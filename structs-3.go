/*
Package ygotsros is a generated package which contains definitions
of structs which represent a YANG schema. The generated schema can be
compressed by a series of transformations (compression was false
in this case).

This package was generated by /home/hans/go/pkg/mod/github.com/openconfig/ygot@v0.20.0/genutil/names.go
using the following YANG input files:
	- nokia/YANG/nokia-combined/nokia-conf.yang
Imported modules were sourced from:
	- nokia/YANG/...
*/
package ygotsros

import (
	"fmt"
	"reflect"

	"github.com/openconfig/ygot/ygot"
	"github.com/openconfig/ygot/ytypes"
)

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-exception/entry/match/dst-port/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range struct {
	End   *uint16 `path:"end" module:"nokia-conf"`
	Start *uint16 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range) GetEnd() uint16 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range) GetStart() uint16 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_DstPort_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp represents the /nokia-conf/configure/groups/group/filter/ipv6-exception/entry/match/icmp YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp struct {
	Code *int32 `path:"code" module:"nokia-conf"`
	Type *int32 `path:"type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp) GetCode() int32 {
	if t == nil || t.Code == nil {
		return 0
	}
	return *t.Code
}

// GetType retrieves the value of the leaf Type from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp) GetType() int32 {
	if t == nil || t.Type == nil {
		return 0
	}
	return *t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Icmp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port represents the /nokia-conf/configure/groups/group/filter/ipv6-exception/entry/match/port YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port struct {
	Eq       *uint16                                                                       `path:"eq" module:"nokia-conf"`
	Gt       *uint16                                                                       `path:"gt" module:"nokia-conf"`
	Lt       *uint16                                                                       `path:"lt" module:"nokia-conf"`
	PortList *string                                                                       `path:"port-list" module:"nokia-conf"`
	Range    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetEq retrieves the value of the leaf Eq from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Eq is set, it can
// safely use t.GetEq() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Eq == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port) GetEq() uint16 {
	if t == nil || t.Eq == nil {
		return 0
	}
	return *t.Eq
}

// GetGt retrieves the value of the leaf Gt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Gt is set, it can
// safely use t.GetGt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Gt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port) GetGt() uint16 {
	if t == nil || t.Gt == nil {
		return 0
	}
	return *t.Gt
}

// GetLt retrieves the value of the leaf Lt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lt is set, it can
// safely use t.GetLt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port) GetLt() uint16 {
	if t == nil || t.Lt == nil {
		return 0
	}
	return *t.Lt
}

// GetPortList retrieves the value of the leaf PortList from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortList is set, it can
// safely use t.GetPortList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortList == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port) GetPortList() string {
	if t == nil || t.PortList == nil {
		return ""
	}
	return *t.PortList
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-exception/entry/match/port/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range struct {
	End   *uint16 `path:"end" module:"nokia-conf"`
	Start *uint16 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range) GetEnd() uint16 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range) GetStart() uint16 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_Port_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp represents the /nokia-conf/configure/groups/group/filter/ipv6-exception/entry/match/src-ip YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp struct {
	Address        *string `path:"address" module:"nokia-conf"`
	Ipv6PrefixList *string `path:"ipv6-prefix-list" module:"nokia-conf"`
	Mask           *string `path:"mask" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetIpv6PrefixList retrieves the value of the leaf Ipv6PrefixList from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6PrefixList is set, it can
// safely use t.GetIpv6PrefixList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6PrefixList == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp) GetIpv6PrefixList() string {
	if t == nil || t.Ipv6PrefixList == nil {
		return ""
	}
	return *t.Ipv6PrefixList
}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcIp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort represents the /nokia-conf/configure/groups/group/filter/ipv6-exception/entry/match/src-port YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort struct {
	Eq       *uint16                                                                          `path:"eq" module:"nokia-conf"`
	Gt       *uint16                                                                          `path:"gt" module:"nokia-conf"`
	Lt       *uint16                                                                          `path:"lt" module:"nokia-conf"`
	PortList *string                                                                          `path:"port-list" module:"nokia-conf"`
	Range    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetEq retrieves the value of the leaf Eq from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Eq is set, it can
// safely use t.GetEq() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Eq == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort) GetEq() uint16 {
	if t == nil || t.Eq == nil {
		return 0
	}
	return *t.Eq
}

// GetGt retrieves the value of the leaf Gt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Gt is set, it can
// safely use t.GetGt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Gt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort) GetGt() uint16 {
	if t == nil || t.Gt == nil {
		return 0
	}
	return *t.Gt
}

// GetLt retrieves the value of the leaf Lt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lt is set, it can
// safely use t.GetLt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort) GetLt() uint16 {
	if t == nil || t.Lt == nil {
		return 0
	}
	return *t.Lt
}

// GetPortList retrieves the value of the leaf PortList from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortList is set, it can
// safely use t.GetPortList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortList == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort) GetPortList() string {
	if t == nil || t.PortList == nil {
		return ""
	}
	return *t.PortList
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-exception/entry/match/src-port/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range struct {
	End   *uint16 `path:"end" module:"nokia-conf"`
	Start *uint16 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range) GetEnd() uint16 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range) GetStart() uint16 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Exception_Entry_Match_SrcPort_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter represents the /nokia-conf/configure/groups/group/filter/ipv6-filter YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter struct {
	ChainToSystemFilter *bool                                                                                                                                `path:"chain-to-system-filter" module:"nokia-conf"`
	DefaultAction       E_NokiaTypesFilter_FilterDefaultAction                                                                                               `path:"default-action" module:"nokia-conf"`
	Description         *string                                                                                                                              `path:"description" module:"nokia-conf"`
	Embed               *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed                                                                            `path:"embed" module:"nokia-conf"`
	Entry               map[NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_EntryId_Union]*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry `path:"entry" module:"nokia-conf"`
	FilterId            *uint32                                                                                                                              `path:"filter-id" module:"nokia-conf"`
	FilterName          *string                                                                                                                              `path:"filter-name" module:"nokia-conf"`
	Scope               E_NokiaTypesFilter_FilterScope                                                                                                       `path:"scope" module:"nokia-conf"`
	SubscriberMgmt      *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt                                                                   `path:"subscriber-mgmt" module:"nokia-conf"`
	Type                E_NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Type                                                                            `path:"type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) NewEntry(EntryId NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_EntryId_Union) (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_EntryId_Union]*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry)
	}

	key := EntryId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry{
		EntryId: EntryId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_EntryId_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.EntryId = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetOrCreateEntry(EntryId NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_EntryId_Union) *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry {

	key := EntryId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(EntryId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetEntry(EntryId NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_EntryId_Union) *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry {

	if t == nil {
		return nil
	}

	key := EntryId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) DeleteEntry(EntryId NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_EntryId_Union) {
	key := EntryId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) AppendEntry(v *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) error {
	key := v.EntryId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_EntryId_Union]*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetOrCreateEmbed retrieves the value of the Embed field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetOrCreateEmbed() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed {
	if t.Embed != nil {
		return t.Embed
	}
	t.Embed = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed{}
	return t.Embed
}

// GetOrCreateSubscriberMgmt retrieves the value of the SubscriberMgmt field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetOrCreateSubscriberMgmt() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt {
	if t.SubscriberMgmt != nil {
		return t.SubscriberMgmt
	}
	t.SubscriberMgmt = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt{}
	return t.SubscriberMgmt
}

// GetEmbed returns the value of the Embed struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter. If the receiver or the field Embed is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetEmbed() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed {
	if t != nil && t.Embed != nil {
		return t.Embed
	}
	return nil
}

// GetSubscriberMgmt returns the value of the SubscriberMgmt struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter. If the receiver or the field SubscriberMgmt is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetSubscriberMgmt() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt {
	if t != nil && t.SubscriberMgmt != nil {
		return t.SubscriberMgmt
	}
	return nil
}

// GetChainToSystemFilter retrieves the value of the leaf ChainToSystemFilter from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ChainToSystemFilter is set, it can
// safely use t.GetChainToSystemFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ChainToSystemFilter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetChainToSystemFilter() bool {
	if t == nil || t.ChainToSystemFilter == nil {
		return false
	}
	return *t.ChainToSystemFilter
}

// GetDefaultAction retrieves the value of the leaf DefaultAction from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultAction is set, it can
// safely use t.GetDefaultAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultAction == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetDefaultAction() E_NokiaTypesFilter_FilterDefaultAction {
	if t == nil || t.DefaultAction == 0 {
		return NokiaTypesFilter_FilterDefaultAction_drop
	}
	return t.DefaultAction
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilterId retrieves the value of the leaf FilterId from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FilterId is set, it can
// safely use t.GetFilterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FilterId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetFilterId() uint32 {
	if t == nil || t.FilterId == nil {
		return 0
	}
	return *t.FilterId
}

// GetFilterName retrieves the value of the leaf FilterName from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FilterName is set, it can
// safely use t.GetFilterName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FilterName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetFilterName() string {
	if t == nil || t.FilterName == nil {
		return ""
	}
	return *t.FilterName
}

// GetScope retrieves the value of the leaf Scope from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Scope is set, it can
// safely use t.GetScope() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Scope == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetScope() E_NokiaTypesFilter_FilterScope {
	if t == nil || t.Scope == 0 {
		return NokiaTypesFilter_FilterScope_template
	}
	return t.Scope
}

// GetType retrieves the value of the leaf Type from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) GetType() E_NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Type {
	if t == nil || t.Type == 0 {
		return NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Type_normal
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ChainToSystemFilter == nil {
		var v bool = false
		t.ChainToSystemFilter = &v
	}
	if t.DefaultAction == 0 {
		t.DefaultAction = NokiaTypesFilter_FilterDefaultAction_drop
	}
	if t.Scope == 0 {
		t.Scope = NokiaTypesFilter_FilterScope_template
	}
	if t.Type == 0 {
		t.Type = NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Type_normal
	}
	t.Embed.PopulateDefaults()
	t.SubscriberMgmt.PopulateDefaults()
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FilterName == nil {
		return nil, fmt.Errorf("nil value for key FilterName")
	}

	return map[string]interface{}{
		"filter-name": *t.FilterName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/embed YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed struct {
	Filter   map[NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Key]*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter              `path:"filter" module:"nokia-conf"`
	Flowspec map[NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec_Offset_Union]*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec `path:"flowspec" module:"nokia-conf"`
	Openflow map[NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Key]*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow          `path:"openflow" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) IsYANGGoStruct() {}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Key represents the key for list Filter of element /nokia-conf/configure/groups/group/filter/ipv6-filter/embed.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Key struct {
	Name   string                                                                       `path:"name"`
	Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Offset_Union `path:"offset"`
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Key represents the key for list Openflow of element /nokia-conf/configure/groups/group/filter/ipv6-filter/embed.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Key struct {
	OfSwitch string                                                                         `path:"of-switch"`
	Offset   NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Offset_Union `path:"offset"`
}

// NewFilter creates a new entry in the Filter list of the
// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) NewFilter(Name string, Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Offset_Union) (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Filter == nil {
		t.Filter = make(map[NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Key]*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter)
	}

	key := NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Key{
		Name:   Name,
		Offset: Offset,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Filter", key)
	}

	t.Filter[key] = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter{
		Name:   &Name,
		Offset: Offset,
	}

	return t.Filter[key], nil
}

// RenameFilter renames an entry in the list Filter within
// the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) RenameFilter(oldK, newK NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Key) error {
	if _, ok := t.Filter[newK]; ok {
		return fmt.Errorf("key %v already exists in Filter", newK)
	}

	e, ok := t.Filter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Filter", oldK)
	}
	e.Name = &newK.Name
	e.Offset = newK.Offset

	t.Filter[newK] = e
	delete(t.Filter, oldK)
	return nil
}

// GetOrCreateFilter retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) GetOrCreateFilter(Name string, Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Offset_Union) *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter {

	key := NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Key{
		Name:   Name,
		Offset: Offset,
	}

	if v, ok := t.Filter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFilter(Name, Offset)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFilter got unexpected error: %v", err))
	}
	return v
}

// GetFilter retrieves the value with the specified key from
// the Filter map field of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) GetFilter(Name string, Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Offset_Union) *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter {

	if t == nil {
		return nil
	}

	key := NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Key{
		Name:   Name,
		Offset: Offset,
	}

	if lm, ok := t.Filter[key]; ok {
		return lm
	}
	return nil
}

// DeleteFilter deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) DeleteFilter(Name string, Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Offset_Union) {
	key := NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Key{
		Name:   Name,
		Offset: Offset,
	}

	delete(t.Filter, key)
}

// AppendFilter appends the supplied NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter struct to the
// list Filter of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) AppendFilter(v *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key for Name")
	}

	key := NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Key{
		Name:   *v.Name,
		Offset: v.Offset,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Filter == nil {
		t.Filter = make(map[NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Key]*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter)
	}

	if _, ok := t.Filter[key]; ok {
		return fmt.Errorf("duplicate key for list Filter %v", key)
	}

	t.Filter[key] = v
	return nil
}

// NewFlowspec creates a new entry in the Flowspec list of the
// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) NewFlowspec(Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec_Offset_Union) (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Flowspec == nil {
		t.Flowspec = make(map[NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec_Offset_Union]*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec)
	}

	key := Offset

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Flowspec[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Flowspec", key)
	}

	t.Flowspec[key] = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec{
		Offset: Offset,
	}

	return t.Flowspec[key], nil
}

// RenameFlowspec renames an entry in the list Flowspec within
// the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) RenameFlowspec(oldK, newK NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec_Offset_Union) error {
	if _, ok := t.Flowspec[newK]; ok {
		return fmt.Errorf("key %v already exists in Flowspec", newK)
	}

	e, ok := t.Flowspec[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Flowspec", oldK)
	}
	e.Offset = newK

	t.Flowspec[newK] = e
	delete(t.Flowspec, oldK)
	return nil
}

// GetOrCreateFlowspec retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) GetOrCreateFlowspec(Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec_Offset_Union) *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec {

	key := Offset

	if v, ok := t.Flowspec[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFlowspec(Offset)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFlowspec got unexpected error: %v", err))
	}
	return v
}

// GetFlowspec retrieves the value with the specified key from
// the Flowspec map field of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) GetFlowspec(Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec_Offset_Union) *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec {

	if t == nil {
		return nil
	}

	key := Offset

	if lm, ok := t.Flowspec[key]; ok {
		return lm
	}
	return nil
}

// DeleteFlowspec deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) DeleteFlowspec(Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec_Offset_Union) {
	key := Offset

	delete(t.Flowspec, key)
}

// AppendFlowspec appends the supplied NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec struct to the
// list Flowspec of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) AppendFlowspec(v *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec) error {
	key := v.Offset

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Flowspec == nil {
		t.Flowspec = make(map[NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec_Offset_Union]*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec)
	}

	if _, ok := t.Flowspec[key]; ok {
		return fmt.Errorf("duplicate key for list Flowspec %v", key)
	}

	t.Flowspec[key] = v
	return nil
}

// NewOpenflow creates a new entry in the Openflow list of the
// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) NewOpenflow(OfSwitch string, Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Offset_Union) (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Openflow == nil {
		t.Openflow = make(map[NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Key]*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow)
	}

	key := NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Key{
		OfSwitch: OfSwitch,
		Offset:   Offset,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Openflow[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Openflow", key)
	}

	t.Openflow[key] = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow{
		OfSwitch: &OfSwitch,
		Offset:   Offset,
	}

	return t.Openflow[key], nil
}

// RenameOpenflow renames an entry in the list Openflow within
// the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) RenameOpenflow(oldK, newK NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Key) error {
	if _, ok := t.Openflow[newK]; ok {
		return fmt.Errorf("key %v already exists in Openflow", newK)
	}

	e, ok := t.Openflow[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Openflow", oldK)
	}
	e.OfSwitch = &newK.OfSwitch
	e.Offset = newK.Offset

	t.Openflow[newK] = e
	delete(t.Openflow, oldK)
	return nil
}

// GetOrCreateOpenflow retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) GetOrCreateOpenflow(OfSwitch string, Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Offset_Union) *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow {

	key := NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Key{
		OfSwitch: OfSwitch,
		Offset:   Offset,
	}

	if v, ok := t.Openflow[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewOpenflow(OfSwitch, Offset)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateOpenflow got unexpected error: %v", err))
	}
	return v
}

// GetOpenflow retrieves the value with the specified key from
// the Openflow map field of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) GetOpenflow(OfSwitch string, Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Offset_Union) *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow {

	if t == nil {
		return nil
	}

	key := NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Key{
		OfSwitch: OfSwitch,
		Offset:   Offset,
	}

	if lm, ok := t.Openflow[key]; ok {
		return lm
	}
	return nil
}

// DeleteOpenflow deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) DeleteOpenflow(OfSwitch string, Offset NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Offset_Union) {
	key := NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Key{
		OfSwitch: OfSwitch,
		Offset:   Offset,
	}

	delete(t.Openflow, key)
}

// AppendOpenflow appends the supplied NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow struct to the
// list Openflow of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) AppendOpenflow(v *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) error {
	if v.OfSwitch == nil {
		return fmt.Errorf("invalid nil key for OfSwitch")
	}

	key := NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Key{
		OfSwitch: *v.OfSwitch,
		Offset:   v.Offset,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Openflow == nil {
		t.Openflow = make(map[NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Key]*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow)
	}

	if _, ok := t.Openflow[key]; ok {
		return fmt.Errorf("duplicate key for list Openflow %v", key)
	}

	t.Openflow[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Filter {
		e.PopulateDefaults()
	}
	for _, e := range t.Flowspec {
		e.PopulateDefaults()
	}
	for _, e := range t.Openflow {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/embed/filter YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter struct {
	AdminState E_NokiaTypesSros_AdminState                                                  `path:"admin-state" module:"nokia-conf"`
	Name       *string                                                                      `path:"name" module:"nokia-conf"`
	Offset     NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Offset_Union `path:"offset" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOffset retrieves the value of the leaf Offset from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Offset is set, it can
// safely use t.GetOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Offset == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter) GetOffset() NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter_Offset_Union {
	if t == nil || t.Offset == nil {
		return nil
	}
	return t.Offset
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name":   *t.Name,
		"offset": t.Offset,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Filter) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/embed/flowspec YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec struct {
	AdminState     E_NokiaTypesSros_AdminState                                                    `path:"admin-state" module:"nokia-conf"`
	Group          *uint32                                                                        `path:"group" module:"nokia-conf"`
	Offset         NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec_Offset_Union `path:"offset" module:"nokia-conf"`
	RouterInstance *string                                                                        `path:"router-instance" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetGroup retrieves the value of the leaf Group from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Group is set, it can
// safely use t.GetGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Group == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec) GetGroup() uint32 {
	if t == nil || t.Group == nil {
		return 0
	}
	return *t.Group
}

// GetOffset retrieves the value of the leaf Offset from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Offset is set, it can
// safely use t.GetOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Offset == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec) GetOffset() NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec_Offset_Union {
	if t == nil || t.Offset == nil {
		return nil
	}
	return t.Offset
}

// GetRouterInstance retrieves the value of the leaf RouterInstance from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterInstance is set, it can
// safely use t.GetRouterInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterInstance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec) GetRouterInstance() string {
	if t == nil || t.RouterInstance == nil {
		return ""
	}
	return *t.RouterInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"offset": t.Offset,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Flowspec) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/embed/openflow YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow struct {
	AdminState E_NokiaTypesSros_AdminState                                                    `path:"admin-state" module:"nokia-conf"`
	Grt        YANGEmpty                                                                      `path:"grt" module:"nokia-conf"`
	OfSwitch   *string                                                                        `path:"of-switch" module:"nokia-conf"`
	Offset     NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Offset_Union `path:"offset" module:"nokia-conf"`
	Sap        *string                                                                        `path:"sap" module:"nokia-conf"`
	System     YANGEmpty                                                                      `path:"system" module:"nokia-conf"`
	Vpls       *string                                                                        `path:"vpls" module:"nokia-conf"`
	Vprn       *string                                                                        `path:"vprn" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetGrt retrieves the value of the leaf Grt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Grt is set, it can
// safely use t.GetGrt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Grt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) GetGrt() YANGEmpty {
	if t == nil || t.Grt == false {
		return false
	}
	return t.Grt
}

// GetOfSwitch retrieves the value of the leaf OfSwitch from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OfSwitch is set, it can
// safely use t.GetOfSwitch() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OfSwitch == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) GetOfSwitch() string {
	if t == nil || t.OfSwitch == nil {
		return ""
	}
	return *t.OfSwitch
}

// GetOffset retrieves the value of the leaf Offset from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Offset is set, it can
// safely use t.GetOffset() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Offset == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) GetOffset() NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow_Offset_Union {
	if t == nil || t.Offset == nil {
		return nil
	}
	return t.Offset
}

// GetSap retrieves the value of the leaf Sap from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Sap is set, it can
// safely use t.GetSap() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Sap == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) GetSap() string {
	if t == nil || t.Sap == nil {
		return ""
	}
	return *t.Sap
}

// GetSystem retrieves the value of the leaf System from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if System is set, it can
// safely use t.GetSystem() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.System == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) GetSystem() YANGEmpty {
	if t == nil || t.System == false {
		return false
	}
	return t.System
}

// GetVpls retrieves the value of the leaf Vpls from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpls is set, it can
// safely use t.GetVpls() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpls == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) GetVpls() string {
	if t == nil || t.Vpls == nil {
		return ""
	}
	return *t.Vpls
}

// GetVprn retrieves the value of the leaf Vprn from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vprn is set, it can
// safely use t.GetVprn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vprn == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) GetVprn() string {
	if t == nil || t.Vprn == nil {
		return ""
	}
	return *t.Vprn
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) ΛListKeyMap() (map[string]interface{}, error) {
	if t.OfSwitch == nil {
		return nil, fmt.Errorf("nil value for key OfSwitch")
	}

	return map[string]interface{}{
		"of-switch": *t.OfSwitch,
		"offset":    t.Offset,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Embed_Openflow) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry struct {
	Action                *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action          `path:"action" module:"nokia-conf" yangPresence:"true"`
	CollectStats          *bool                                                                     `path:"collect-stats" module:"nokia-conf"`
	Description           *string                                                                   `path:"description" module:"nokia-conf"`
	EgressPbr             E_NokiaTypesFilter_FilterEgressPbr                                        `path:"egress-pbr" module:"nokia-conf"`
	EntryId               NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_EntryId_Union    `path:"entry-id" module:"nokia-conf"`
	FilterSample          *bool                                                                     `path:"filter-sample" module:"nokia-conf"`
	InterfaceSample       *bool                                                                     `path:"interface-sample" module:"nokia-conf"`
	Log                   *uint32                                                                   `path:"log" module:"nokia-conf"`
	Match                 *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match           `path:"match" module:"nokia-conf"`
	PbrDownActionOverride E_NokiaTypesFilter_FilterPbrDownActionOvr                                 `path:"pbr-down-action-override" module:"nokia-conf"`
	SampleProfile         *uint32                                                                   `path:"sample-profile" module:"nokia-conf"`
	StickyDest            NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_StickyDest_Union `path:"sticky-dest" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetOrCreateAction() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetOrCreateMatch() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetAction() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetMatch() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetCollectStats retrieves the value of the leaf CollectStats from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CollectStats is set, it can
// safely use t.GetCollectStats() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CollectStats == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetCollectStats() bool {
	if t == nil || t.CollectStats == nil {
		return false
	}
	return *t.CollectStats
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEgressPbr retrieves the value of the leaf EgressPbr from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EgressPbr is set, it can
// safely use t.GetEgressPbr() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EgressPbr == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetEgressPbr() E_NokiaTypesFilter_FilterEgressPbr {
	if t == nil || t.EgressPbr == 0 {
		return 0
	}
	return t.EgressPbr
}

// GetEntryId retrieves the value of the leaf EntryId from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryId is set, it can
// safely use t.GetEntryId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetEntryId() NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_EntryId_Union {
	if t == nil || t.EntryId == nil {
		return nil
	}
	return t.EntryId
}

// GetFilterSample retrieves the value of the leaf FilterSample from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FilterSample is set, it can
// safely use t.GetFilterSample() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FilterSample == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetFilterSample() bool {
	if t == nil || t.FilterSample == nil {
		return false
	}
	return *t.FilterSample
}

// GetInterfaceSample retrieves the value of the leaf InterfaceSample from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceSample is set, it can
// safely use t.GetInterfaceSample() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceSample == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetInterfaceSample() bool {
	if t == nil || t.InterfaceSample == nil {
		return true
	}
	return *t.InterfaceSample
}

// GetLog retrieves the value of the leaf Log from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetLog() uint32 {
	if t == nil || t.Log == nil {
		return 0
	}
	return *t.Log
}

// GetPbrDownActionOverride retrieves the value of the leaf PbrDownActionOverride from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PbrDownActionOverride is set, it can
// safely use t.GetPbrDownActionOverride() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PbrDownActionOverride == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetPbrDownActionOverride() E_NokiaTypesFilter_FilterPbrDownActionOvr {
	if t == nil || t.PbrDownActionOverride == 0 {
		return 0
	}
	return t.PbrDownActionOverride
}

// GetSampleProfile retrieves the value of the leaf SampleProfile from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SampleProfile is set, it can
// safely use t.GetSampleProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SampleProfile == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetSampleProfile() uint32 {
	if t == nil || t.SampleProfile == nil {
		return 0
	}
	return *t.SampleProfile
}

// GetStickyDest retrieves the value of the leaf StickyDest from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StickyDest is set, it can
// safely use t.GetStickyDest() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StickyDest == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) GetStickyDest() NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_StickyDest_Union {
	if t == nil || t.StickyDest == nil {
		return nil
	}
	return t.StickyDest
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CollectStats == nil {
		var v bool = false
		t.CollectStats = &v
	}
	if t.FilterSample == nil {
		var v bool = false
		t.FilterSample = &v
	}
	if t.InterfaceSample == nil {
		var v bool = true
		t.InterfaceSample = &v
	}
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"entry-id": t.EntryId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action struct {
	Accept       YANGEmpty                                                                     `path:"accept" module:"nokia-conf"`
	AcceptWhen   *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen   `path:"accept-when" module:"nokia-conf" yangPresence:"true"`
	Drop         YANGEmpty                                                                     `path:"drop" module:"nokia-conf"`
	DropWhen     *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen     `path:"drop-when" module:"nokia-conf" yangPresence:"true"`
	Fc           E_NokiaTypesSros_FcName                                                       `path:"fc" module:"nokia-conf"`
	Forward      *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward      `path:"forward" module:"nokia-conf"`
	HttpRedirect *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect `path:"http-redirect" module:"nokia-conf" yangPresence:"true"`
	IgnoreMatch  YANGEmpty                                                                     `path:"ignore-match" module:"nokia-conf"`
	Nat          *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat          `path:"nat" module:"nokia-conf" yangPresence:"true"`
	RateLimit    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit    `path:"rate-limit" module:"nokia-conf" yangPresence:"true"`
	Remark       *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark       `path:"remark" module:"nokia-conf" yangPresence:"true"`
	Secondary    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary    `path:"secondary" module:"nokia-conf" yangPresence:"true"`
	TcpMssAdjust YANGEmpty                                                                     `path:"tcp-mss-adjust" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateAcceptWhen retrieves the value of the AcceptWhen field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetOrCreateAcceptWhen() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen {
	if t.AcceptWhen != nil {
		return t.AcceptWhen
	}
	t.AcceptWhen = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen{}
	return t.AcceptWhen
}

// GetOrCreateDropWhen retrieves the value of the DropWhen field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetOrCreateDropWhen() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen {
	if t.DropWhen != nil {
		return t.DropWhen
	}
	t.DropWhen = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen{}
	return t.DropWhen
}

// GetOrCreateForward retrieves the value of the Forward field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetOrCreateForward() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward {
	if t.Forward != nil {
		return t.Forward
	}
	t.Forward = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward{}
	return t.Forward
}

// GetOrCreateHttpRedirect retrieves the value of the HttpRedirect field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetOrCreateHttpRedirect() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect {
	if t.HttpRedirect != nil {
		return t.HttpRedirect
	}
	t.HttpRedirect = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect{}
	return t.HttpRedirect
}

// GetOrCreateNat retrieves the value of the Nat field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetOrCreateNat() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat {
	if t.Nat != nil {
		return t.Nat
	}
	t.Nat = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat{}
	return t.Nat
}

// GetOrCreateRateLimit retrieves the value of the RateLimit field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetOrCreateRateLimit() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit {
	if t.RateLimit != nil {
		return t.RateLimit
	}
	t.RateLimit = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit{}
	return t.RateLimit
}

// GetOrCreateRemark retrieves the value of the Remark field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetOrCreateRemark() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark {
	if t.Remark != nil {
		return t.Remark
	}
	t.Remark = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark{}
	return t.Remark
}

// GetOrCreateSecondary retrieves the value of the Secondary field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetOrCreateSecondary() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary {
	if t.Secondary != nil {
		return t.Secondary
	}
	t.Secondary = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary{}
	return t.Secondary
}

// GetAcceptWhen returns the value of the AcceptWhen struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action. If the receiver or the field AcceptWhen is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetAcceptWhen() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen {
	if t != nil && t.AcceptWhen != nil {
		return t.AcceptWhen
	}
	return nil
}

// GetDropWhen returns the value of the DropWhen struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action. If the receiver or the field DropWhen is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetDropWhen() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen {
	if t != nil && t.DropWhen != nil {
		return t.DropWhen
	}
	return nil
}

// GetForward returns the value of the Forward struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action. If the receiver or the field Forward is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetForward() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward {
	if t != nil && t.Forward != nil {
		return t.Forward
	}
	return nil
}

// GetHttpRedirect returns the value of the HttpRedirect struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action. If the receiver or the field HttpRedirect is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetHttpRedirect() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect {
	if t != nil && t.HttpRedirect != nil {
		return t.HttpRedirect
	}
	return nil
}

// GetNat returns the value of the Nat struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action. If the receiver or the field Nat is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetNat() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat {
	if t != nil && t.Nat != nil {
		return t.Nat
	}
	return nil
}

// GetRateLimit returns the value of the RateLimit struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action. If the receiver or the field RateLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetRateLimit() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit {
	if t != nil && t.RateLimit != nil {
		return t.RateLimit
	}
	return nil
}

// GetRemark returns the value of the Remark struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action. If the receiver or the field Remark is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetRemark() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark {
	if t != nil && t.Remark != nil {
		return t.Remark
	}
	return nil
}

// GetSecondary returns the value of the Secondary struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action. If the receiver or the field Secondary is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetSecondary() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary {
	if t != nil && t.Secondary != nil {
		return t.Secondary
	}
	return nil
}

// GetAccept retrieves the value of the leaf Accept from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Accept is set, it can
// safely use t.GetAccept() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Accept == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetAccept() YANGEmpty {
	if t == nil || t.Accept == false {
		return false
	}
	return t.Accept
}

// GetDrop retrieves the value of the leaf Drop from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Drop is set, it can
// safely use t.GetDrop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Drop == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetDrop() YANGEmpty {
	if t == nil || t.Drop == false {
		return false
	}
	return t.Drop
}

// GetFc retrieves the value of the leaf Fc from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fc is set, it can
// safely use t.GetFc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fc == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetFc() E_NokiaTypesSros_FcName {
	if t == nil || t.Fc == 0 {
		return 0
	}
	return t.Fc
}

// GetIgnoreMatch retrieves the value of the leaf IgnoreMatch from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IgnoreMatch is set, it can
// safely use t.GetIgnoreMatch() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IgnoreMatch == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetIgnoreMatch() YANGEmpty {
	if t == nil || t.IgnoreMatch == false {
		return false
	}
	return t.IgnoreMatch
}

// GetTcpMssAdjust retrieves the value of the leaf TcpMssAdjust from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpMssAdjust is set, it can
// safely use t.GetTcpMssAdjust() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpMssAdjust == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) GetTcpMssAdjust() YANGEmpty {
	if t == nil || t.TcpMssAdjust == false {
		return false
	}
	return t.TcpMssAdjust
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AcceptWhen.PopulateDefaults()
	t.DropWhen.PopulateDefaults()
	t.Forward.PopulateDefaults()
	t.HttpRedirect.PopulateDefaults()
	t.Nat.PopulateDefaults()
	t.RateLimit.PopulateDefaults()
	t.Remark.PopulateDefaults()
	t.Secondary.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/accept-when YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen struct {
	Pattern *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern `path:"pattern" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen) IsYANGGoStruct() {}

// GetOrCreatePattern retrieves the value of the Pattern field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen) GetOrCreatePattern() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern {
	if t.Pattern != nil {
		return t.Pattern
	}
	t.Pattern = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern{}
	return t.Pattern
}

// GetPattern returns the value of the Pattern struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen. If the receiver or the field Pattern is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen) GetPattern() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern {
	if t != nil && t.Pattern != nil {
		return t.Pattern
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Pattern.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/accept-when/pattern YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern struct {
	Expression  *string                                                                                         `path:"expression" module:"nokia-conf"`
	Mask        *string                                                                                         `path:"mask" module:"nokia-conf"`
	OffsetType  E_NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern_OffsetType `path:"offset-type" module:"nokia-conf"`
	OffsetValue *int32                                                                                          `path:"offset-value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern) IsYANGGoStruct() {
}

// GetExpression retrieves the value of the leaf Expression from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Expression is set, it can
// safely use t.GetExpression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Expression == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern) GetExpression() string {
	if t == nil || t.Expression == nil {
		return ""
	}
	return *t.Expression
}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetOffsetType retrieves the value of the leaf OffsetType from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OffsetType is set, it can
// safely use t.GetOffsetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OffsetType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern) GetOffsetType() E_NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern_OffsetType {
	if t == nil || t.OffsetType == 0 {
		return 0
	}
	return t.OffsetType
}

// GetOffsetValue retrieves the value of the leaf OffsetValue from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OffsetValue is set, it can
// safely use t.GetOffsetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OffsetValue == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern) GetOffsetValue() int32 {
	if t == nil || t.OffsetValue == nil {
		return 0
	}
	return *t.OffsetValue
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_AcceptWhen_Pattern) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/drop-when YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen struct {
	ExtractedTraffic YANGEmpty                                                                               `path:"extracted-traffic" module:"nokia-conf"`
	HopLimit         *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit      `path:"hop-limit" module:"nokia-conf" yangPresence:"true"`
	Pattern          *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern       `path:"pattern" module:"nokia-conf" yangPresence:"true"`
	PayloadLength    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength `path:"payload-length" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) IsYANGGoStruct() {}

// GetOrCreateHopLimit retrieves the value of the HopLimit field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) GetOrCreateHopLimit() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit {
	if t.HopLimit != nil {
		return t.HopLimit
	}
	t.HopLimit = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit{}
	return t.HopLimit
}

// GetOrCreatePattern retrieves the value of the Pattern field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) GetOrCreatePattern() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern {
	if t.Pattern != nil {
		return t.Pattern
	}
	t.Pattern = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern{}
	return t.Pattern
}

// GetOrCreatePayloadLength retrieves the value of the PayloadLength field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) GetOrCreatePayloadLength() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength {
	if t.PayloadLength != nil {
		return t.PayloadLength
	}
	t.PayloadLength = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength{}
	return t.PayloadLength
}

// GetHopLimit returns the value of the HopLimit struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen. If the receiver or the field HopLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) GetHopLimit() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit {
	if t != nil && t.HopLimit != nil {
		return t.HopLimit
	}
	return nil
}

// GetPattern returns the value of the Pattern struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen. If the receiver or the field Pattern is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) GetPattern() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern {
	if t != nil && t.Pattern != nil {
		return t.Pattern
	}
	return nil
}

// GetPayloadLength returns the value of the PayloadLength struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen. If the receiver or the field PayloadLength is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) GetPayloadLength() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength {
	if t != nil && t.PayloadLength != nil {
		return t.PayloadLength
	}
	return nil
}

// GetExtractedTraffic retrieves the value of the leaf ExtractedTraffic from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExtractedTraffic is set, it can
// safely use t.GetExtractedTraffic() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExtractedTraffic == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) GetExtractedTraffic() YANGEmpty {
	if t == nil || t.ExtractedTraffic == false {
		return false
	}
	return t.ExtractedTraffic
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.HopLimit.PopulateDefaults()
	t.Pattern.PopulateDefaults()
	t.PayloadLength.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/drop-when/hop-limit YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit struct {
	Eq    *int32                                                                                   `path:"eq" module:"nokia-conf"`
	Gt    *int32                                                                                   `path:"gt" module:"nokia-conf"`
	Lt    *int32                                                                                   `path:"lt" module:"nokia-conf"`
	Range *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit) IsYANGGoStruct() {
}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetEq retrieves the value of the leaf Eq from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Eq is set, it can
// safely use t.GetEq() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Eq == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit) GetEq() int32 {
	if t == nil || t.Eq == nil {
		return 0
	}
	return *t.Eq
}

// GetGt retrieves the value of the leaf Gt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Gt is set, it can
// safely use t.GetGt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Gt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit) GetGt() int32 {
	if t == nil || t.Gt == nil {
		return 0
	}
	return *t.Gt
}

// GetLt retrieves the value of the leaf Lt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lt is set, it can
// safely use t.GetLt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit) GetLt() int32 {
	if t == nil || t.Lt == nil {
		return 0
	}
	return *t.Lt
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/drop-when/hop-limit/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range struct {
	End   *int32 `path:"end" module:"nokia-conf"`
	Start *int32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range) GetEnd() int32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range) GetStart() int32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_HopLimit_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/drop-when/pattern YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern struct {
	Expression  *string                                                                                       `path:"expression" module:"nokia-conf"`
	Mask        *string                                                                                       `path:"mask" module:"nokia-conf"`
	OffsetType  E_NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern_OffsetType `path:"offset-type" module:"nokia-conf"`
	OffsetValue *int32                                                                                        `path:"offset-value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern) IsYANGGoStruct() {
}

// GetExpression retrieves the value of the leaf Expression from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Expression is set, it can
// safely use t.GetExpression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Expression == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern) GetExpression() string {
	if t == nil || t.Expression == nil {
		return ""
	}
	return *t.Expression
}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetOffsetType retrieves the value of the leaf OffsetType from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OffsetType is set, it can
// safely use t.GetOffsetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OffsetType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern) GetOffsetType() E_NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern_OffsetType {
	if t == nil || t.OffsetType == 0 {
		return 0
	}
	return t.OffsetType
}

// GetOffsetValue retrieves the value of the leaf OffsetValue from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OffsetValue is set, it can
// safely use t.GetOffsetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OffsetValue == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern) GetOffsetValue() int32 {
	if t == nil || t.OffsetValue == nil {
		return 0
	}
	return *t.OffsetValue
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_Pattern) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/drop-when/payload-length YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength struct {
	Eq    *int32                                                                                        `path:"eq" module:"nokia-conf"`
	Gt    *int32                                                                                        `path:"gt" module:"nokia-conf"`
	Lt    *int32                                                                                        `path:"lt" module:"nokia-conf"`
	Range *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength) IsYANGGoStruct() {
}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetEq retrieves the value of the leaf Eq from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Eq is set, it can
// safely use t.GetEq() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Eq == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength) GetEq() int32 {
	if t == nil || t.Eq == nil {
		return 0
	}
	return *t.Eq
}

// GetGt retrieves the value of the leaf Gt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Gt is set, it can
// safely use t.GetGt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Gt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength) GetGt() int32 {
	if t == nil || t.Gt == nil {
		return 0
	}
	return *t.Gt
}

// GetLt retrieves the value of the leaf Lt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lt is set, it can
// safely use t.GetLt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength) GetLt() int32 {
	if t == nil || t.Lt == nil {
		return 0
	}
	return *t.Lt
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/drop-when/payload-length/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range struct {
	End   *int32 `path:"end" module:"nokia-conf"`
	Start *int32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range) GetEnd() int32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range) GetStart() int32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_DropWhen_PayloadLength_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/forward YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward struct {
	BondingConnection *uint32                                                                             `path:"bonding-connection" module:"nokia-conf"`
	EsiL2             *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2      `path:"esi-l2" module:"nokia-conf" yangPresence:"true"`
	EsiL3             *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3      `path:"esi-l3" module:"nokia-conf" yangPresence:"true"`
	GreTunnel         *string                                                                             `path:"gre-tunnel" module:"nokia-conf"`
	Lsp               *string                                                                             `path:"lsp" module:"nokia-conf"`
	MplsPolicy        *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy `path:"mpls-policy" module:"nokia-conf" yangPresence:"true"`
	NextHop           *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop    `path:"next-hop" module:"nokia-conf" yangPresence:"true"`
	RedirectPolicy    *string                                                                             `path:"redirect-policy" module:"nokia-conf"`
	RouterInstance    *string                                                                             `path:"router-instance" module:"nokia-conf"`
	Sap               *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap        `path:"sap" module:"nokia-conf" yangPresence:"true"`
	Sdp               *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp        `path:"sdp" module:"nokia-conf" yangPresence:"true"`
	SrtePolicy        *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy `path:"srte-policy" module:"nokia-conf" yangPresence:"true"`
	VprnTarget        *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget `path:"vprn-target" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) IsYANGGoStruct() {}

// GetOrCreateEsiL2 retrieves the value of the EsiL2 field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetOrCreateEsiL2() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2 {
	if t.EsiL2 != nil {
		return t.EsiL2
	}
	t.EsiL2 = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2{}
	return t.EsiL2
}

// GetOrCreateEsiL3 retrieves the value of the EsiL3 field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetOrCreateEsiL3() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3 {
	if t.EsiL3 != nil {
		return t.EsiL3
	}
	t.EsiL3 = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3{}
	return t.EsiL3
}

// GetOrCreateMplsPolicy retrieves the value of the MplsPolicy field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetOrCreateMplsPolicy() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy {
	if t.MplsPolicy != nil {
		return t.MplsPolicy
	}
	t.MplsPolicy = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy{}
	return t.MplsPolicy
}

// GetOrCreateNextHop retrieves the value of the NextHop field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetOrCreateNextHop() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop {
	if t.NextHop != nil {
		return t.NextHop
	}
	t.NextHop = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop{}
	return t.NextHop
}

// GetOrCreateSap retrieves the value of the Sap field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetOrCreateSap() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap {
	if t.Sap != nil {
		return t.Sap
	}
	t.Sap = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap{}
	return t.Sap
}

// GetOrCreateSdp retrieves the value of the Sdp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetOrCreateSdp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp {
	if t.Sdp != nil {
		return t.Sdp
	}
	t.Sdp = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp{}
	return t.Sdp
}

// GetOrCreateSrtePolicy retrieves the value of the SrtePolicy field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetOrCreateSrtePolicy() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy {
	if t.SrtePolicy != nil {
		return t.SrtePolicy
	}
	t.SrtePolicy = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy{}
	return t.SrtePolicy
}

// GetOrCreateVprnTarget retrieves the value of the VprnTarget field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetOrCreateVprnTarget() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget {
	if t.VprnTarget != nil {
		return t.VprnTarget
	}
	t.VprnTarget = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget{}
	return t.VprnTarget
}

// GetEsiL2 returns the value of the EsiL2 struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward. If the receiver or the field EsiL2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetEsiL2() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2 {
	if t != nil && t.EsiL2 != nil {
		return t.EsiL2
	}
	return nil
}

// GetEsiL3 returns the value of the EsiL3 struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward. If the receiver or the field EsiL3 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetEsiL3() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3 {
	if t != nil && t.EsiL3 != nil {
		return t.EsiL3
	}
	return nil
}

// GetMplsPolicy returns the value of the MplsPolicy struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward. If the receiver or the field MplsPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetMplsPolicy() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy {
	if t != nil && t.MplsPolicy != nil {
		return t.MplsPolicy
	}
	return nil
}

// GetNextHop returns the value of the NextHop struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward. If the receiver or the field NextHop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetNextHop() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop {
	if t != nil && t.NextHop != nil {
		return t.NextHop
	}
	return nil
}

// GetSap returns the value of the Sap struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward. If the receiver or the field Sap is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetSap() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap {
	if t != nil && t.Sap != nil {
		return t.Sap
	}
	return nil
}

// GetSdp returns the value of the Sdp struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward. If the receiver or the field Sdp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetSdp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp {
	if t != nil && t.Sdp != nil {
		return t.Sdp
	}
	return nil
}

// GetSrtePolicy returns the value of the SrtePolicy struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward. If the receiver or the field SrtePolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetSrtePolicy() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy {
	if t != nil && t.SrtePolicy != nil {
		return t.SrtePolicy
	}
	return nil
}

// GetVprnTarget returns the value of the VprnTarget struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward. If the receiver or the field VprnTarget is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetVprnTarget() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget {
	if t != nil && t.VprnTarget != nil {
		return t.VprnTarget
	}
	return nil
}

// GetBondingConnection retrieves the value of the leaf BondingConnection from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BondingConnection is set, it can
// safely use t.GetBondingConnection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BondingConnection == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetBondingConnection() uint32 {
	if t == nil || t.BondingConnection == nil {
		return 0
	}
	return *t.BondingConnection
}

// GetGreTunnel retrieves the value of the leaf GreTunnel from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GreTunnel is set, it can
// safely use t.GetGreTunnel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GreTunnel == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetGreTunnel() string {
	if t == nil || t.GreTunnel == nil {
		return ""
	}
	return *t.GreTunnel
}

// GetLsp retrieves the value of the leaf Lsp from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lsp is set, it can
// safely use t.GetLsp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lsp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetLsp() string {
	if t == nil || t.Lsp == nil {
		return ""
	}
	return *t.Lsp
}

// GetRedirectPolicy retrieves the value of the leaf RedirectPolicy from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RedirectPolicy is set, it can
// safely use t.GetRedirectPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RedirectPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetRedirectPolicy() string {
	if t == nil || t.RedirectPolicy == nil {
		return ""
	}
	return *t.RedirectPolicy
}

// GetRouterInstance retrieves the value of the leaf RouterInstance from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterInstance is set, it can
// safely use t.GetRouterInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterInstance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) GetRouterInstance() string {
	if t == nil || t.RouterInstance == nil {
		return ""
	}
	return *t.RouterInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.EsiL2.PopulateDefaults()
	t.EsiL3.PopulateDefaults()
	t.MplsPolicy.PopulateDefaults()
	t.NextHop.PopulateDefaults()
	t.Sap.PopulateDefaults()
	t.Sdp.PopulateDefaults()
	t.SrtePolicy.PopulateDefaults()
	t.VprnTarget.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2 represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/forward/esi-l2 YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2 struct {
	EsiValue *string `path:"esi-value" module:"nokia-conf"`
	Vpls     *string `path:"vpls" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2) IsYANGGoStruct() {
}

// GetEsiValue retrieves the value of the leaf EsiValue from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EsiValue is set, it can
// safely use t.GetEsiValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EsiValue == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2) GetEsiValue() string {
	if t == nil || t.EsiValue == nil {
		return ""
	}
	return *t.EsiValue
}

// GetVpls retrieves the value of the leaf Vpls from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpls is set, it can
// safely use t.GetVpls() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpls == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2) GetVpls() string {
	if t == nil || t.Vpls == nil {
		return ""
	}
	return *t.Vpls
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL2) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3 represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/forward/esi-l3 YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3 struct {
	EsiValue     *string `path:"esi-value" module:"nokia-conf"`
	SfIp         *string `path:"sf-ip" module:"nokia-conf"`
	VasInterface *string `path:"vas-interface" module:"nokia-conf"`
	Vprn         *string `path:"vprn" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3) IsYANGGoStruct() {
}

// GetEsiValue retrieves the value of the leaf EsiValue from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EsiValue is set, it can
// safely use t.GetEsiValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EsiValue == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3) GetEsiValue() string {
	if t == nil || t.EsiValue == nil {
		return ""
	}
	return *t.EsiValue
}

// GetSfIp retrieves the value of the leaf SfIp from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SfIp is set, it can
// safely use t.GetSfIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SfIp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3) GetSfIp() string {
	if t == nil || t.SfIp == nil {
		return ""
	}
	return *t.SfIp
}

// GetVasInterface retrieves the value of the leaf VasInterface from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VasInterface is set, it can
// safely use t.GetVasInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VasInterface == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3) GetVasInterface() string {
	if t == nil || t.VasInterface == nil {
		return ""
	}
	return *t.VasInterface
}

// GetVprn retrieves the value of the leaf Vprn from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vprn is set, it can
// safely use t.GetVprn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vprn == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3) GetVprn() string {
	if t == nil || t.Vprn == nil {
		return ""
	}
	return *t.Vprn
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_EsiL3) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/forward/mpls-policy YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy struct {
	Endpoint *string `path:"endpoint" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy) IsYANGGoStruct() {
}

// GetEndpoint retrieves the value of the leaf Endpoint from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Endpoint is set, it can
// safely use t.GetEndpoint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Endpoint == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy) GetEndpoint() string {
	if t == nil || t.Endpoint == nil {
		return ""
	}
	return *t.Endpoint
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_MplsPolicy) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/forward/next-hop YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop struct {
	NhIp    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp    `path:"nh-ip" module:"nokia-conf" yangPresence:"true"`
	NhIpVrf *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf `path:"nh-ip-vrf" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop) IsYANGGoStruct() {
}

// GetOrCreateNhIp retrieves the value of the NhIp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop) GetOrCreateNhIp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp {
	if t.NhIp != nil {
		return t.NhIp
	}
	t.NhIp = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp{}
	return t.NhIp
}

// GetOrCreateNhIpVrf retrieves the value of the NhIpVrf field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop) GetOrCreateNhIpVrf() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf {
	if t.NhIpVrf != nil {
		return t.NhIpVrf
	}
	t.NhIpVrf = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf{}
	return t.NhIpVrf
}

// GetNhIp returns the value of the NhIp struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop. If the receiver or the field NhIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop) GetNhIp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp {
	if t != nil && t.NhIp != nil {
		return t.NhIp
	}
	return nil
}

// GetNhIpVrf returns the value of the NhIpVrf struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop. If the receiver or the field NhIpVrf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop) GetNhIpVrf() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf {
	if t != nil && t.NhIpVrf != nil {
		return t.NhIpVrf
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.NhIp.PopulateDefaults()
	t.NhIpVrf.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/forward/next-hop/nh-ip YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp struct {
	Address  *string `path:"address" module:"nokia-conf"`
	Indirect *bool   `path:"indirect" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetIndirect retrieves the value of the leaf Indirect from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Indirect is set, it can
// safely use t.GetIndirect() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Indirect == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp) GetIndirect() bool {
	if t == nil || t.Indirect == nil {
		return false
	}
	return *t.Indirect
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Indirect == nil {
		var v bool = false
		t.Indirect = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/forward/next-hop/nh-ip-vrf YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf struct {
	Address        *string `path:"address" module:"nokia-conf"`
	Indirect       *bool   `path:"indirect" module:"nokia-conf"`
	RouterInstance *string `path:"router-instance" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetIndirect retrieves the value of the leaf Indirect from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Indirect is set, it can
// safely use t.GetIndirect() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Indirect == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf) GetIndirect() bool {
	if t == nil || t.Indirect == nil {
		return false
	}
	return *t.Indirect
}

// GetRouterInstance retrieves the value of the leaf RouterInstance from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterInstance is set, it can
// safely use t.GetRouterInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterInstance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf) GetRouterInstance() string {
	if t == nil || t.RouterInstance == nil {
		return ""
	}
	return *t.RouterInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Indirect == nil {
		var v bool = false
		t.Indirect = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_NextHop_NhIpVrf) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/forward/sap YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap struct {
	SapId *string `path:"sap-id" module:"nokia-conf"`
	Vpls  *string `path:"vpls" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap) IsYANGGoStruct() {
}

// GetSapId retrieves the value of the leaf SapId from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SapId is set, it can
// safely use t.GetSapId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SapId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap) GetSapId() string {
	if t == nil || t.SapId == nil {
		return ""
	}
	return *t.SapId
}

// GetVpls retrieves the value of the leaf Vpls from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpls is set, it can
// safely use t.GetVpls() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpls == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap) GetVpls() string {
	if t == nil || t.Vpls == nil {
		return ""
	}
	return *t.Vpls
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sap) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/forward/sdp YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp struct {
	SdpBindId *string `path:"sdp-bind-id" module:"nokia-conf"`
	Vpls      *string `path:"vpls" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp) IsYANGGoStruct() {
}

// GetSdpBindId retrieves the value of the leaf SdpBindId from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SdpBindId is set, it can
// safely use t.GetSdpBindId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SdpBindId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp) GetSdpBindId() string {
	if t == nil || t.SdpBindId == nil {
		return ""
	}
	return *t.SdpBindId
}

// GetVpls retrieves the value of the leaf Vpls from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpls is set, it can
// safely use t.GetVpls() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpls == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp) GetVpls() string {
	if t == nil || t.Vpls == nil {
		return ""
	}
	return *t.Vpls
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_Sdp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/forward/srte-policy YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy struct {
	Color    *int64  `path:"color" module:"nokia-conf"`
	Endpoint *string `path:"endpoint" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy) IsYANGGoStruct() {
}

// GetColor retrieves the value of the leaf Color from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Color is set, it can
// safely use t.GetColor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Color == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy) GetColor() int64 {
	if t == nil || t.Color == nil {
		return 0
	}
	return *t.Color
}

// GetEndpoint retrieves the value of the leaf Endpoint from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Endpoint is set, it can
// safely use t.GetEndpoint() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Endpoint == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy) GetEndpoint() string {
	if t == nil || t.Endpoint == nil {
		return ""
	}
	return *t.Endpoint
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_SrtePolicy) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/forward/vprn-target YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget struct {
	AdvPrefix *string `path:"adv-prefix" module:"nokia-conf"`
	BgpNh     *string `path:"bgp-nh" module:"nokia-conf"`
	Lsp       *string `path:"lsp" module:"nokia-conf"`
	Vprn      *string `path:"vprn" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget) IsYANGGoStruct() {
}

// GetAdvPrefix retrieves the value of the leaf AdvPrefix from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvPrefix is set, it can
// safely use t.GetAdvPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvPrefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget) GetAdvPrefix() string {
	if t == nil || t.AdvPrefix == nil {
		return ""
	}
	return *t.AdvPrefix
}

// GetBgpNh retrieves the value of the leaf BgpNh from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BgpNh is set, it can
// safely use t.GetBgpNh() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BgpNh == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget) GetBgpNh() string {
	if t == nil || t.BgpNh == nil {
		return ""
	}
	return *t.BgpNh
}

// GetLsp retrieves the value of the leaf Lsp from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lsp is set, it can
// safely use t.GetLsp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lsp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget) GetLsp() string {
	if t == nil || t.Lsp == nil {
		return ""
	}
	return *t.Lsp
}

// GetVprn retrieves the value of the leaf Vprn from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vprn is set, it can
// safely use t.GetVprn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vprn == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget) GetVprn() string {
	if t == nil || t.Vprn == nil {
		return ""
	}
	return *t.Vprn
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Forward_VprnTarget) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/http-redirect YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect struct {
	AllowOverride *bool                                                                                  `path:"allow-override" module:"nokia-conf"`
	Url           NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect_Url_Union `path:"url" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect) IsYANGGoStruct() {
}

// GetAllowOverride retrieves the value of the leaf AllowOverride from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllowOverride is set, it can
// safely use t.GetAllowOverride() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllowOverride == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect) GetAllowOverride() bool {
	if t == nil || t.AllowOverride == nil {
		return false
	}
	return *t.AllowOverride
}

// GetUrl retrieves the value of the leaf Url from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Url is set, it can
// safely use t.GetUrl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Url == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect) GetUrl() NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect_Url_Union {
	if t == nil || t.Url == nil {
		return nil
	}
	return t.Url
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AllowOverride == nil {
		var v bool = false
		t.AllowOverride = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_HttpRedirect) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/nat YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat struct {
	NatPolicy *string                    `path:"nat-policy" module:"nokia-conf"`
	NatType   E_NokiaTypesFilter_NatType `path:"nat-type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat) IsYANGGoStruct() {}

// GetNatPolicy retrieves the value of the leaf NatPolicy from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NatPolicy is set, it can
// safely use t.GetNatPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NatPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat) GetNatPolicy() string {
	if t == nil || t.NatPolicy == nil {
		return ""
	}
	return *t.NatPolicy
}

// GetNatType retrieves the value of the leaf NatType from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NatType is set, it can
// safely use t.GetNatType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NatType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat) GetNatType() E_NokiaTypesFilter_NatType {
	if t == nil || t.NatType == 0 {
		return 0
	}
	return t.NatType
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Nat) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/rate-limit YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit struct {
	ExtractedTraffic YANGEmpty                                                                                `path:"extracted-traffic" module:"nokia-conf"`
	HopLimit         *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit      `path:"hop-limit" module:"nokia-conf" yangPresence:"true"`
	Pattern          *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern       `path:"pattern" module:"nokia-conf" yangPresence:"true"`
	PayloadLength    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength `path:"payload-length" module:"nokia-conf" yangPresence:"true"`
	Pir              NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pir_Union      `path:"pir" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) IsYANGGoStruct() {}

// GetOrCreateHopLimit retrieves the value of the HopLimit field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) GetOrCreateHopLimit() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit {
	if t.HopLimit != nil {
		return t.HopLimit
	}
	t.HopLimit = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit{}
	return t.HopLimit
}

// GetOrCreatePattern retrieves the value of the Pattern field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) GetOrCreatePattern() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern {
	if t.Pattern != nil {
		return t.Pattern
	}
	t.Pattern = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern{}
	return t.Pattern
}

// GetOrCreatePayloadLength retrieves the value of the PayloadLength field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) GetOrCreatePayloadLength() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength {
	if t.PayloadLength != nil {
		return t.PayloadLength
	}
	t.PayloadLength = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength{}
	return t.PayloadLength
}

// GetHopLimit returns the value of the HopLimit struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit. If the receiver or the field HopLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) GetHopLimit() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit {
	if t != nil && t.HopLimit != nil {
		return t.HopLimit
	}
	return nil
}

// GetPattern returns the value of the Pattern struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit. If the receiver or the field Pattern is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) GetPattern() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern {
	if t != nil && t.Pattern != nil {
		return t.Pattern
	}
	return nil
}

// GetPayloadLength returns the value of the PayloadLength struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit. If the receiver or the field PayloadLength is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) GetPayloadLength() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength {
	if t != nil && t.PayloadLength != nil {
		return t.PayloadLength
	}
	return nil
}

// GetExtractedTraffic retrieves the value of the leaf ExtractedTraffic from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExtractedTraffic is set, it can
// safely use t.GetExtractedTraffic() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExtractedTraffic == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) GetExtractedTraffic() YANGEmpty {
	if t == nil || t.ExtractedTraffic == false {
		return false
	}
	return t.ExtractedTraffic
}

// GetPir retrieves the value of the leaf Pir from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Pir is set, it can
// safely use t.GetPir() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Pir == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) GetPir() NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pir_Union {
	if t == nil || t.Pir == nil {
		return nil
	}
	return t.Pir
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.HopLimit.PopulateDefaults()
	t.Pattern.PopulateDefaults()
	t.PayloadLength.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/rate-limit/hop-limit YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit struct {
	Eq    *int32                                                                                    `path:"eq" module:"nokia-conf"`
	Gt    *int32                                                                                    `path:"gt" module:"nokia-conf"`
	Lt    *int32                                                                                    `path:"lt" module:"nokia-conf"`
	Range *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit) IsYANGGoStruct() {
}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetEq retrieves the value of the leaf Eq from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Eq is set, it can
// safely use t.GetEq() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Eq == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit) GetEq() int32 {
	if t == nil || t.Eq == nil {
		return 0
	}
	return *t.Eq
}

// GetGt retrieves the value of the leaf Gt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Gt is set, it can
// safely use t.GetGt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Gt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit) GetGt() int32 {
	if t == nil || t.Gt == nil {
		return 0
	}
	return *t.Gt
}

// GetLt retrieves the value of the leaf Lt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lt is set, it can
// safely use t.GetLt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit) GetLt() int32 {
	if t == nil || t.Lt == nil {
		return 0
	}
	return *t.Lt
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/rate-limit/hop-limit/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range struct {
	End   *int32 `path:"end" module:"nokia-conf"`
	Start *int32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range) GetEnd() int32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range) GetStart() int32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_HopLimit_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/rate-limit/pattern YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern struct {
	Expression  *string                                                                                        `path:"expression" module:"nokia-conf"`
	Mask        *string                                                                                        `path:"mask" module:"nokia-conf"`
	OffsetType  E_NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern_OffsetType `path:"offset-type" module:"nokia-conf"`
	OffsetValue *int32                                                                                         `path:"offset-value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern) IsYANGGoStruct() {
}

// GetExpression retrieves the value of the leaf Expression from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Expression is set, it can
// safely use t.GetExpression() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Expression == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern) GetExpression() string {
	if t == nil || t.Expression == nil {
		return ""
	}
	return *t.Expression
}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// GetOffsetType retrieves the value of the leaf OffsetType from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OffsetType is set, it can
// safely use t.GetOffsetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OffsetType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern) GetOffsetType() E_NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern_OffsetType {
	if t == nil || t.OffsetType == 0 {
		return 0
	}
	return t.OffsetType
}

// GetOffsetValue retrieves the value of the leaf OffsetValue from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OffsetValue is set, it can
// safely use t.GetOffsetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OffsetValue == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern) GetOffsetValue() int32 {
	if t == nil || t.OffsetValue == nil {
		return 0
	}
	return *t.OffsetValue
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_Pattern) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/rate-limit/payload-length YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength struct {
	Eq    *int32                                                                                         `path:"eq" module:"nokia-conf"`
	Gt    *int32                                                                                         `path:"gt" module:"nokia-conf"`
	Lt    *int32                                                                                         `path:"lt" module:"nokia-conf"`
	Range *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength) IsYANGGoStruct() {
}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetEq retrieves the value of the leaf Eq from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Eq is set, it can
// safely use t.GetEq() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Eq == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength) GetEq() int32 {
	if t == nil || t.Eq == nil {
		return 0
	}
	return *t.Eq
}

// GetGt retrieves the value of the leaf Gt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Gt is set, it can
// safely use t.GetGt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Gt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength) GetGt() int32 {
	if t == nil || t.Gt == nil {
		return 0
	}
	return *t.Gt
}

// GetLt retrieves the value of the leaf Lt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lt is set, it can
// safely use t.GetLt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength) GetLt() int32 {
	if t == nil || t.Lt == nil {
		return 0
	}
	return *t.Lt
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/rate-limit/payload-length/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range struct {
	End   *int32 `path:"end" module:"nokia-conf"`
	Start *int32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range) GetEnd() int32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range) GetStart() int32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_RateLimit_PayloadLength_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/remark YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark struct {
	Dscp E_NokiaTypesQos_DscpName `path:"dscp" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark) IsYANGGoStruct() {}

// GetDscp retrieves the value of the leaf Dscp from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark) GetDscp() E_NokiaTypesQos_DscpName {
	if t == nil || t.Dscp == 0 {
		return 0
	}
	return t.Dscp
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Remark) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/secondary YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary struct {
	Forward *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward `path:"forward" module:"nokia-conf"`
	Remark  *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark  `path:"remark" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary) IsYANGGoStruct() {}

// GetOrCreateForward retrieves the value of the Forward field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary) GetOrCreateForward() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward {
	if t.Forward != nil {
		return t.Forward
	}
	t.Forward = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward{}
	return t.Forward
}

// GetOrCreateRemark retrieves the value of the Remark field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary) GetOrCreateRemark() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark {
	if t.Remark != nil {
		return t.Remark
	}
	t.Remark = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark{}
	return t.Remark
}

// GetForward returns the value of the Forward struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary. If the receiver or the field Forward is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary) GetForward() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward {
	if t != nil && t.Forward != nil {
		return t.Forward
	}
	return nil
}

// GetRemark returns the value of the Remark struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary. If the receiver or the field Remark is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary) GetRemark() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark {
	if t != nil && t.Remark != nil {
		return t.Remark
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Forward.PopulateDefaults()
	t.Remark.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/secondary/forward YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward struct {
	NextHop    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop    `path:"next-hop" module:"nokia-conf" yangPresence:"true"`
	Sap        *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap        `path:"sap" module:"nokia-conf" yangPresence:"true"`
	Sdp        *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp        `path:"sdp" module:"nokia-conf" yangPresence:"true"`
	VprnTarget *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget `path:"vprn-target" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) IsYANGGoStruct() {
}

// GetOrCreateNextHop retrieves the value of the NextHop field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) GetOrCreateNextHop() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop {
	if t.NextHop != nil {
		return t.NextHop
	}
	t.NextHop = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop{}
	return t.NextHop
}

// GetOrCreateSap retrieves the value of the Sap field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) GetOrCreateSap() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap {
	if t.Sap != nil {
		return t.Sap
	}
	t.Sap = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap{}
	return t.Sap
}

// GetOrCreateSdp retrieves the value of the Sdp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) GetOrCreateSdp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp {
	if t.Sdp != nil {
		return t.Sdp
	}
	t.Sdp = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp{}
	return t.Sdp
}

// GetOrCreateVprnTarget retrieves the value of the VprnTarget field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) GetOrCreateVprnTarget() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget {
	if t.VprnTarget != nil {
		return t.VprnTarget
	}
	t.VprnTarget = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget{}
	return t.VprnTarget
}

// GetNextHop returns the value of the NextHop struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward. If the receiver or the field NextHop is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) GetNextHop() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop {
	if t != nil && t.NextHop != nil {
		return t.NextHop
	}
	return nil
}

// GetSap returns the value of the Sap struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward. If the receiver or the field Sap is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) GetSap() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap {
	if t != nil && t.Sap != nil {
		return t.Sap
	}
	return nil
}

// GetSdp returns the value of the Sdp struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward. If the receiver or the field Sdp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) GetSdp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp {
	if t != nil && t.Sdp != nil {
		return t.Sdp
	}
	return nil
}

// GetVprnTarget returns the value of the VprnTarget struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward. If the receiver or the field VprnTarget is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) GetVprnTarget() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget {
	if t != nil && t.VprnTarget != nil {
		return t.VprnTarget
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.NextHop.PopulateDefaults()
	t.Sap.PopulateDefaults()
	t.Sdp.PopulateDefaults()
	t.VprnTarget.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/secondary/forward/next-hop YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop struct {
	NhIpVrf *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf `path:"nh-ip-vrf" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop) IsYANGGoStruct() {
}

// GetOrCreateNhIpVrf retrieves the value of the NhIpVrf field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop) GetOrCreateNhIpVrf() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf {
	if t.NhIpVrf != nil {
		return t.NhIpVrf
	}
	t.NhIpVrf = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf{}
	return t.NhIpVrf
}

// GetNhIpVrf returns the value of the NhIpVrf struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop. If the receiver or the field NhIpVrf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop) GetNhIpVrf() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf {
	if t != nil && t.NhIpVrf != nil {
		return t.NhIpVrf
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.NhIpVrf.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/secondary/forward/next-hop/nh-ip-vrf YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf struct {
	Address        *string `path:"address" module:"nokia-conf"`
	Indirect       *bool   `path:"indirect" module:"nokia-conf"`
	RouterInstance *string `path:"router-instance" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf) IsYANGGoStruct() {
}

// GetAddress retrieves the value of the leaf Address from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetIndirect retrieves the value of the leaf Indirect from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Indirect is set, it can
// safely use t.GetIndirect() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Indirect == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf) GetIndirect() bool {
	if t == nil || t.Indirect == nil {
		return false
	}
	return *t.Indirect
}

// GetRouterInstance retrieves the value of the leaf RouterInstance from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterInstance is set, it can
// safely use t.GetRouterInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterInstance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf) GetRouterInstance() string {
	if t == nil || t.RouterInstance == nil {
		return ""
	}
	return *t.RouterInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Indirect == nil {
		var v bool = false
		t.Indirect = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_NextHop_NhIpVrf) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/secondary/forward/sap YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap struct {
	SapId *string `path:"sap-id" module:"nokia-conf"`
	Vpls  *string `path:"vpls" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap) IsYANGGoStruct() {
}

// GetSapId retrieves the value of the leaf SapId from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SapId is set, it can
// safely use t.GetSapId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SapId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap) GetSapId() string {
	if t == nil || t.SapId == nil {
		return ""
	}
	return *t.SapId
}

// GetVpls retrieves the value of the leaf Vpls from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpls is set, it can
// safely use t.GetVpls() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpls == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap) GetVpls() string {
	if t == nil || t.Vpls == nil {
		return ""
	}
	return *t.Vpls
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sap) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/secondary/forward/sdp YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp struct {
	SdpBindId *string `path:"sdp-bind-id" module:"nokia-conf"`
	Vpls      *string `path:"vpls" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp) IsYANGGoStruct() {
}

// GetSdpBindId retrieves the value of the leaf SdpBindId from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SdpBindId is set, it can
// safely use t.GetSdpBindId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SdpBindId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp) GetSdpBindId() string {
	if t == nil || t.SdpBindId == nil {
		return ""
	}
	return *t.SdpBindId
}

// GetVpls retrieves the value of the leaf Vpls from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpls is set, it can
// safely use t.GetVpls() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpls == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp) GetVpls() string {
	if t == nil || t.Vpls == nil {
		return ""
	}
	return *t.Vpls
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_Sdp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/secondary/forward/vprn-target YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget struct {
	AdvPrefix *string `path:"adv-prefix" module:"nokia-conf"`
	BgpNh     *string `path:"bgp-nh" module:"nokia-conf"`
	Lsp       *string `path:"lsp" module:"nokia-conf"`
	Vprn      *string `path:"vprn" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget) IsYANGGoStruct() {
}

// GetAdvPrefix retrieves the value of the leaf AdvPrefix from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdvPrefix is set, it can
// safely use t.GetAdvPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdvPrefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget) GetAdvPrefix() string {
	if t == nil || t.AdvPrefix == nil {
		return ""
	}
	return *t.AdvPrefix
}

// GetBgpNh retrieves the value of the leaf BgpNh from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BgpNh is set, it can
// safely use t.GetBgpNh() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BgpNh == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget) GetBgpNh() string {
	if t == nil || t.BgpNh == nil {
		return ""
	}
	return *t.BgpNh
}

// GetLsp retrieves the value of the leaf Lsp from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lsp is set, it can
// safely use t.GetLsp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lsp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget) GetLsp() string {
	if t == nil || t.Lsp == nil {
		return ""
	}
	return *t.Lsp
}

// GetVprn retrieves the value of the leaf Vprn from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vprn is set, it can
// safely use t.GetVprn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vprn == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget) GetVprn() string {
	if t == nil || t.Vprn == nil {
		return ""
	}
	return *t.Vprn
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Forward_VprnTarget) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/action/secondary/remark YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark struct {
	Dscp E_NokiaTypesQos_DscpName `path:"dscp" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark) IsYANGGoStruct() {
}

// GetDscp retrieves the value of the leaf Dscp from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark) GetDscp() E_NokiaTypesQos_DscpName {
	if t == nil || t.Dscp == 0 {
		return 0
	}
	return t.Dscp
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Action_Secondary_Remark) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match struct {
	DestinationClass *uint32                                                                         `path:"destination-class" module:"nokia-conf"`
	Dscp             E_NokiaTypesQos_DscpName                                                        `path:"dscp" module:"nokia-conf"`
	DstIp            *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp           `path:"dst-ip" module:"nokia-conf"`
	DstPort          *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort         `path:"dst-port" module:"nokia-conf"`
	ExtensionHeader  *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader `path:"extension-header" module:"nokia-conf"`
	FlowLabel        *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel       `path:"flow-label" module:"nokia-conf" yangPresence:"true"`
	Fragment         E_NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Fragment       `path:"fragment" module:"nokia-conf"`
	HopLimit         *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit        `path:"hop-limit" module:"nokia-conf" yangPresence:"true"`
	Icmp             *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp            `path:"icmp" module:"nokia-conf"`
	Ip               *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip              `path:"ip" module:"nokia-conf"`
	NextHeader       NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_NextHeader_Union `path:"next-header" module:"nokia-conf"`
	NextHeaderList   *string                                                                         `path:"next-header-list" module:"nokia-conf"`
	PacketLength     *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength    `path:"packet-length" module:"nokia-conf" yangPresence:"true"`
	Port             *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port            `path:"port" module:"nokia-conf"`
	SrcIp            *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp           `path:"src-ip" module:"nokia-conf"`
	SrcMac           *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac          `path:"src-mac" module:"nokia-conf" yangPresence:"true"`
	SrcPort          *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort         `path:"src-port" module:"nokia-conf"`
	TcpFlags         *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags        `path:"tcp-flags" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDstIp retrieves the value of the DstIp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreateDstIp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp {
	if t.DstIp != nil {
		return t.DstIp
	}
	t.DstIp = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp{}
	return t.DstIp
}

// GetOrCreateDstPort retrieves the value of the DstPort field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreateDstPort() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort {
	if t.DstPort != nil {
		return t.DstPort
	}
	t.DstPort = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort{}
	return t.DstPort
}

// GetOrCreateExtensionHeader retrieves the value of the ExtensionHeader field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreateExtensionHeader() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader {
	if t.ExtensionHeader != nil {
		return t.ExtensionHeader
	}
	t.ExtensionHeader = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader{}
	return t.ExtensionHeader
}

// GetOrCreateFlowLabel retrieves the value of the FlowLabel field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreateFlowLabel() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel {
	if t.FlowLabel != nil {
		return t.FlowLabel
	}
	t.FlowLabel = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel{}
	return t.FlowLabel
}

// GetOrCreateHopLimit retrieves the value of the HopLimit field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreateHopLimit() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit {
	if t.HopLimit != nil {
		return t.HopLimit
	}
	t.HopLimit = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit{}
	return t.HopLimit
}

// GetOrCreateIcmp retrieves the value of the Icmp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreateIcmp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp {
	if t.Icmp != nil {
		return t.Icmp
	}
	t.Icmp = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp{}
	return t.Icmp
}

// GetOrCreateIp retrieves the value of the Ip field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreateIp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip {
	if t.Ip != nil {
		return t.Ip
	}
	t.Ip = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip{}
	return t.Ip
}

// GetOrCreatePacketLength retrieves the value of the PacketLength field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreatePacketLength() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength {
	if t.PacketLength != nil {
		return t.PacketLength
	}
	t.PacketLength = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength{}
	return t.PacketLength
}

// GetOrCreatePort retrieves the value of the Port field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreatePort() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port {
	if t.Port != nil {
		return t.Port
	}
	t.Port = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port{}
	return t.Port
}

// GetOrCreateSrcIp retrieves the value of the SrcIp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreateSrcIp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp {
	if t.SrcIp != nil {
		return t.SrcIp
	}
	t.SrcIp = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp{}
	return t.SrcIp
}

// GetOrCreateSrcMac retrieves the value of the SrcMac field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreateSrcMac() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac {
	if t.SrcMac != nil {
		return t.SrcMac
	}
	t.SrcMac = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac{}
	return t.SrcMac
}

// GetOrCreateSrcPort retrieves the value of the SrcPort field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreateSrcPort() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort {
	if t.SrcPort != nil {
		return t.SrcPort
	}
	t.SrcPort = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort{}
	return t.SrcPort
}

// GetOrCreateTcpFlags retrieves the value of the TcpFlags field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetOrCreateTcpFlags() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags {
	if t.TcpFlags != nil {
		return t.TcpFlags
	}
	t.TcpFlags = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags{}
	return t.TcpFlags
}

// GetDstIp returns the value of the DstIp struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field DstIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetDstIp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp {
	if t != nil && t.DstIp != nil {
		return t.DstIp
	}
	return nil
}

// GetDstPort returns the value of the DstPort struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field DstPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetDstPort() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort {
	if t != nil && t.DstPort != nil {
		return t.DstPort
	}
	return nil
}

// GetExtensionHeader returns the value of the ExtensionHeader struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field ExtensionHeader is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetExtensionHeader() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader {
	if t != nil && t.ExtensionHeader != nil {
		return t.ExtensionHeader
	}
	return nil
}

// GetFlowLabel returns the value of the FlowLabel struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field FlowLabel is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetFlowLabel() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel {
	if t != nil && t.FlowLabel != nil {
		return t.FlowLabel
	}
	return nil
}

// GetHopLimit returns the value of the HopLimit struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field HopLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetHopLimit() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit {
	if t != nil && t.HopLimit != nil {
		return t.HopLimit
	}
	return nil
}

// GetIcmp returns the value of the Icmp struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field Icmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetIcmp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp {
	if t != nil && t.Icmp != nil {
		return t.Icmp
	}
	return nil
}

// GetIp returns the value of the Ip struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field Ip is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetIp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip {
	if t != nil && t.Ip != nil {
		return t.Ip
	}
	return nil
}

// GetPacketLength returns the value of the PacketLength struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field PacketLength is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetPacketLength() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength {
	if t != nil && t.PacketLength != nil {
		return t.PacketLength
	}
	return nil
}

// GetPort returns the value of the Port struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field Port is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetPort() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port {
	if t != nil && t.Port != nil {
		return t.Port
	}
	return nil
}

// GetSrcIp returns the value of the SrcIp struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field SrcIp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetSrcIp() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp {
	if t != nil && t.SrcIp != nil {
		return t.SrcIp
	}
	return nil
}

// GetSrcMac returns the value of the SrcMac struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field SrcMac is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetSrcMac() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac {
	if t != nil && t.SrcMac != nil {
		return t.SrcMac
	}
	return nil
}

// GetSrcPort returns the value of the SrcPort struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field SrcPort is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetSrcPort() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort {
	if t != nil && t.SrcPort != nil {
		return t.SrcPort
	}
	return nil
}

// GetTcpFlags returns the value of the TcpFlags struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match. If the receiver or the field TcpFlags is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetTcpFlags() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags {
	if t != nil && t.TcpFlags != nil {
		return t.TcpFlags
	}
	return nil
}

// GetDestinationClass retrieves the value of the leaf DestinationClass from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationClass is set, it can
// safely use t.GetDestinationClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationClass == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetDestinationClass() uint32 {
	if t == nil || t.DestinationClass == nil {
		return 0
	}
	return *t.DestinationClass
}

// GetDscp retrieves the value of the leaf Dscp from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dscp is set, it can
// safely use t.GetDscp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dscp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetDscp() E_NokiaTypesQos_DscpName {
	if t == nil || t.Dscp == 0 {
		return 0
	}
	return t.Dscp
}

// GetFragment retrieves the value of the leaf Fragment from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fragment is set, it can
// safely use t.GetFragment() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fragment == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetFragment() E_NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Fragment {
	if t == nil || t.Fragment == 0 {
		return 0
	}
	return t.Fragment
}

// GetNextHeader retrieves the value of the leaf NextHeader from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHeader is set, it can
// safely use t.GetNextHeader() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHeader == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetNextHeader() NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_NextHeader_Union {
	if t == nil || t.NextHeader == nil {
		return nil
	}
	return t.NextHeader
}

// GetNextHeaderList retrieves the value of the leaf NextHeaderList from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NextHeaderList is set, it can
// safely use t.GetNextHeaderList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NextHeaderList == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) GetNextHeaderList() string {
	if t == nil || t.NextHeaderList == nil {
		return ""
	}
	return *t.NextHeaderList
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.DstIp.PopulateDefaults()
	t.DstPort.PopulateDefaults()
	t.ExtensionHeader.PopulateDefaults()
	t.FlowLabel.PopulateDefaults()
	t.HopLimit.PopulateDefaults()
	t.Icmp.PopulateDefaults()
	t.Ip.PopulateDefaults()
	t.PacketLength.PopulateDefaults()
	t.Port.PopulateDefaults()
	t.SrcIp.PopulateDefaults()
	t.SrcMac.PopulateDefaults()
	t.SrcPort.PopulateDefaults()
	t.TcpFlags.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/dst-ip YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp struct {
	Address        *string `path:"address" module:"nokia-conf"`
	Ipv6PrefixList *string `path:"ipv6-prefix-list" module:"nokia-conf"`
	Mask           *string `path:"mask" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetIpv6PrefixList retrieves the value of the leaf Ipv6PrefixList from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6PrefixList is set, it can
// safely use t.GetIpv6PrefixList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6PrefixList == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp) GetIpv6PrefixList() string {
	if t == nil || t.Ipv6PrefixList == nil {
		return ""
	}
	return *t.Ipv6PrefixList
}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstIp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/dst-port YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort struct {
	Eq       *uint16                                                                       `path:"eq" module:"nokia-conf"`
	Gt       *uint16                                                                       `path:"gt" module:"nokia-conf"`
	Lt       *uint16                                                                       `path:"lt" module:"nokia-conf"`
	PortList *string                                                                       `path:"port-list" module:"nokia-conf"`
	Range    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetEq retrieves the value of the leaf Eq from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Eq is set, it can
// safely use t.GetEq() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Eq == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort) GetEq() uint16 {
	if t == nil || t.Eq == nil {
		return 0
	}
	return *t.Eq
}

// GetGt retrieves the value of the leaf Gt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Gt is set, it can
// safely use t.GetGt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Gt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort) GetGt() uint16 {
	if t == nil || t.Gt == nil {
		return 0
	}
	return *t.Gt
}

// GetLt retrieves the value of the leaf Lt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lt is set, it can
// safely use t.GetLt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort) GetLt() uint16 {
	if t == nil || t.Lt == nil {
		return 0
	}
	return *t.Lt
}

// GetPortList retrieves the value of the leaf PortList from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortList is set, it can
// safely use t.GetPortList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortList == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort) GetPortList() string {
	if t == nil || t.PortList == nil {
		return ""
	}
	return *t.PortList
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/dst-port/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range struct {
	End   *uint16 `path:"end" module:"nokia-conf"`
	Start *uint16 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range) GetEnd() uint16 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range) GetStart() uint16 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_DstPort_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/extension-header YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader struct {
	Ah           *bool `path:"ah" module:"nokia-conf"`
	Esp          *bool `path:"esp" module:"nokia-conf"`
	HopByHop     *bool `path:"hop-by-hop" module:"nokia-conf"`
	RoutingType0 *bool `path:"routing-type0" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader) IsYANGGoStruct() {
}

// GetAh retrieves the value of the leaf Ah from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ah is set, it can
// safely use t.GetAh() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ah == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader) GetAh() bool {
	if t == nil || t.Ah == nil {
		return false
	}
	return *t.Ah
}

// GetEsp retrieves the value of the leaf Esp from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esp is set, it can
// safely use t.GetEsp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader) GetEsp() bool {
	if t == nil || t.Esp == nil {
		return false
	}
	return *t.Esp
}

// GetHopByHop retrieves the value of the leaf HopByHop from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HopByHop is set, it can
// safely use t.GetHopByHop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HopByHop == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader) GetHopByHop() bool {
	if t == nil || t.HopByHop == nil {
		return false
	}
	return *t.HopByHop
}

// GetRoutingType0 retrieves the value of the leaf RoutingType0 from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RoutingType0 is set, it can
// safely use t.GetRoutingType0() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RoutingType0 == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader) GetRoutingType0() bool {
	if t == nil || t.RoutingType0 == nil {
		return false
	}
	return *t.RoutingType0
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_ExtensionHeader) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/flow-label YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel struct {
	Mask  *int32 `path:"mask" module:"nokia-conf"`
	Value *int32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel) IsYANGGoStruct() {}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel) GetMask() int32 {
	if t == nil || t.Mask == nil {
		return 1048575
	}
	return *t.Mask
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel) GetValue() int32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mask == nil {
		var v int32 = 1048575
		t.Mask = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_FlowLabel) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/hop-limit YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit struct {
	Eq    *int32                                                                         `path:"eq" module:"nokia-conf"`
	Gt    *int32                                                                         `path:"gt" module:"nokia-conf"`
	Lt    *int32                                                                         `path:"lt" module:"nokia-conf"`
	Range *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetEq retrieves the value of the leaf Eq from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Eq is set, it can
// safely use t.GetEq() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Eq == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit) GetEq() int32 {
	if t == nil || t.Eq == nil {
		return 0
	}
	return *t.Eq
}

// GetGt retrieves the value of the leaf Gt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Gt is set, it can
// safely use t.GetGt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Gt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit) GetGt() int32 {
	if t == nil || t.Gt == nil {
		return 0
	}
	return *t.Gt
}

// GetLt retrieves the value of the leaf Lt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lt is set, it can
// safely use t.GetLt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit) GetLt() int32 {
	if t == nil || t.Lt == nil {
		return 0
	}
	return *t.Lt
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/hop-limit/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range struct {
	End   *int32 `path:"end" module:"nokia-conf"`
	Start *int32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range) GetEnd() int32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range) GetStart() int32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_HopLimit_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/icmp YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp struct {
	Code *int32 `path:"code" module:"nokia-conf"`
	Type *int32 `path:"type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp) IsYANGGoStruct() {}

// GetCode retrieves the value of the leaf Code from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Code is set, it can
// safely use t.GetCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Code == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp) GetCode() int32 {
	if t == nil || t.Code == nil {
		return 0
	}
	return *t.Code
}

// GetType retrieves the value of the leaf Type from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp) GetType() int32 {
	if t == nil || t.Type == nil {
		return 0
	}
	return *t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Icmp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/ip YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip struct {
	Address        *string `path:"address" module:"nokia-conf"`
	Ipv6PrefixList *string `path:"ipv6-prefix-list" module:"nokia-conf"`
	Mask           *string `path:"mask" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetIpv6PrefixList retrieves the value of the leaf Ipv6PrefixList from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6PrefixList is set, it can
// safely use t.GetIpv6PrefixList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6PrefixList == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip) GetIpv6PrefixList() string {
	if t == nil || t.Ipv6PrefixList == nil {
		return ""
	}
	return *t.Ipv6PrefixList
}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Ip) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/packet-length YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength struct {
	Eq    *int32                                                                             `path:"eq" module:"nokia-conf"`
	Gt    *int32                                                                             `path:"gt" module:"nokia-conf"`
	Lt    *int32                                                                             `path:"lt" module:"nokia-conf"`
	Range *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength) IsYANGGoStruct() {
}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetEq retrieves the value of the leaf Eq from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Eq is set, it can
// safely use t.GetEq() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Eq == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength) GetEq() int32 {
	if t == nil || t.Eq == nil {
		return 0
	}
	return *t.Eq
}

// GetGt retrieves the value of the leaf Gt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Gt is set, it can
// safely use t.GetGt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Gt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength) GetGt() int32 {
	if t == nil || t.Gt == nil {
		return 0
	}
	return *t.Gt
}

// GetLt retrieves the value of the leaf Lt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lt is set, it can
// safely use t.GetLt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength) GetLt() int32 {
	if t == nil || t.Lt == nil {
		return 0
	}
	return *t.Lt
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/packet-length/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range struct {
	End   *int32 `path:"end" module:"nokia-conf"`
	Start *int32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range) GetEnd() int32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range) GetStart() int32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_PacketLength_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/port YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port struct {
	Eq       *uint16                                                                    `path:"eq" module:"nokia-conf"`
	Gt       *uint16                                                                    `path:"gt" module:"nokia-conf"`
	Lt       *uint16                                                                    `path:"lt" module:"nokia-conf"`
	PortList *string                                                                    `path:"port-list" module:"nokia-conf"`
	Range    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetEq retrieves the value of the leaf Eq from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Eq is set, it can
// safely use t.GetEq() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Eq == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port) GetEq() uint16 {
	if t == nil || t.Eq == nil {
		return 0
	}
	return *t.Eq
}

// GetGt retrieves the value of the leaf Gt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Gt is set, it can
// safely use t.GetGt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Gt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port) GetGt() uint16 {
	if t == nil || t.Gt == nil {
		return 0
	}
	return *t.Gt
}

// GetLt retrieves the value of the leaf Lt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lt is set, it can
// safely use t.GetLt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port) GetLt() uint16 {
	if t == nil || t.Lt == nil {
		return 0
	}
	return *t.Lt
}

// GetPortList retrieves the value of the leaf PortList from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortList is set, it can
// safely use t.GetPortList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortList == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port) GetPortList() string {
	if t == nil || t.PortList == nil {
		return ""
	}
	return *t.PortList
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/port/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range struct {
	End   *uint16 `path:"end" module:"nokia-conf"`
	Start *uint16 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range) GetEnd() uint16 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range) GetStart() uint16 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_Port_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/src-ip YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp struct {
	Address        *string `path:"address" module:"nokia-conf"`
	Ipv6PrefixList *string `path:"ipv6-prefix-list" module:"nokia-conf"`
	Mask           *string `path:"mask" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetIpv6PrefixList retrieves the value of the leaf Ipv6PrefixList from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6PrefixList is set, it can
// safely use t.GetIpv6PrefixList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6PrefixList == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp) GetIpv6PrefixList() string {
	if t == nil || t.Ipv6PrefixList == nil {
		return ""
	}
	return *t.Ipv6PrefixList
}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp) GetMask() string {
	if t == nil || t.Mask == nil {
		return ""
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcIp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/src-mac YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac struct {
	Address *string `path:"address" module:"nokia-conf"`
	Mask    *string `path:"mask" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac) GetMask() string {
	if t == nil || t.Mask == nil {
		return "ff:ff:ff:ff:ff:ff"
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mask == nil {
		var v string = "ff:ff:ff:ff:ff:ff"
		t.Mask = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcMac) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/src-port YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort struct {
	Eq       *uint16                                                                       `path:"eq" module:"nokia-conf"`
	Gt       *uint16                                                                       `path:"gt" module:"nokia-conf"`
	Lt       *uint16                                                                       `path:"lt" module:"nokia-conf"`
	PortList *string                                                                       `path:"port-list" module:"nokia-conf"`
	Range    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetEq retrieves the value of the leaf Eq from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Eq is set, it can
// safely use t.GetEq() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Eq == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort) GetEq() uint16 {
	if t == nil || t.Eq == nil {
		return 0
	}
	return *t.Eq
}

// GetGt retrieves the value of the leaf Gt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Gt is set, it can
// safely use t.GetGt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Gt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort) GetGt() uint16 {
	if t == nil || t.Gt == nil {
		return 0
	}
	return *t.Gt
}

// GetLt retrieves the value of the leaf Lt from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lt is set, it can
// safely use t.GetLt() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lt == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort) GetLt() uint16 {
	if t == nil || t.Lt == nil {
		return 0
	}
	return *t.Lt
}

// GetPortList retrieves the value of the leaf PortList from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortList is set, it can
// safely use t.GetPortList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortList == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort) GetPortList() string {
	if t == nil || t.PortList == nil {
		return ""
	}
	return *t.PortList
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/src-port/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range struct {
	End   *uint16 `path:"end" module:"nokia-conf"`
	Start *uint16 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range) GetEnd() uint16 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range) GetStart() uint16 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_SrcPort_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/entry/match/tcp-flags YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags struct {
	Ack *bool `path:"ack" module:"nokia-conf"`
	Cwr *bool `path:"cwr" module:"nokia-conf"`
	Ece *bool `path:"ece" module:"nokia-conf"`
	Fin *bool `path:"fin" module:"nokia-conf"`
	Ns  *bool `path:"ns" module:"nokia-conf"`
	Psh *bool `path:"psh" module:"nokia-conf"`
	Rst *bool `path:"rst" module:"nokia-conf"`
	Syn *bool `path:"syn" module:"nokia-conf"`
	Urg *bool `path:"urg" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) IsYANGGoStruct() {}

// GetAck retrieves the value of the leaf Ack from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ack is set, it can
// safely use t.GetAck() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ack == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) GetAck() bool {
	if t == nil || t.Ack == nil {
		return false
	}
	return *t.Ack
}

// GetCwr retrieves the value of the leaf Cwr from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cwr is set, it can
// safely use t.GetCwr() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cwr == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) GetCwr() bool {
	if t == nil || t.Cwr == nil {
		return false
	}
	return *t.Cwr
}

// GetEce retrieves the value of the leaf Ece from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ece is set, it can
// safely use t.GetEce() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ece == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) GetEce() bool {
	if t == nil || t.Ece == nil {
		return false
	}
	return *t.Ece
}

// GetFin retrieves the value of the leaf Fin from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fin is set, it can
// safely use t.GetFin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fin == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) GetFin() bool {
	if t == nil || t.Fin == nil {
		return false
	}
	return *t.Fin
}

// GetNs retrieves the value of the leaf Ns from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ns is set, it can
// safely use t.GetNs() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ns == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) GetNs() bool {
	if t == nil || t.Ns == nil {
		return false
	}
	return *t.Ns
}

// GetPsh retrieves the value of the leaf Psh from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Psh is set, it can
// safely use t.GetPsh() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Psh == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) GetPsh() bool {
	if t == nil || t.Psh == nil {
		return false
	}
	return *t.Psh
}

// GetRst retrieves the value of the leaf Rst from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Rst is set, it can
// safely use t.GetRst() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Rst == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) GetRst() bool {
	if t == nil || t.Rst == nil {
		return false
	}
	return *t.Rst
}

// GetSyn retrieves the value of the leaf Syn from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Syn is set, it can
// safely use t.GetSyn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Syn == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) GetSyn() bool {
	if t == nil || t.Syn == nil {
		return false
	}
	return *t.Syn
}

// GetUrg retrieves the value of the leaf Urg from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Urg is set, it can
// safely use t.GetUrg() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Urg == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) GetUrg() bool {
	if t == nil || t.Urg == nil {
		return false
	}
	return *t.Urg
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_Entry_Match_TcpFlags) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt struct {
	HostSpecificEntry *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry `path:"host-specific-entry" module:"nokia-conf"`
	SharedEntry       *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry       `path:"shared-entry" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt) IsYANGGoStruct() {}

// GetOrCreateHostSpecificEntry retrieves the value of the HostSpecificEntry field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt) GetOrCreateHostSpecificEntry() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry {
	if t.HostSpecificEntry != nil {
		return t.HostSpecificEntry
	}
	t.HostSpecificEntry = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry{}
	return t.HostSpecificEntry
}

// GetOrCreateSharedEntry retrieves the value of the SharedEntry field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt) GetOrCreateSharedEntry() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry {
	if t.SharedEntry != nil {
		return t.SharedEntry
	}
	t.SharedEntry = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry{}
	return t.SharedEntry
}

// GetHostSpecificEntry returns the value of the HostSpecificEntry struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt. If the receiver or the field HostSpecificEntry is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt) GetHostSpecificEntry() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry {
	if t != nil && t.HostSpecificEntry != nil {
		return t.HostSpecificEntry
	}
	return nil
}

// GetSharedEntry returns the value of the SharedEntry struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt. If the receiver or the field SharedEntry is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt) GetSharedEntry() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry {
	if t != nil && t.SharedEntry != nil {
		return t.SharedEntry
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.HostSpecificEntry.PopulateDefaults()
	t.SharedEntry.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt/host-specific-entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry struct {
	CreditControl *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl `path:"credit-control" module:"nokia-conf"`
	FilterRule    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule    `path:"filter-rule" module:"nokia-conf"`
	Watermark     *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark     `path:"watermark" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry) IsYANGGoStruct() {
}

// GetOrCreateCreditControl retrieves the value of the CreditControl field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry) GetOrCreateCreditControl() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl {
	if t.CreditControl != nil {
		return t.CreditControl
	}
	t.CreditControl = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl{}
	return t.CreditControl
}

// GetOrCreateFilterRule retrieves the value of the FilterRule field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry) GetOrCreateFilterRule() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule {
	if t.FilterRule != nil {
		return t.FilterRule
	}
	t.FilterRule = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule{}
	return t.FilterRule
}

// GetOrCreateWatermark retrieves the value of the Watermark field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry) GetOrCreateWatermark() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark {
	if t.Watermark != nil {
		return t.Watermark
	}
	t.Watermark = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark{}
	return t.Watermark
}

// GetCreditControl returns the value of the CreditControl struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry. If the receiver or the field CreditControl is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry) GetCreditControl() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl {
	if t != nil && t.CreditControl != nil {
		return t.CreditControl
	}
	return nil
}

// GetFilterRule returns the value of the FilterRule struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry. If the receiver or the field FilterRule is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry) GetFilterRule() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule {
	if t != nil && t.FilterRule != nil {
		return t.FilterRule
	}
	return nil
}

// GetWatermark returns the value of the Watermark struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry. If the receiver or the field Watermark is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry) GetWatermark() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark {
	if t != nil && t.Watermark != nil {
		return t.Watermark
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.CreditControl.PopulateDefaults()
	t.FilterRule.PopulateDefaults()
	t.Watermark.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt/host-specific-entry/credit-control YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl struct {
	Range *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl) IsYANGGoStruct() {
}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt/host-specific-entry/credit-control/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range struct {
	End   *uint32 `path:"end" module:"nokia-conf"`
	Start *uint32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range) GetEnd() uint32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range) GetStart() uint32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_CreditControl_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt/host-specific-entry/filter-rule YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule struct {
	Range *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule) IsYANGGoStruct() {
}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt/host-specific-entry/filter-rule/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range struct {
	End   *uint32 `path:"end" module:"nokia-conf"`
	Start *uint32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range) GetEnd() uint32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range) GetStart() uint32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_FilterRule_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt/host-specific-entry/watermark YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark struct {
	High *int32 `path:"high" module:"nokia-conf"`
	Low  *int32 `path:"low" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark) IsYANGGoStruct() {
}

// GetHigh retrieves the value of the leaf High from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if High is set, it can
// safely use t.GetHigh() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.High == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark) GetHigh() int32 {
	if t == nil || t.High == nil {
		return 95
	}
	return *t.High
}

// GetLow retrieves the value of the leaf Low from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Low is set, it can
// safely use t.GetLow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Low == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark) GetLow() int32 {
	if t == nil || t.Low == nil {
		return 90
	}
	return *t.Low
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.High == nil {
		var v int32 = 95
		t.High = &v
	}
	if t.Low == nil {
		var v int32 = 90
		t.Low = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_HostSpecificEntry_Watermark) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt/shared-entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry struct {
	FilterRule *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule `path:"filter-rule" module:"nokia-conf"`
	PccRule    *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule    `path:"pcc-rule" module:"nokia-conf"`
	Watermark  *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark  `path:"watermark" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry) IsYANGGoStruct() {
}

// GetOrCreateFilterRule retrieves the value of the FilterRule field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry) GetOrCreateFilterRule() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule {
	if t.FilterRule != nil {
		return t.FilterRule
	}
	t.FilterRule = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule{}
	return t.FilterRule
}

// GetOrCreatePccRule retrieves the value of the PccRule field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry) GetOrCreatePccRule() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule {
	if t.PccRule != nil {
		return t.PccRule
	}
	t.PccRule = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule{}
	return t.PccRule
}

// GetOrCreateWatermark retrieves the value of the Watermark field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry) GetOrCreateWatermark() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark {
	if t.Watermark != nil {
		return t.Watermark
	}
	t.Watermark = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark{}
	return t.Watermark
}

// GetFilterRule returns the value of the FilterRule struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry. If the receiver or the field FilterRule is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry) GetFilterRule() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule {
	if t != nil && t.FilterRule != nil {
		return t.FilterRule
	}
	return nil
}

// GetPccRule returns the value of the PccRule struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry. If the receiver or the field PccRule is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry) GetPccRule() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule {
	if t != nil && t.PccRule != nil {
		return t.PccRule
	}
	return nil
}

// GetWatermark returns the value of the Watermark struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry. If the receiver or the field Watermark is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry) GetWatermark() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark {
	if t != nil && t.Watermark != nil {
		return t.Watermark
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.FilterRule.PopulateDefaults()
	t.PccRule.PopulateDefaults()
	t.Watermark.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt/shared-entry/filter-rule YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule struct {
	Range *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule) IsYANGGoStruct() {
}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt/shared-entry/filter-rule/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range struct {
	End   *uint32 `path:"end" module:"nokia-conf"`
	Start *uint32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range) GetEnd() uint32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range) GetStart() uint32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_FilterRule_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt/shared-entry/pcc-rule YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule struct {
	Range *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule) IsYANGGoStruct() {
}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule) GetRange() *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt/shared-entry/pcc-rule/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range struct {
	End   *uint32 `path:"end" module:"nokia-conf"`
	Start *uint32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range) IsYANGGoStruct() {
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range) GetEnd() uint32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range) GetStart() uint32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_PccRule_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark represents the /nokia-conf/configure/groups/group/filter/ipv6-filter/subscriber-mgmt/shared-entry/watermark YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark struct {
	High *int32 `path:"high" module:"nokia-conf"`
	Low  *int32 `path:"low" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark) IsYANGGoStruct() {
}

// GetHigh retrieves the value of the leaf High from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if High is set, it can
// safely use t.GetHigh() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.High == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark) GetHigh() int32 {
	if t == nil || t.High == nil {
		return 0
	}
	return *t.High
}

// GetLow retrieves the value of the leaf Low from the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Low is set, it can
// safely use t.GetLow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Low == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark) GetLow() int32 {
	if t == nil || t.Low == nil {
		return 0
	}
	return *t.Low
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark.
func (*NokiaConf_Configure_Groups_Group_Filter_Ipv6Filter_SubscriberMgmt_SharedEntry_Watermark) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Log represents the /nokia-conf/configure/groups/group/filter/log YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Log struct {
	AdminState  E_NokiaTypesSros_AdminState                              `path:"admin-state" module:"nokia-conf"`
	Description *string                                                  `path:"description" module:"nokia-conf"`
	Destination *NokiaConf_Configure_Groups_Group_Filter_Log_Destination `path:"destination" module:"nokia-conf"`
	LogId       NokiaConf_Configure_Groups_Group_Filter_Log_LogId_Union  `path:"log-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Log implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Log) IsYANGGoStruct() {}

// GetOrCreateDestination retrieves the value of the Destination field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log) GetOrCreateDestination() *NokiaConf_Configure_Groups_Group_Filter_Log_Destination {
	if t.Destination != nil {
		return t.Destination
	}
	t.Destination = &NokiaConf_Configure_Groups_Group_Filter_Log_Destination{}
	return t.Destination
}

// GetDestination returns the value of the Destination struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Log. If the receiver or the field Destination is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log) GetDestination() *NokiaConf_Configure_Groups_Group_Filter_Log_Destination {
	if t != nil && t.Destination != nil {
		return t.Destination
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Filter_Log
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Filter_Log
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetLogId retrieves the value of the leaf LogId from the NokiaConf_Configure_Groups_Group_Filter_Log
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LogId is set, it can
// safely use t.GetLogId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LogId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log) GetLogId() NokiaConf_Configure_Groups_Group_Filter_Log_LogId_Union {
	if t == nil || t.LogId == nil {
		return nil
	}
	return t.LogId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Log
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Destination.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_Log struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"log-id": t.LogId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Log"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Log.
func (*NokiaConf_Configure_Groups_Group_Filter_Log) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Log_Destination represents the /nokia-conf/configure/groups/group/filter/log/destination YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Log_Destination struct {
	Memory *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory `path:"memory" module:"nokia-conf"`
	Syslog *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog `path:"syslog" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Log_Destination implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Log_Destination) IsYANGGoStruct() {}

// GetOrCreateMemory retrieves the value of the Memory field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination) GetOrCreateMemory() *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory {
	if t.Memory != nil {
		return t.Memory
	}
	t.Memory = &NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory{}
	return t.Memory
}

// GetOrCreateSyslog retrieves the value of the Syslog field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination) GetOrCreateSyslog() *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog {
	if t.Syslog != nil {
		return t.Syslog
	}
	t.Syslog = &NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog{}
	return t.Syslog
}

// GetMemory returns the value of the Memory struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Log_Destination. If the receiver or the field Memory is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination) GetMemory() *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory {
	if t != nil && t.Memory != nil {
		return t.Memory
	}
	return nil
}

// GetSyslog returns the value of the Syslog struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Log_Destination. If the receiver or the field Syslog is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination) GetSyslog() *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog {
	if t != nil && t.Syslog != nil {
		return t.Syslog
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Log_Destination
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Memory.PopulateDefaults()
	t.Syslog.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Log_Destination"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Log_Destination.
func (*NokiaConf_Configure_Groups_Group_Filter_Log_Destination) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory represents the /nokia-conf/configure/groups/group/filter/log/destination/memory YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory struct {
	MaxEntries *uint32 `path:"max-entries" module:"nokia-conf"`
	StopOnFull *bool   `path:"stop-on-full" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory) IsYANGGoStruct() {}

// GetMaxEntries retrieves the value of the leaf MaxEntries from the NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxEntries is set, it can
// safely use t.GetMaxEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxEntries == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory) GetMaxEntries() uint32 {
	if t == nil || t.MaxEntries == nil {
		return 1000
	}
	return *t.MaxEntries
}

// GetStopOnFull retrieves the value of the leaf StopOnFull from the NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StopOnFull is set, it can
// safely use t.GetStopOnFull() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StopOnFull == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory) GetStopOnFull() bool {
	if t == nil || t.StopOnFull == nil {
		return false
	}
	return *t.StopOnFull
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.MaxEntries == nil {
		var v uint32 = 1000
		t.MaxEntries = &v
	}
	if t.StopOnFull == nil {
		var v bool = false
		t.StopOnFull = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory.
func (*NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Memory) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog represents the /nokia-conf/configure/groups/group/filter/log/destination/syslog YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog struct {
	Name     *string                                                                 `path:"name" module:"nokia-conf"`
	Summary  *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary `path:"summary" module:"nokia-conf"`
	SyslogId *string                                                                 `path:"syslog-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog) IsYANGGoStruct() {}

// GetOrCreateSummary retrieves the value of the Summary field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog) GetOrCreateSummary() *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary {
	if t.Summary != nil {
		return t.Summary
	}
	t.Summary = &NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary{}
	return t.Summary
}

// GetSummary returns the value of the Summary struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog. If the receiver or the field Summary is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog) GetSummary() *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary {
	if t != nil && t.Summary != nil {
		return t.Summary
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetSyslogId retrieves the value of the leaf SyslogId from the NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SyslogId is set, it can
// safely use t.GetSyslogId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SyslogId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog) GetSyslogId() string {
	if t == nil || t.SyslogId == nil {
		return ""
	}
	return *t.SyslogId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Summary.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog.
func (*NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary represents the /nokia-conf/configure/groups/group/filter/log/destination/syslog/summary YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary struct {
	AdminState  E_NokiaTypesSros_AdminState                  `path:"admin-state" module:"nokia-conf"`
	SummaryCrit E_NokiaTypesFilter_FilterLogSummaryCriterion `path:"summary-crit" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetSummaryCrit retrieves the value of the leaf SummaryCrit from the NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SummaryCrit is set, it can
// safely use t.GetSummaryCrit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SummaryCrit == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary) GetSummaryCrit() E_NokiaTypesFilter_FilterLogSummaryCriterion {
	if t == nil || t.SummaryCrit == 0 {
		return NokiaTypesFilter_FilterLogSummaryCriterion_src_addr
	}
	return t.SummaryCrit
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.SummaryCrit == 0 {
		t.SummaryCrit = NokiaTypesFilter_FilterLogSummaryCriterion_src_addr
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary.
func (*NokiaConf_Configure_Groups_Group_Filter_Log_Destination_Syslog_Summary) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter represents the /nokia-conf/configure/groups/group/filter/mac-filter YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter struct {
	DefaultAction E_NokiaTypesFilter_FilterDefaultAction                                                                                             `path:"default-action" module:"nokia-conf"`
	Description   *string                                                                                                                            `path:"description" module:"nokia-conf"`
	Embed         *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed                                                                           `path:"embed" module:"nokia-conf"`
	Entry         map[NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_EntryId_Union]*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry `path:"entry" module:"nokia-conf"`
	FilterId      *uint32                                                                                                                            `path:"filter-id" module:"nokia-conf"`
	FilterName    *string                                                                                                                            `path:"filter-name" module:"nokia-conf"`
	Scope         E_NokiaTypesFilter_FilterScope                                                                                                     `path:"scope" module:"nokia-conf"`
	Type          E_NokiaTypesQos_MacFilterType                                                                                                      `path:"type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Filter_MacFilter struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) NewEntry(EntryId NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_EntryId_Union) (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_EntryId_Union]*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry)
	}

	key := EntryId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry{
		EntryId: EntryId,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Filter_MacFilter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_EntryId_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.EntryId = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MacFilter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) GetOrCreateEntry(EntryId NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_EntryId_Union) *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry {

	key := EntryId

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(EntryId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Filter_MacFilter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) GetEntry(EntryId NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_EntryId_Union) *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry {

	if t == nil {
		return nil
	}

	key := EntryId

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MacFilter. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) DeleteEntry(EntryId NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_EntryId_Union) {
	key := EntryId

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Filter_MacFilter. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) AppendEntry(v *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) error {
	key := v.EntryId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_EntryId_Union]*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetOrCreateEmbed retrieves the value of the Embed field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) GetOrCreateEmbed() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed {
	if t.Embed != nil {
		return t.Embed
	}
	t.Embed = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed{}
	return t.Embed
}

// GetEmbed returns the value of the Embed struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter. If the receiver or the field Embed is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) GetEmbed() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed {
	if t != nil && t.Embed != nil {
		return t.Embed
	}
	return nil
}

// GetDefaultAction retrieves the value of the leaf DefaultAction from the NokiaConf_Configure_Groups_Group_Filter_MacFilter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultAction is set, it can
// safely use t.GetDefaultAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultAction == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) GetDefaultAction() E_NokiaTypesFilter_FilterDefaultAction {
	if t == nil || t.DefaultAction == 0 {
		return NokiaTypesFilter_FilterDefaultAction_drop
	}
	return t.DefaultAction
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Filter_MacFilter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilterId retrieves the value of the leaf FilterId from the NokiaConf_Configure_Groups_Group_Filter_MacFilter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FilterId is set, it can
// safely use t.GetFilterId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FilterId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) GetFilterId() uint32 {
	if t == nil || t.FilterId == nil {
		return 0
	}
	return *t.FilterId
}

// GetFilterName retrieves the value of the leaf FilterName from the NokiaConf_Configure_Groups_Group_Filter_MacFilter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FilterName is set, it can
// safely use t.GetFilterName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FilterName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) GetFilterName() string {
	if t == nil || t.FilterName == nil {
		return ""
	}
	return *t.FilterName
}

// GetScope retrieves the value of the leaf Scope from the NokiaConf_Configure_Groups_Group_Filter_MacFilter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Scope is set, it can
// safely use t.GetScope() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Scope == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) GetScope() E_NokiaTypesFilter_FilterScope {
	if t == nil || t.Scope == 0 {
		return NokiaTypesFilter_FilterScope_template
	}
	return t.Scope
}

// GetType retrieves the value of the leaf Type from the NokiaConf_Configure_Groups_Group_Filter_MacFilter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) GetType() E_NokiaTypesQos_MacFilterType {
	if t == nil || t.Type == 0 {
		return NokiaTypesQos_MacFilterType_normal
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DefaultAction == 0 {
		t.DefaultAction = NokiaTypesFilter_FilterDefaultAction_drop
	}
	if t.Scope == 0 {
		t.Scope = NokiaTypesFilter_FilterScope_template
	}
	if t.Type == 0 {
		t.Type = NokiaTypesQos_MacFilterType_normal
	}
	t.Embed.PopulateDefaults()
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MacFilter struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FilterName == nil {
		return nil, fmt.Errorf("nil value for key FilterName")
	}

	return map[string]interface{}{
		"filter-name": *t.FilterName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed represents the /nokia-conf/configure/groups/group/filter/mac-filter/embed YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed struct {
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed) IsYANGGoStruct() {}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Embed) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry struct {
	Action                *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action          `path:"action" module:"nokia-conf" yangPresence:"true"`
	CollectStats          *bool                                                                    `path:"collect-stats" module:"nokia-conf"`
	Description           *string                                                                  `path:"description" module:"nokia-conf"`
	EntryId               NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_EntryId_Union    `path:"entry-id" module:"nokia-conf"`
	Log                   *uint32                                                                  `path:"log" module:"nokia-conf"`
	Match                 *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match           `path:"match" module:"nokia-conf"`
	PbrDownActionOverride E_NokiaTypesFilter_FilterPbrDownActionOvr                                `path:"pbr-down-action-override" module:"nokia-conf"`
	StickyDest            NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_StickyDest_Union `path:"sticky-dest" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) IsYANGGoStruct() {}

// GetOrCreateAction retrieves the value of the Action field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) GetOrCreateAction() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action {
	if t.Action != nil {
		return t.Action
	}
	t.Action = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action{}
	return t.Action
}

// GetOrCreateMatch retrieves the value of the Match field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) GetOrCreateMatch() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match {
	if t.Match != nil {
		return t.Match
	}
	t.Match = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match{}
	return t.Match
}

// GetAction returns the value of the Action struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry. If the receiver or the field Action is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) GetAction() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action {
	if t != nil && t.Action != nil {
		return t.Action
	}
	return nil
}

// GetMatch returns the value of the Match struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry. If the receiver or the field Match is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) GetMatch() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match {
	if t != nil && t.Match != nil {
		return t.Match
	}
	return nil
}

// GetCollectStats retrieves the value of the leaf CollectStats from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CollectStats is set, it can
// safely use t.GetCollectStats() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CollectStats == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) GetCollectStats() bool {
	if t == nil || t.CollectStats == nil {
		return false
	}
	return *t.CollectStats
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEntryId retrieves the value of the leaf EntryId from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EntryId is set, it can
// safely use t.GetEntryId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EntryId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) GetEntryId() NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_EntryId_Union {
	if t == nil || t.EntryId == nil {
		return nil
	}
	return t.EntryId
}

// GetLog retrieves the value of the leaf Log from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Log is set, it can
// safely use t.GetLog() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Log == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) GetLog() uint32 {
	if t == nil || t.Log == nil {
		return 0
	}
	return *t.Log
}

// GetPbrDownActionOverride retrieves the value of the leaf PbrDownActionOverride from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PbrDownActionOverride is set, it can
// safely use t.GetPbrDownActionOverride() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PbrDownActionOverride == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) GetPbrDownActionOverride() E_NokiaTypesFilter_FilterPbrDownActionOvr {
	if t == nil || t.PbrDownActionOverride == 0 {
		return 0
	}
	return t.PbrDownActionOverride
}

// GetStickyDest retrieves the value of the leaf StickyDest from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StickyDest is set, it can
// safely use t.GetStickyDest() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StickyDest == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) GetStickyDest() NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_StickyDest_Union {
	if t == nil || t.StickyDest == nil {
		return nil
	}
	return t.StickyDest
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CollectStats == nil {
		var v bool = false
		t.CollectStats = &v
	}
	t.Action.PopulateDefaults()
	t.Match.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"entry-id": t.EntryId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/action YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action struct {
	Accept       YANGEmpty                                                                    `path:"accept" module:"nokia-conf"`
	Drop         YANGEmpty                                                                    `path:"drop" module:"nokia-conf"`
	Fc           E_NokiaTypesSros_FcName                                                      `path:"fc" module:"nokia-conf"`
	Forward      *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward      `path:"forward" module:"nokia-conf"`
	HttpRedirect *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect `path:"http-redirect" module:"nokia-conf" yangPresence:"true"`
	IgnoreMatch  YANGEmpty                                                                    `path:"ignore-match" module:"nokia-conf"`
	RateLimit    *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit    `path:"rate-limit" module:"nokia-conf" yangPresence:"true"`
	Secondary    *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary    `path:"secondary" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) IsYANGGoStruct() {}

// GetOrCreateForward retrieves the value of the Forward field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) GetOrCreateForward() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward {
	if t.Forward != nil {
		return t.Forward
	}
	t.Forward = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward{}
	return t.Forward
}

// GetOrCreateHttpRedirect retrieves the value of the HttpRedirect field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) GetOrCreateHttpRedirect() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect {
	if t.HttpRedirect != nil {
		return t.HttpRedirect
	}
	t.HttpRedirect = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect{}
	return t.HttpRedirect
}

// GetOrCreateRateLimit retrieves the value of the RateLimit field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) GetOrCreateRateLimit() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit {
	if t.RateLimit != nil {
		return t.RateLimit
	}
	t.RateLimit = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit{}
	return t.RateLimit
}

// GetOrCreateSecondary retrieves the value of the Secondary field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) GetOrCreateSecondary() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary {
	if t.Secondary != nil {
		return t.Secondary
	}
	t.Secondary = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary{}
	return t.Secondary
}

// GetForward returns the value of the Forward struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action. If the receiver or the field Forward is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) GetForward() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward {
	if t != nil && t.Forward != nil {
		return t.Forward
	}
	return nil
}

// GetHttpRedirect returns the value of the HttpRedirect struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action. If the receiver or the field HttpRedirect is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) GetHttpRedirect() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect {
	if t != nil && t.HttpRedirect != nil {
		return t.HttpRedirect
	}
	return nil
}

// GetRateLimit returns the value of the RateLimit struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action. If the receiver or the field RateLimit is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) GetRateLimit() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit {
	if t != nil && t.RateLimit != nil {
		return t.RateLimit
	}
	return nil
}

// GetSecondary returns the value of the Secondary struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action. If the receiver or the field Secondary is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) GetSecondary() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary {
	if t != nil && t.Secondary != nil {
		return t.Secondary
	}
	return nil
}

// GetAccept retrieves the value of the leaf Accept from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Accept is set, it can
// safely use t.GetAccept() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Accept == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) GetAccept() YANGEmpty {
	if t == nil || t.Accept == false {
		return false
	}
	return t.Accept
}

// GetDrop retrieves the value of the leaf Drop from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Drop is set, it can
// safely use t.GetDrop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Drop == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) GetDrop() YANGEmpty {
	if t == nil || t.Drop == false {
		return false
	}
	return t.Drop
}

// GetFc retrieves the value of the leaf Fc from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fc is set, it can
// safely use t.GetFc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fc == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) GetFc() E_NokiaTypesSros_FcName {
	if t == nil || t.Fc == 0 {
		return 0
	}
	return t.Fc
}

// GetIgnoreMatch retrieves the value of the leaf IgnoreMatch from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IgnoreMatch is set, it can
// safely use t.GetIgnoreMatch() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IgnoreMatch == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) GetIgnoreMatch() YANGEmpty {
	if t == nil || t.IgnoreMatch == false {
		return false
	}
	return t.IgnoreMatch
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Forward.PopulateDefaults()
	t.HttpRedirect.PopulateDefaults()
	t.RateLimit.PopulateDefaults()
	t.Secondary.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/action/forward YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward struct {
	EsiL2 *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2 `path:"esi-l2" module:"nokia-conf" yangPresence:"true"`
	Sap   *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap   `path:"sap" module:"nokia-conf" yangPresence:"true"`
	Sdp   *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp   `path:"sdp" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward) IsYANGGoStruct() {}

// GetOrCreateEsiL2 retrieves the value of the EsiL2 field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward) GetOrCreateEsiL2() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2 {
	if t.EsiL2 != nil {
		return t.EsiL2
	}
	t.EsiL2 = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2{}
	return t.EsiL2
}

// GetOrCreateSap retrieves the value of the Sap field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward) GetOrCreateSap() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap {
	if t.Sap != nil {
		return t.Sap
	}
	t.Sap = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap{}
	return t.Sap
}

// GetOrCreateSdp retrieves the value of the Sdp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward) GetOrCreateSdp() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp {
	if t.Sdp != nil {
		return t.Sdp
	}
	t.Sdp = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp{}
	return t.Sdp
}

// GetEsiL2 returns the value of the EsiL2 struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward. If the receiver or the field EsiL2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward) GetEsiL2() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2 {
	if t != nil && t.EsiL2 != nil {
		return t.EsiL2
	}
	return nil
}

// GetSap returns the value of the Sap struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward. If the receiver or the field Sap is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward) GetSap() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap {
	if t != nil && t.Sap != nil {
		return t.Sap
	}
	return nil
}

// GetSdp returns the value of the Sdp struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward. If the receiver or the field Sdp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward) GetSdp() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp {
	if t != nil && t.Sdp != nil {
		return t.Sdp
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.EsiL2.PopulateDefaults()
	t.Sap.PopulateDefaults()
	t.Sdp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2 represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/action/forward/esi-l2 YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2 struct {
	EsiValue *string `path:"esi-value" module:"nokia-conf"`
	Vpls     *string `path:"vpls" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2) IsYANGGoStruct() {
}

// GetEsiValue retrieves the value of the leaf EsiValue from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EsiValue is set, it can
// safely use t.GetEsiValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EsiValue == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2) GetEsiValue() string {
	if t == nil || t.EsiValue == nil {
		return ""
	}
	return *t.EsiValue
}

// GetVpls retrieves the value of the leaf Vpls from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpls is set, it can
// safely use t.GetVpls() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpls == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2) GetVpls() string {
	if t == nil || t.Vpls == nil {
		return ""
	}
	return *t.Vpls
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_EsiL2) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/action/forward/sap YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap struct {
	SapId *string `path:"sap-id" module:"nokia-conf"`
	Vpls  *string `path:"vpls" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap) IsYANGGoStruct() {}

// GetSapId retrieves the value of the leaf SapId from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SapId is set, it can
// safely use t.GetSapId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SapId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap) GetSapId() string {
	if t == nil || t.SapId == nil {
		return ""
	}
	return *t.SapId
}

// GetVpls retrieves the value of the leaf Vpls from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpls is set, it can
// safely use t.GetVpls() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpls == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap) GetVpls() string {
	if t == nil || t.Vpls == nil {
		return ""
	}
	return *t.Vpls
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sap) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/action/forward/sdp YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp struct {
	SdpBindId *string `path:"sdp-bind-id" module:"nokia-conf"`
	Vpls      *string `path:"vpls" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp) IsYANGGoStruct() {}

// GetSdpBindId retrieves the value of the leaf SdpBindId from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SdpBindId is set, it can
// safely use t.GetSdpBindId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SdpBindId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp) GetSdpBindId() string {
	if t == nil || t.SdpBindId == nil {
		return ""
	}
	return *t.SdpBindId
}

// GetVpls retrieves the value of the leaf Vpls from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpls is set, it can
// safely use t.GetVpls() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpls == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp) GetVpls() string {
	if t == nil || t.Vpls == nil {
		return ""
	}
	return *t.Vpls
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Forward_Sdp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/action/http-redirect YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect struct {
	Url *string `path:"url" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect) IsYANGGoStruct() {
}

// GetUrl retrieves the value of the leaf Url from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Url is set, it can
// safely use t.GetUrl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Url == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect) GetUrl() string {
	if t == nil || t.Url == nil {
		return ""
	}
	return *t.Url
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_HttpRedirect) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/action/rate-limit YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit struct {
	Pir NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit_Pir_Union `path:"pir" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit) IsYANGGoStruct() {}

// GetPir retrieves the value of the leaf Pir from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Pir is set, it can
// safely use t.GetPir() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Pir == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit) GetPir() NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit_Pir_Union {
	if t == nil || t.Pir == nil {
		return nil
	}
	return t.Pir
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_RateLimit) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/action/secondary YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary struct {
	Forward *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward `path:"forward" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary) IsYANGGoStruct() {}

// GetOrCreateForward retrieves the value of the Forward field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary) GetOrCreateForward() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward {
	if t.Forward != nil {
		return t.Forward
	}
	t.Forward = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward{}
	return t.Forward
}

// GetForward returns the value of the Forward struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary. If the receiver or the field Forward is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary) GetForward() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward {
	if t != nil && t.Forward != nil {
		return t.Forward
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Forward.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/action/secondary/forward YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward struct {
	Sap *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap `path:"sap" module:"nokia-conf" yangPresence:"true"`
	Sdp *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp `path:"sdp" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward) IsYANGGoStruct() {
}

// GetOrCreateSap retrieves the value of the Sap field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward) GetOrCreateSap() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap {
	if t.Sap != nil {
		return t.Sap
	}
	t.Sap = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap{}
	return t.Sap
}

// GetOrCreateSdp retrieves the value of the Sdp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward) GetOrCreateSdp() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp {
	if t.Sdp != nil {
		return t.Sdp
	}
	t.Sdp = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp{}
	return t.Sdp
}

// GetSap returns the value of the Sap struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward. If the receiver or the field Sap is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward) GetSap() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap {
	if t != nil && t.Sap != nil {
		return t.Sap
	}
	return nil
}

// GetSdp returns the value of the Sdp struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward. If the receiver or the field Sdp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward) GetSdp() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp {
	if t != nil && t.Sdp != nil {
		return t.Sdp
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Sap.PopulateDefaults()
	t.Sdp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/action/secondary/forward/sap YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap struct {
	SapId *string `path:"sap-id" module:"nokia-conf"`
	Vpls  *string `path:"vpls" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap) IsYANGGoStruct() {
}

// GetSapId retrieves the value of the leaf SapId from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SapId is set, it can
// safely use t.GetSapId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SapId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap) GetSapId() string {
	if t == nil || t.SapId == nil {
		return ""
	}
	return *t.SapId
}

// GetVpls retrieves the value of the leaf Vpls from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpls is set, it can
// safely use t.GetVpls() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpls == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap) GetVpls() string {
	if t == nil || t.Vpls == nil {
		return ""
	}
	return *t.Vpls
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sap) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/action/secondary/forward/sdp YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp struct {
	SdpBindId *string `path:"sdp-bind-id" module:"nokia-conf"`
	Vpls      *string `path:"vpls" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp) IsYANGGoStruct() {
}

// GetSdpBindId retrieves the value of the leaf SdpBindId from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SdpBindId is set, it can
// safely use t.GetSdpBindId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SdpBindId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp) GetSdpBindId() string {
	if t == nil || t.SdpBindId == nil {
		return ""
	}
	return *t.SdpBindId
}

// GetVpls retrieves the value of the leaf Vpls from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vpls is set, it can
// safely use t.GetVpls() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vpls == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp) GetVpls() string {
	if t == nil || t.Vpls == nil {
		return ""
	}
	return *t.Vpls
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Action_Secondary_Forward_Sdp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/match YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match struct {
	Dot1P     *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P    `path:"dot1p" module:"nokia-conf" yangPresence:"true"`
	DstMac    *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac   `path:"dst-mac" module:"nokia-conf" yangPresence:"true"`
	Etype     *string                                                                 `path:"etype" module:"nokia-conf"`
	FrameType E_NokiaTypesFilter_MacFrameType                                         `path:"frame-type" module:"nokia-conf"`
	InnerTag  *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag `path:"inner-tag" module:"nokia-conf" yangPresence:"true"`
	Isid      *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid     `path:"isid" module:"nokia-conf"`
	LlcDsap   *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap  `path:"llc-dsap" module:"nokia-conf" yangPresence:"true"`
	LlcSsap   *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap  `path:"llc-ssap" module:"nokia-conf" yangPresence:"true"`
	OuterTag  *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag `path:"outer-tag" module:"nokia-conf" yangPresence:"true"`
	SnapOui   E_NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SnapOui `path:"snap-oui" module:"nokia-conf"`
	SnapPid   *int32                                                                  `path:"snap-pid" module:"nokia-conf"`
	SrcMac    *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac   `path:"src-mac" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) IsYANGGoStruct() {}

// GetOrCreateDot1P retrieves the value of the Dot1P field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetOrCreateDot1P() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P {
	if t.Dot1P != nil {
		return t.Dot1P
	}
	t.Dot1P = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P{}
	return t.Dot1P
}

// GetOrCreateDstMac retrieves the value of the DstMac field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetOrCreateDstMac() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac {
	if t.DstMac != nil {
		return t.DstMac
	}
	t.DstMac = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac{}
	return t.DstMac
}

// GetOrCreateInnerTag retrieves the value of the InnerTag field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetOrCreateInnerTag() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag {
	if t.InnerTag != nil {
		return t.InnerTag
	}
	t.InnerTag = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag{}
	return t.InnerTag
}

// GetOrCreateIsid retrieves the value of the Isid field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetOrCreateIsid() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid {
	if t.Isid != nil {
		return t.Isid
	}
	t.Isid = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid{}
	return t.Isid
}

// GetOrCreateLlcDsap retrieves the value of the LlcDsap field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetOrCreateLlcDsap() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap {
	if t.LlcDsap != nil {
		return t.LlcDsap
	}
	t.LlcDsap = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap{}
	return t.LlcDsap
}

// GetOrCreateLlcSsap retrieves the value of the LlcSsap field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetOrCreateLlcSsap() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap {
	if t.LlcSsap != nil {
		return t.LlcSsap
	}
	t.LlcSsap = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap{}
	return t.LlcSsap
}

// GetOrCreateOuterTag retrieves the value of the OuterTag field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetOrCreateOuterTag() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag {
	if t.OuterTag != nil {
		return t.OuterTag
	}
	t.OuterTag = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag{}
	return t.OuterTag
}

// GetOrCreateSrcMac retrieves the value of the SrcMac field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetOrCreateSrcMac() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac {
	if t.SrcMac != nil {
		return t.SrcMac
	}
	t.SrcMac = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac{}
	return t.SrcMac
}

// GetDot1P returns the value of the Dot1P struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match. If the receiver or the field Dot1P is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetDot1P() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P {
	if t != nil && t.Dot1P != nil {
		return t.Dot1P
	}
	return nil
}

// GetDstMac returns the value of the DstMac struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match. If the receiver or the field DstMac is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetDstMac() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac {
	if t != nil && t.DstMac != nil {
		return t.DstMac
	}
	return nil
}

// GetInnerTag returns the value of the InnerTag struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match. If the receiver or the field InnerTag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetInnerTag() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag {
	if t != nil && t.InnerTag != nil {
		return t.InnerTag
	}
	return nil
}

// GetIsid returns the value of the Isid struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match. If the receiver or the field Isid is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetIsid() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid {
	if t != nil && t.Isid != nil {
		return t.Isid
	}
	return nil
}

// GetLlcDsap returns the value of the LlcDsap struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match. If the receiver or the field LlcDsap is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetLlcDsap() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap {
	if t != nil && t.LlcDsap != nil {
		return t.LlcDsap
	}
	return nil
}

// GetLlcSsap returns the value of the LlcSsap struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match. If the receiver or the field LlcSsap is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetLlcSsap() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap {
	if t != nil && t.LlcSsap != nil {
		return t.LlcSsap
	}
	return nil
}

// GetOuterTag returns the value of the OuterTag struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match. If the receiver or the field OuterTag is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetOuterTag() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag {
	if t != nil && t.OuterTag != nil {
		return t.OuterTag
	}
	return nil
}

// GetSrcMac returns the value of the SrcMac struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match. If the receiver or the field SrcMac is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetSrcMac() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac {
	if t != nil && t.SrcMac != nil {
		return t.SrcMac
	}
	return nil
}

// GetEtype retrieves the value of the leaf Etype from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Etype is set, it can
// safely use t.GetEtype() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Etype == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetEtype() string {
	if t == nil || t.Etype == nil {
		return ""
	}
	return *t.Etype
}

// GetFrameType retrieves the value of the leaf FrameType from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FrameType is set, it can
// safely use t.GetFrameType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FrameType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetFrameType() E_NokiaTypesFilter_MacFrameType {
	if t == nil || t.FrameType == 0 {
		return 0
	}
	return t.FrameType
}

// GetSnapOui retrieves the value of the leaf SnapOui from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SnapOui is set, it can
// safely use t.GetSnapOui() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SnapOui == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetSnapOui() E_NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SnapOui {
	if t == nil || t.SnapOui == 0 {
		return 0
	}
	return t.SnapOui
}

// GetSnapPid retrieves the value of the leaf SnapPid from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SnapPid is set, it can
// safely use t.GetSnapPid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SnapPid == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) GetSnapPid() int32 {
	if t == nil || t.SnapPid == nil {
		return 0
	}
	return *t.SnapPid
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Dot1P.PopulateDefaults()
	t.DstMac.PopulateDefaults()
	t.InnerTag.PopulateDefaults()
	t.Isid.PopulateDefaults()
	t.LlcDsap.PopulateDefaults()
	t.LlcSsap.PopulateDefaults()
	t.OuterTag.PopulateDefaults()
	t.SrcMac.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/match/dot1p YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P struct {
	Mask     *int32 `path:"mask" module:"nokia-conf"`
	Priority *int32 `path:"priority" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P) IsYANGGoStruct() {}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P) GetMask() int32 {
	if t == nil || t.Mask == nil {
		return 7
	}
	return *t.Mask
}

// GetPriority retrieves the value of the leaf Priority from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P) GetPriority() int32 {
	if t == nil || t.Priority == nil {
		return 0
	}
	return *t.Priority
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mask == nil {
		var v int32 = 7
		t.Mask = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Dot1P) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/match/dst-mac YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac struct {
	Address *string `path:"address" module:"nokia-conf"`
	Mask    *string `path:"mask" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac) GetMask() string {
	if t == nil || t.Mask == nil {
		return "ff:ff:ff:ff:ff:ff"
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mask == nil {
		var v string = "ff:ff:ff:ff:ff:ff"
		t.Mask = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_DstMac) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/match/inner-tag YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag struct {
	Mask *uint32 `path:"mask" module:"nokia-conf"`
	Tag  *int32  `path:"tag" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag) IsYANGGoStruct() {}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag) GetMask() uint32 {
	if t == nil || t.Mask == nil {
		return 4095
	}
	return *t.Mask
}

// GetTag retrieves the value of the leaf Tag from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tag is set, it can
// safely use t.GetTag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tag == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag) GetTag() int32 {
	if t == nil || t.Tag == nil {
		return 0
	}
	return *t.Tag
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mask == nil {
		var v uint32 = 4095
		t.Mask = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_InnerTag) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/match/isid YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid struct {
	Range *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
	Value *int32                                                                    `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid) GetRange() *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid) GetValue() int32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/match/isid/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range struct {
	End   *int32 `path:"end" module:"nokia-conf"`
	Start *int32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range) GetEnd() int32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range) GetStart() int32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_Isid_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/match/llc-dsap YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap struct {
	Dsap *int32 `path:"dsap" module:"nokia-conf"`
	Mask *int32 `path:"mask" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap) IsYANGGoStruct() {}

// GetDsap retrieves the value of the leaf Dsap from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dsap is set, it can
// safely use t.GetDsap() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dsap == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap) GetDsap() int32 {
	if t == nil || t.Dsap == nil {
		return 0
	}
	return *t.Dsap
}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap) GetMask() int32 {
	if t == nil || t.Mask == nil {
		return 255
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mask == nil {
		var v int32 = 255
		t.Mask = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcDsap) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/match/llc-ssap YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap struct {
	Mask *int32 `path:"mask" module:"nokia-conf"`
	Ssap *int32 `path:"ssap" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap) IsYANGGoStruct() {}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap) GetMask() int32 {
	if t == nil || t.Mask == nil {
		return 255
	}
	return *t.Mask
}

// GetSsap retrieves the value of the leaf Ssap from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ssap is set, it can
// safely use t.GetSsap() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ssap == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap) GetSsap() int32 {
	if t == nil || t.Ssap == nil {
		return 0
	}
	return *t.Ssap
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mask == nil {
		var v int32 = 255
		t.Mask = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_LlcSsap) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/match/outer-tag YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag struct {
	Mask *uint32 `path:"mask" module:"nokia-conf"`
	Tag  *int32  `path:"tag" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag) IsYANGGoStruct() {}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag) GetMask() uint32 {
	if t == nil || t.Mask == nil {
		return 4095
	}
	return *t.Mask
}

// GetTag retrieves the value of the leaf Tag from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tag is set, it can
// safely use t.GetTag() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tag == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag) GetTag() int32 {
	if t == nil || t.Tag == nil {
		return 0
	}
	return *t.Tag
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mask == nil {
		var v uint32 = 4095
		t.Mask = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_OuterTag) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac represents the /nokia-conf/configure/groups/group/filter/mac-filter/entry/match/src-mac YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac struct {
	Address *string `path:"address" module:"nokia-conf"`
	Mask    *string `path:"mask" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac) IsYANGGoStruct() {}

// GetAddress retrieves the value of the leaf Address from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Address is set, it can
// safely use t.GetAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Address == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac) GetAddress() string {
	if t == nil || t.Address == nil {
		return ""
	}
	return *t.Address
}

// GetMask retrieves the value of the leaf Mask from the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mask is set, it can
// safely use t.GetMask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac) GetMask() string {
	if t == nil || t.Mask == nil {
		return "ff:ff:ff:ff:ff:ff"
	}
	return *t.Mask
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mask == nil {
		var v string = "ff:ff:ff:ff:ff:ff"
		t.Mask = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac.
func (*NokiaConf_Configure_Groups_Group_Filter_MacFilter_Entry_Match_SrcMac) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList represents the /nokia-conf/configure/groups/group/filter/match-list YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList struct {
	IpPrefixList   map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList   `path:"ip-prefix-list" module:"nokia-conf"`
	Ipv6PrefixList map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList `path:"ipv6-prefix-list" module:"nokia-conf"`
	PortList       map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList       `path:"port-list" module:"nokia-conf"`
	ProtocolList   map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList   `path:"protocol-list" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList) IsYANGGoStruct() {}

// NewIpPrefixList creates a new entry in the IpPrefixList list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) NewIpPrefixList(PrefixListName string) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpPrefixList == nil {
		t.IpPrefixList = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList)
	}

	key := PrefixListName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IpPrefixList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IpPrefixList", key)
	}

	t.IpPrefixList[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList{
		PrefixListName: &PrefixListName,
	}

	return t.IpPrefixList[key], nil
}

// RenameIpPrefixList renames an entry in the list IpPrefixList within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) RenameIpPrefixList(oldK, newK string) error {
	if _, ok := t.IpPrefixList[newK]; ok {
		return fmt.Errorf("key %v already exists in IpPrefixList", newK)
	}

	e, ok := t.IpPrefixList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IpPrefixList", oldK)
	}
	e.PrefixListName = &newK

	t.IpPrefixList[newK] = e
	delete(t.IpPrefixList, oldK)
	return nil
}

// GetOrCreateIpPrefixList retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) GetOrCreateIpPrefixList(PrefixListName string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList {

	key := PrefixListName

	if v, ok := t.IpPrefixList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpPrefixList(PrefixListName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpPrefixList got unexpected error: %v", err))
	}
	return v
}

// GetIpPrefixList retrieves the value with the specified key from
// the IpPrefixList map field of NokiaConf_Configure_Groups_Group_Filter_MatchList. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) GetIpPrefixList(PrefixListName string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList {

	if t == nil {
		return nil
	}

	key := PrefixListName

	if lm, ok := t.IpPrefixList[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpPrefixList deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) DeleteIpPrefixList(PrefixListName string) {
	key := PrefixListName

	delete(t.IpPrefixList, key)
}

// AppendIpPrefixList appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList struct to the
// list IpPrefixList of NokiaConf_Configure_Groups_Group_Filter_MatchList. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) AppendIpPrefixList(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) error {
	if v.PrefixListName == nil {
		return fmt.Errorf("invalid nil key received for PrefixListName")
	}

	key := *v.PrefixListName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpPrefixList == nil {
		t.IpPrefixList = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList)
	}

	if _, ok := t.IpPrefixList[key]; ok {
		return fmt.Errorf("duplicate key for list IpPrefixList %v", key)
	}

	t.IpPrefixList[key] = v
	return nil
}

// NewIpv6PrefixList creates a new entry in the Ipv6PrefixList list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) NewIpv6PrefixList(PrefixListName string) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6PrefixList == nil {
		t.Ipv6PrefixList = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList)
	}

	key := PrefixListName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6PrefixList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6PrefixList", key)
	}

	t.Ipv6PrefixList[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList{
		PrefixListName: &PrefixListName,
	}

	return t.Ipv6PrefixList[key], nil
}

// RenameIpv6PrefixList renames an entry in the list Ipv6PrefixList within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) RenameIpv6PrefixList(oldK, newK string) error {
	if _, ok := t.Ipv6PrefixList[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6PrefixList", newK)
	}

	e, ok := t.Ipv6PrefixList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6PrefixList", oldK)
	}
	e.PrefixListName = &newK

	t.Ipv6PrefixList[newK] = e
	delete(t.Ipv6PrefixList, oldK)
	return nil
}

// GetOrCreateIpv6PrefixList retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) GetOrCreateIpv6PrefixList(PrefixListName string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList {

	key := PrefixListName

	if v, ok := t.Ipv6PrefixList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6PrefixList(PrefixListName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6PrefixList got unexpected error: %v", err))
	}
	return v
}

// GetIpv6PrefixList retrieves the value with the specified key from
// the Ipv6PrefixList map field of NokiaConf_Configure_Groups_Group_Filter_MatchList. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) GetIpv6PrefixList(PrefixListName string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList {

	if t == nil {
		return nil
	}

	key := PrefixListName

	if lm, ok := t.Ipv6PrefixList[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6PrefixList deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) DeleteIpv6PrefixList(PrefixListName string) {
	key := PrefixListName

	delete(t.Ipv6PrefixList, key)
}

// AppendIpv6PrefixList appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList struct to the
// list Ipv6PrefixList of NokiaConf_Configure_Groups_Group_Filter_MatchList. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) AppendIpv6PrefixList(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) error {
	if v.PrefixListName == nil {
		return fmt.Errorf("invalid nil key received for PrefixListName")
	}

	key := *v.PrefixListName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6PrefixList == nil {
		t.Ipv6PrefixList = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList)
	}

	if _, ok := t.Ipv6PrefixList[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6PrefixList %v", key)
	}

	t.Ipv6PrefixList[key] = v
	return nil
}

// NewPortList creates a new entry in the PortList list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) NewPortList(PortListName string) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PortList == nil {
		t.PortList = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList)
	}

	key := PortListName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PortList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PortList", key)
	}

	t.PortList[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList{
		PortListName: &PortListName,
	}

	return t.PortList[key], nil
}

// RenamePortList renames an entry in the list PortList within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) RenamePortList(oldK, newK string) error {
	if _, ok := t.PortList[newK]; ok {
		return fmt.Errorf("key %v already exists in PortList", newK)
	}

	e, ok := t.PortList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PortList", oldK)
	}
	e.PortListName = &newK

	t.PortList[newK] = e
	delete(t.PortList, oldK)
	return nil
}

// GetOrCreatePortList retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) GetOrCreatePortList(PortListName string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList {

	key := PortListName

	if v, ok := t.PortList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPortList(PortListName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePortList got unexpected error: %v", err))
	}
	return v
}

// GetPortList retrieves the value with the specified key from
// the PortList map field of NokiaConf_Configure_Groups_Group_Filter_MatchList. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) GetPortList(PortListName string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList {

	if t == nil {
		return nil
	}

	key := PortListName

	if lm, ok := t.PortList[key]; ok {
		return lm
	}
	return nil
}

// DeletePortList deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) DeletePortList(PortListName string) {
	key := PortListName

	delete(t.PortList, key)
}

// AppendPortList appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList struct to the
// list PortList of NokiaConf_Configure_Groups_Group_Filter_MatchList. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) AppendPortList(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) error {
	if v.PortListName == nil {
		return fmt.Errorf("invalid nil key received for PortListName")
	}

	key := *v.PortListName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PortList == nil {
		t.PortList = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList)
	}

	if _, ok := t.PortList[key]; ok {
		return fmt.Errorf("duplicate key for list PortList %v", key)
	}

	t.PortList[key] = v
	return nil
}

// NewProtocolList creates a new entry in the ProtocolList list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) NewProtocolList(ProtocolListName string) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ProtocolList == nil {
		t.ProtocolList = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList)
	}

	key := ProtocolListName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ProtocolList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ProtocolList", key)
	}

	t.ProtocolList[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList{
		ProtocolListName: &ProtocolListName,
	}

	return t.ProtocolList[key], nil
}

// RenameProtocolList renames an entry in the list ProtocolList within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) RenameProtocolList(oldK, newK string) error {
	if _, ok := t.ProtocolList[newK]; ok {
		return fmt.Errorf("key %v already exists in ProtocolList", newK)
	}

	e, ok := t.ProtocolList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ProtocolList", oldK)
	}
	e.ProtocolListName = &newK

	t.ProtocolList[newK] = e
	delete(t.ProtocolList, oldK)
	return nil
}

// GetOrCreateProtocolList retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) GetOrCreateProtocolList(ProtocolListName string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList {

	key := ProtocolListName

	if v, ok := t.ProtocolList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProtocolList(ProtocolListName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProtocolList got unexpected error: %v", err))
	}
	return v
}

// GetProtocolList retrieves the value with the specified key from
// the ProtocolList map field of NokiaConf_Configure_Groups_Group_Filter_MatchList. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) GetProtocolList(ProtocolListName string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList {

	if t == nil {
		return nil
	}

	key := ProtocolListName

	if lm, ok := t.ProtocolList[key]; ok {
		return lm
	}
	return nil
}

// DeleteProtocolList deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) DeleteProtocolList(ProtocolListName string) {
	key := ProtocolListName

	delete(t.ProtocolList, key)
}

// AppendProtocolList appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList struct to the
// list ProtocolList of NokiaConf_Configure_Groups_Group_Filter_MatchList. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) AppendProtocolList(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) error {
	if v.ProtocolListName == nil {
		return fmt.Errorf("invalid nil key received for ProtocolListName")
	}

	key := *v.ProtocolListName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ProtocolList == nil {
		t.ProtocolList = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList)
	}

	if _, ok := t.ProtocolList[key]; ok {
		return fmt.Errorf("duplicate key for list ProtocolList %v", key)
	}

	t.ProtocolList[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.IpPrefixList {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv6PrefixList {
		e.PopulateDefaults()
	}
	for _, e := range t.PortList {
		e.PopulateDefaults()
	}
	for _, e := range t.ProtocolList {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList represents the /nokia-conf/configure/groups/group/filter/match-list/ip-prefix-list YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList struct {
	ApplyPath      *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath                `path:"apply-path" module:"nokia-conf"`
	Description    *string                                                                                  `path:"description" module:"nokia-conf"`
	Prefix         map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix        `path:"prefix" module:"nokia-conf"`
	PrefixExclude  map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude `path:"prefix-exclude" module:"nokia-conf"`
	PrefixListName *string                                                                                  `path:"prefix-list-name" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) IsYANGGoStruct() {}

// NewPrefix creates a new entry in the Prefix list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) NewPrefix(IpPrefix string) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix)
	}

	key := IpPrefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix{
		IpPrefix: &IpPrefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.IpPrefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) GetOrCreatePrefix(IpPrefix string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix {

	key := IpPrefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(IpPrefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) GetPrefix(IpPrefix string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix {

	if t == nil {
		return nil
	}

	key := IpPrefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) DeletePrefix(IpPrefix string) {
	key := IpPrefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix struct to the
// list Prefix of NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) AppendPrefix(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix) error {
	if v.IpPrefix == nil {
		return fmt.Errorf("invalid nil key received for IpPrefix")
	}

	key := *v.IpPrefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// NewPrefixExclude creates a new entry in the PrefixExclude list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) NewPrefixExclude(IpPrefix string) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixExclude == nil {
		t.PrefixExclude = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude)
	}

	key := IpPrefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixExclude[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixExclude", key)
	}

	t.PrefixExclude[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude{
		IpPrefix: &IpPrefix,
	}

	return t.PrefixExclude[key], nil
}

// RenamePrefixExclude renames an entry in the list PrefixExclude within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) RenamePrefixExclude(oldK, newK string) error {
	if _, ok := t.PrefixExclude[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixExclude", newK)
	}

	e, ok := t.PrefixExclude[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixExclude", oldK)
	}
	e.IpPrefix = &newK

	t.PrefixExclude[newK] = e
	delete(t.PrefixExclude, oldK)
	return nil
}

// GetOrCreatePrefixExclude retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) GetOrCreatePrefixExclude(IpPrefix string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude {

	key := IpPrefix

	if v, ok := t.PrefixExclude[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixExclude(IpPrefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixExclude got unexpected error: %v", err))
	}
	return v
}

// GetPrefixExclude retrieves the value with the specified key from
// the PrefixExclude map field of NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) GetPrefixExclude(IpPrefix string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude {

	if t == nil {
		return nil
	}

	key := IpPrefix

	if lm, ok := t.PrefixExclude[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefixExclude deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) DeletePrefixExclude(IpPrefix string) {
	key := IpPrefix

	delete(t.PrefixExclude, key)
}

// AppendPrefixExclude appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude struct to the
// list PrefixExclude of NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) AppendPrefixExclude(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude) error {
	if v.IpPrefix == nil {
		return fmt.Errorf("invalid nil key received for IpPrefix")
	}

	key := *v.IpPrefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixExclude == nil {
		t.PrefixExclude = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude)
	}

	if _, ok := t.PrefixExclude[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixExclude %v", key)
	}

	t.PrefixExclude[key] = v
	return nil
}

// GetOrCreateApplyPath retrieves the value of the ApplyPath field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) GetOrCreateApplyPath() *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath {
	if t.ApplyPath != nil {
		return t.ApplyPath
	}
	t.ApplyPath = &NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath{}
	return t.ApplyPath
}

// GetApplyPath returns the value of the ApplyPath struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList. If the receiver or the field ApplyPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) GetApplyPath() *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath {
	if t != nil && t.ApplyPath != nil {
		return t.ApplyPath
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetPrefixListName retrieves the value of the leaf PrefixListName from the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixListName is set, it can
// safely use t.GetPrefixListName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixListName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) GetPrefixListName() string {
	if t == nil || t.PrefixListName == nil {
		return ""
	}
	return *t.PrefixListName
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ApplyPath.PopulateDefaults()
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
	for _, e := range t.PrefixExclude {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PrefixListName == nil {
		return nil, fmt.Errorf("nil value for key PrefixListName")
	}

	return map[string]interface{}{
		"prefix-list-name": *t.PrefixListName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath represents the /nokia-conf/configure/groups/group/filter/match-list/ip-prefix-list/apply-path YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath struct {
	BgpPeers map[NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers_CriterionIndex_Union]*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers `path:"bgp-peers" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath) IsYANGGoStruct() {}

// NewBgpPeers creates a new entry in the BgpPeers list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath) NewBgpPeers(CriterionIndex NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers_CriterionIndex_Union) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BgpPeers == nil {
		t.BgpPeers = make(map[NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers_CriterionIndex_Union]*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers)
	}

	key := CriterionIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BgpPeers[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BgpPeers", key)
	}

	t.BgpPeers[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers{
		CriterionIndex: CriterionIndex,
	}

	return t.BgpPeers[key], nil
}

// RenameBgpPeers renames an entry in the list BgpPeers within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath) RenameBgpPeers(oldK, newK NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers_CriterionIndex_Union) error {
	if _, ok := t.BgpPeers[newK]; ok {
		return fmt.Errorf("key %v already exists in BgpPeers", newK)
	}

	e, ok := t.BgpPeers[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BgpPeers", oldK)
	}
	e.CriterionIndex = newK

	t.BgpPeers[newK] = e
	delete(t.BgpPeers, oldK)
	return nil
}

// GetOrCreateBgpPeers retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath) GetOrCreateBgpPeers(CriterionIndex NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers_CriterionIndex_Union) *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers {

	key := CriterionIndex

	if v, ok := t.BgpPeers[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBgpPeers(CriterionIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBgpPeers got unexpected error: %v", err))
	}
	return v
}

// GetBgpPeers retrieves the value with the specified key from
// the BgpPeers map field of NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath) GetBgpPeers(CriterionIndex NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers_CriterionIndex_Union) *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers {

	if t == nil {
		return nil
	}

	key := CriterionIndex

	if lm, ok := t.BgpPeers[key]; ok {
		return lm
	}
	return nil
}

// DeleteBgpPeers deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath) DeleteBgpPeers(CriterionIndex NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers_CriterionIndex_Union) {
	key := CriterionIndex

	delete(t.BgpPeers, key)
}

// AppendBgpPeers appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers struct to the
// list BgpPeers of NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath) AppendBgpPeers(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers) error {
	key := v.CriterionIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BgpPeers == nil {
		t.BgpPeers = make(map[NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers_CriterionIndex_Union]*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers)
	}

	if _, ok := t.BgpPeers[key]; ok {
		return fmt.Errorf("duplicate key for list BgpPeers %v", key)
	}

	t.BgpPeers[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.BgpPeers {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers represents the /nokia-conf/configure/groups/group/filter/match-list/ip-prefix-list/apply-path/bgp-peers YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers struct {
	CriterionIndex NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers_CriterionIndex_Union `path:"criterion-index" module:"nokia-conf"`
	Group          *string                                                                                                `path:"group" module:"nokia-conf"`
	Neighbor       *string                                                                                                `path:"neighbor" module:"nokia-conf"`
	RouterInstance *string                                                                                                `path:"router-instance" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers) IsYANGGoStruct() {
}

// GetCriterionIndex retrieves the value of the leaf CriterionIndex from the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CriterionIndex is set, it can
// safely use t.GetCriterionIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CriterionIndex == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers) GetCriterionIndex() NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers_CriterionIndex_Union {
	if t == nil || t.CriterionIndex == nil {
		return nil
	}
	return t.CriterionIndex
}

// GetGroup retrieves the value of the leaf Group from the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Group is set, it can
// safely use t.GetGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Group == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers) GetGroup() string {
	if t == nil || t.Group == nil {
		return ""
	}
	return *t.Group
}

// GetNeighbor retrieves the value of the leaf Neighbor from the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Neighbor is set, it can
// safely use t.GetNeighbor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Neighbor == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers) GetNeighbor() string {
	if t == nil || t.Neighbor == nil {
		return ""
	}
	return *t.Neighbor
}

// GetRouterInstance retrieves the value of the leaf RouterInstance from the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterInstance is set, it can
// safely use t.GetRouterInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterInstance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers) GetRouterInstance() string {
	if t == nil || t.RouterInstance == nil {
		return "Base"
	}
	return *t.RouterInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RouterInstance == nil {
		var v string = "Base"
		t.RouterInstance = &v
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"criterion-index": t.CriterionIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_ApplyPath_BgpPeers) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix represents the /nokia-conf/configure/groups/group/filter/match-list/ip-prefix-list/prefix YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix struct {
	IpPrefix *string `path:"ip-prefix" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix) IsYANGGoStruct() {}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_Prefix) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude represents the /nokia-conf/configure/groups/group/filter/match-list/ip-prefix-list/prefix-exclude YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude struct {
	IpPrefix *string `path:"ip-prefix" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude) IsYANGGoStruct() {
}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpPrefix == nil {
		return nil, fmt.Errorf("nil value for key IpPrefix")
	}

	return map[string]interface{}{
		"ip-prefix": *t.IpPrefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_IpPrefixList_PrefixExclude) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList represents the /nokia-conf/configure/groups/group/filter/match-list/ipv6-prefix-list YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList struct {
	ApplyPath      *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath                `path:"apply-path" module:"nokia-conf"`
	Description    *string                                                                                    `path:"description" module:"nokia-conf"`
	Prefix         map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix        `path:"prefix" module:"nokia-conf"`
	PrefixExclude  map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude `path:"prefix-exclude" module:"nokia-conf"`
	PrefixListName *string                                                                                    `path:"prefix-list-name" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) IsYANGGoStruct() {}

// NewPrefix creates a new entry in the Prefix list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) NewPrefix(Ipv6Prefix string) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix)
	}

	key := Ipv6Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Prefix[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Prefix", key)
	}

	t.Prefix[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix{
		Ipv6Prefix: &Ipv6Prefix,
	}

	return t.Prefix[key], nil
}

// RenamePrefix renames an entry in the list Prefix within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) RenamePrefix(oldK, newK string) error {
	if _, ok := t.Prefix[newK]; ok {
		return fmt.Errorf("key %v already exists in Prefix", newK)
	}

	e, ok := t.Prefix[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Prefix", oldK)
	}
	e.Ipv6Prefix = &newK

	t.Prefix[newK] = e
	delete(t.Prefix, oldK)
	return nil
}

// GetOrCreatePrefix retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) GetOrCreatePrefix(Ipv6Prefix string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix {

	key := Ipv6Prefix

	if v, ok := t.Prefix[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefix(Ipv6Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefix got unexpected error: %v", err))
	}
	return v
}

// GetPrefix retrieves the value with the specified key from
// the Prefix map field of NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) GetPrefix(Ipv6Prefix string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix {

	if t == nil {
		return nil
	}

	key := Ipv6Prefix

	if lm, ok := t.Prefix[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefix deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) DeletePrefix(Ipv6Prefix string) {
	key := Ipv6Prefix

	delete(t.Prefix, key)
}

// AppendPrefix appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix struct to the
// list Prefix of NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) AppendPrefix(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix) error {
	if v.Ipv6Prefix == nil {
		return fmt.Errorf("invalid nil key received for Ipv6Prefix")
	}

	key := *v.Ipv6Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Prefix == nil {
		t.Prefix = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix)
	}

	if _, ok := t.Prefix[key]; ok {
		return fmt.Errorf("duplicate key for list Prefix %v", key)
	}

	t.Prefix[key] = v
	return nil
}

// NewPrefixExclude creates a new entry in the PrefixExclude list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) NewPrefixExclude(Ipv6Prefix string) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixExclude == nil {
		t.PrefixExclude = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude)
	}

	key := Ipv6Prefix

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PrefixExclude[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PrefixExclude", key)
	}

	t.PrefixExclude[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude{
		Ipv6Prefix: &Ipv6Prefix,
	}

	return t.PrefixExclude[key], nil
}

// RenamePrefixExclude renames an entry in the list PrefixExclude within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) RenamePrefixExclude(oldK, newK string) error {
	if _, ok := t.PrefixExclude[newK]; ok {
		return fmt.Errorf("key %v already exists in PrefixExclude", newK)
	}

	e, ok := t.PrefixExclude[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PrefixExclude", oldK)
	}
	e.Ipv6Prefix = &newK

	t.PrefixExclude[newK] = e
	delete(t.PrefixExclude, oldK)
	return nil
}

// GetOrCreatePrefixExclude retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) GetOrCreatePrefixExclude(Ipv6Prefix string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude {

	key := Ipv6Prefix

	if v, ok := t.PrefixExclude[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPrefixExclude(Ipv6Prefix)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePrefixExclude got unexpected error: %v", err))
	}
	return v
}

// GetPrefixExclude retrieves the value with the specified key from
// the PrefixExclude map field of NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) GetPrefixExclude(Ipv6Prefix string) *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude {

	if t == nil {
		return nil
	}

	key := Ipv6Prefix

	if lm, ok := t.PrefixExclude[key]; ok {
		return lm
	}
	return nil
}

// DeletePrefixExclude deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) DeletePrefixExclude(Ipv6Prefix string) {
	key := Ipv6Prefix

	delete(t.PrefixExclude, key)
}

// AppendPrefixExclude appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude struct to the
// list PrefixExclude of NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) AppendPrefixExclude(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude) error {
	if v.Ipv6Prefix == nil {
		return fmt.Errorf("invalid nil key received for Ipv6Prefix")
	}

	key := *v.Ipv6Prefix

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PrefixExclude == nil {
		t.PrefixExclude = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude)
	}

	if _, ok := t.PrefixExclude[key]; ok {
		return fmt.Errorf("duplicate key for list PrefixExclude %v", key)
	}

	t.PrefixExclude[key] = v
	return nil
}

// GetOrCreateApplyPath retrieves the value of the ApplyPath field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) GetOrCreateApplyPath() *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath {
	if t.ApplyPath != nil {
		return t.ApplyPath
	}
	t.ApplyPath = &NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath{}
	return t.ApplyPath
}

// GetApplyPath returns the value of the ApplyPath struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList. If the receiver or the field ApplyPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) GetApplyPath() *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath {
	if t != nil && t.ApplyPath != nil {
		return t.ApplyPath
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetPrefixListName retrieves the value of the leaf PrefixListName from the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrefixListName is set, it can
// safely use t.GetPrefixListName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrefixListName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) GetPrefixListName() string {
	if t == nil || t.PrefixListName == nil {
		return ""
	}
	return *t.PrefixListName
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ApplyPath.PopulateDefaults()
	for _, e := range t.Prefix {
		e.PopulateDefaults()
	}
	for _, e := range t.PrefixExclude {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PrefixListName == nil {
		return nil, fmt.Errorf("nil value for key PrefixListName")
	}

	return map[string]interface{}{
		"prefix-list-name": *t.PrefixListName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath represents the /nokia-conf/configure/groups/group/filter/match-list/ipv6-prefix-list/apply-path YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath struct {
	BgpPeers map[NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers_CriterionIndex_Union]*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers `path:"bgp-peers" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath) IsYANGGoStruct() {}

// NewBgpPeers creates a new entry in the BgpPeers list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath) NewBgpPeers(CriterionIndex NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers_CriterionIndex_Union) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BgpPeers == nil {
		t.BgpPeers = make(map[NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers_CriterionIndex_Union]*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers)
	}

	key := CriterionIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.BgpPeers[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list BgpPeers", key)
	}

	t.BgpPeers[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers{
		CriterionIndex: CriterionIndex,
	}

	return t.BgpPeers[key], nil
}

// RenameBgpPeers renames an entry in the list BgpPeers within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath) RenameBgpPeers(oldK, newK NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers_CriterionIndex_Union) error {
	if _, ok := t.BgpPeers[newK]; ok {
		return fmt.Errorf("key %v already exists in BgpPeers", newK)
	}

	e, ok := t.BgpPeers[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in BgpPeers", oldK)
	}
	e.CriterionIndex = newK

	t.BgpPeers[newK] = e
	delete(t.BgpPeers, oldK)
	return nil
}

// GetOrCreateBgpPeers retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath) GetOrCreateBgpPeers(CriterionIndex NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers_CriterionIndex_Union) *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers {

	key := CriterionIndex

	if v, ok := t.BgpPeers[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBgpPeers(CriterionIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBgpPeers got unexpected error: %v", err))
	}
	return v
}

// GetBgpPeers retrieves the value with the specified key from
// the BgpPeers map field of NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath) GetBgpPeers(CriterionIndex NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers_CriterionIndex_Union) *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers {

	if t == nil {
		return nil
	}

	key := CriterionIndex

	if lm, ok := t.BgpPeers[key]; ok {
		return lm
	}
	return nil
}

// DeleteBgpPeers deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath) DeleteBgpPeers(CriterionIndex NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers_CriterionIndex_Union) {
	key := CriterionIndex

	delete(t.BgpPeers, key)
}

// AppendBgpPeers appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers struct to the
// list BgpPeers of NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath) AppendBgpPeers(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers) error {
	key := v.CriterionIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.BgpPeers == nil {
		t.BgpPeers = make(map[NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers_CriterionIndex_Union]*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers)
	}

	if _, ok := t.BgpPeers[key]; ok {
		return fmt.Errorf("duplicate key for list BgpPeers %v", key)
	}

	t.BgpPeers[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.BgpPeers {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers represents the /nokia-conf/configure/groups/group/filter/match-list/ipv6-prefix-list/apply-path/bgp-peers YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers struct {
	CriterionIndex NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers_CriterionIndex_Union `path:"criterion-index" module:"nokia-conf"`
	Group          *string                                                                                                  `path:"group" module:"nokia-conf"`
	Neighbor       *string                                                                                                  `path:"neighbor" module:"nokia-conf"`
	RouterInstance *string                                                                                                  `path:"router-instance" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers) IsYANGGoStruct() {
}

// GetCriterionIndex retrieves the value of the leaf CriterionIndex from the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CriterionIndex is set, it can
// safely use t.GetCriterionIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CriterionIndex == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers) GetCriterionIndex() NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers_CriterionIndex_Union {
	if t == nil || t.CriterionIndex == nil {
		return nil
	}
	return t.CriterionIndex
}

// GetGroup retrieves the value of the leaf Group from the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Group is set, it can
// safely use t.GetGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Group == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers) GetGroup() string {
	if t == nil || t.Group == nil {
		return ""
	}
	return *t.Group
}

// GetNeighbor retrieves the value of the leaf Neighbor from the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Neighbor is set, it can
// safely use t.GetNeighbor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Neighbor == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers) GetNeighbor() string {
	if t == nil || t.Neighbor == nil {
		return ""
	}
	return *t.Neighbor
}

// GetRouterInstance retrieves the value of the leaf RouterInstance from the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterInstance is set, it can
// safely use t.GetRouterInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterInstance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers) GetRouterInstance() string {
	if t == nil || t.RouterInstance == nil {
		return "Base"
	}
	return *t.RouterInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RouterInstance == nil {
		var v string = "Base"
		t.RouterInstance = &v
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"criterion-index": t.CriterionIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_ApplyPath_BgpPeers) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix represents the /nokia-conf/configure/groups/group/filter/match-list/ipv6-prefix-list/prefix YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix struct {
	Ipv6Prefix *string `path:"ipv6-prefix" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix) IsYANGGoStruct() {}

// GetIpv6Prefix retrieves the value of the leaf Ipv6Prefix from the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Prefix is set, it can
// safely use t.GetIpv6Prefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Prefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix) GetIpv6Prefix() string {
	if t == nil || t.Ipv6Prefix == nil {
		return ""
	}
	return *t.Ipv6Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv6Prefix == nil {
		return nil, fmt.Errorf("nil value for key Ipv6Prefix")
	}

	return map[string]interface{}{
		"ipv6-prefix": *t.Ipv6Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_Prefix) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude represents the /nokia-conf/configure/groups/group/filter/match-list/ipv6-prefix-list/prefix-exclude YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude struct {
	Ipv6Prefix *string `path:"ipv6-prefix" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude) IsYANGGoStruct() {
}

// GetIpv6Prefix retrieves the value of the leaf Ipv6Prefix from the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Prefix is set, it can
// safely use t.GetIpv6Prefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Prefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude) GetIpv6Prefix() string {
	if t == nil || t.Ipv6Prefix == nil {
		return ""
	}
	return *t.Ipv6Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv6Prefix == nil {
		return nil, fmt.Errorf("nil value for key Ipv6Prefix")
	}

	return map[string]interface{}{
		"ipv6-prefix": *t.Ipv6Prefix,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_Ipv6PrefixList_PrefixExclude) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList represents the /nokia-conf/configure/groups/group/filter/match-list/port-list YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList struct {
	Description  *string                                                                                                                                          `path:"description" module:"nokia-conf"`
	Port         map[NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port_Value_Union]*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port `path:"port" module:"nokia-conf"`
	PortListName *string                                                                                                                                          `path:"port-list-name" module:"nokia-conf"`
	Range        map[NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Key]*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range       `path:"range" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) IsYANGGoStruct() {}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Key represents the key for list Range of element /nokia-conf/configure/groups/group/filter/match-list/port-list.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Key struct {
	Start NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Start_Union `path:"start"`
	End   NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_End_Union   `path:"end"`
}

// NewPort creates a new entry in the Port list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) NewPort(Value NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port_Value_Union) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Port == nil {
		t.Port = make(map[NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port_Value_Union]*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port)
	}

	key := Value

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Port[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Port", key)
	}

	t.Port[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port{
		Value: Value,
	}

	return t.Port[key], nil
}

// RenamePort renames an entry in the list Port within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) RenamePort(oldK, newK NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port_Value_Union) error {
	if _, ok := t.Port[newK]; ok {
		return fmt.Errorf("key %v already exists in Port", newK)
	}

	e, ok := t.Port[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Port", oldK)
	}
	e.Value = newK

	t.Port[newK] = e
	delete(t.Port, oldK)
	return nil
}

// GetOrCreatePort retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) GetOrCreatePort(Value NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port_Value_Union) *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port {

	key := Value

	if v, ok := t.Port[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPort(Value)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePort got unexpected error: %v", err))
	}
	return v
}

// GetPort retrieves the value with the specified key from
// the Port map field of NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) GetPort(Value NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port_Value_Union) *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port {

	if t == nil {
		return nil
	}

	key := Value

	if lm, ok := t.Port[key]; ok {
		return lm
	}
	return nil
}

// DeletePort deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) DeletePort(Value NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port_Value_Union) {
	key := Value

	delete(t.Port, key)
}

// AppendPort appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port struct to the
// list Port of NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) AppendPort(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port) error {
	key := v.Value

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Port == nil {
		t.Port = make(map[NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port_Value_Union]*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port)
	}

	if _, ok := t.Port[key]; ok {
		return fmt.Errorf("duplicate key for list Port %v", key)
	}

	t.Port[key] = v
	return nil
}

// NewRange creates a new entry in the Range list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) NewRange(Start NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Start_Union, End NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_End_Union) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Range == nil {
		t.Range = make(map[NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Key]*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range)
	}

	key := NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Key{
		Start: Start,
		End:   End,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Range[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Range", key)
	}

	t.Range[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range{
		Start: Start,
		End:   End,
	}

	return t.Range[key], nil
}

// RenameRange renames an entry in the list Range within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) RenameRange(oldK, newK NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Key) error {
	if _, ok := t.Range[newK]; ok {
		return fmt.Errorf("key %v already exists in Range", newK)
	}

	e, ok := t.Range[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Range", oldK)
	}
	e.Start = newK.Start
	e.End = newK.End

	t.Range[newK] = e
	delete(t.Range, oldK)
	return nil
}

// GetOrCreateRange retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) GetOrCreateRange(Start NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Start_Union, End NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_End_Union) *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range {

	key := NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Key{
		Start: Start,
		End:   End,
	}

	if v, ok := t.Range[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRange(Start, End)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRange got unexpected error: %v", err))
	}
	return v
}

// GetRange retrieves the value with the specified key from
// the Range map field of NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) GetRange(Start NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Start_Union, End NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_End_Union) *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range {

	if t == nil {
		return nil
	}

	key := NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Key{
		Start: Start,
		End:   End,
	}

	if lm, ok := t.Range[key]; ok {
		return lm
	}
	return nil
}

// DeleteRange deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) DeleteRange(Start NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Start_Union, End NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_End_Union) {
	key := NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Key{
		Start: Start,
		End:   End,
	}

	delete(t.Range, key)
}

// AppendRange appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range struct to the
// list Range of NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) AppendRange(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range) error {
	key := NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Key{
		Start: v.Start,
		End:   v.End,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Range == nil {
		t.Range = make(map[NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Key]*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range)
	}

	if _, ok := t.Range[key]; ok {
		return fmt.Errorf("duplicate key for list Range %v", key)
	}

	t.Range[key] = v
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetPortListName retrieves the value of the leaf PortListName from the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortListName is set, it can
// safely use t.GetPortListName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortListName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) GetPortListName() string {
	if t == nil || t.PortListName == nil {
		return ""
	}
	return *t.PortListName
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Port {
		e.PopulateDefaults()
	}
	for _, e := range t.Range {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PortListName == nil {
		return nil, fmt.Errorf("nil value for key PortListName")
	}

	return map[string]interface{}{
		"port-list-name": *t.PortListName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port represents the /nokia-conf/configure/groups/group/filter/match-list/port-list/port YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port struct {
	Value NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port_Value_Union `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port) IsYANGGoStruct() {}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port) GetValue() NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port_Value_Union {
	if t == nil || t.Value == nil {
		return nil
	}
	return t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"value": t.Value,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Port) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range represents the /nokia-conf/configure/groups/group/filter/match-list/port-list/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range struct {
	End   NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_End_Union   `path:"end" module:"nokia-conf"`
	Start NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Start_Union `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range) GetEnd() NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_End_Union {
	if t == nil || t.End == nil {
		return nil
	}
	return t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range) GetStart() NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range_Start_Union {
	if t == nil || t.Start == nil {
		return nil
	}
	return t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"end":   t.End,
		"start": t.Start,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_PortList_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList represents the /nokia-conf/configure/groups/group/filter/match-list/protocol-list YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList struct {
	Description      *string                                                                                                                                                               `path:"description" module:"nokia-conf"`
	Protocol         map[NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol_ProtocolId_Union]*NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol `path:"protocol" module:"nokia-conf"`
	ProtocolListName *string                                                                                                                                                               `path:"protocol-list-name" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) IsYANGGoStruct() {}

// NewProtocol creates a new entry in the Protocol list of the
// NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) NewProtocol(ProtocolId NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol_ProtocolId_Union) (*NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol_ProtocolId_Union]*NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol)
	}

	key := ProtocolId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Protocol[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Protocol", key)
	}

	t.Protocol[key] = &NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol{
		ProtocolId: ProtocolId,
	}

	return t.Protocol[key], nil
}

// RenameProtocol renames an entry in the list Protocol within
// the NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) RenameProtocol(oldK, newK NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol_ProtocolId_Union) error {
	if _, ok := t.Protocol[newK]; ok {
		return fmt.Errorf("key %v already exists in Protocol", newK)
	}

	e, ok := t.Protocol[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Protocol", oldK)
	}
	e.ProtocolId = newK

	t.Protocol[newK] = e
	delete(t.Protocol, oldK)
	return nil
}

// GetOrCreateProtocol retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) GetOrCreateProtocol(ProtocolId NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol_ProtocolId_Union) *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol {

	key := ProtocolId

	if v, ok := t.Protocol[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewProtocol(ProtocolId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateProtocol got unexpected error: %v", err))
	}
	return v
}

// GetProtocol retrieves the value with the specified key from
// the Protocol map field of NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) GetProtocol(ProtocolId NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol_ProtocolId_Union) *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol {

	if t == nil {
		return nil
	}

	key := ProtocolId

	if lm, ok := t.Protocol[key]; ok {
		return lm
	}
	return nil
}

// DeleteProtocol deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) DeleteProtocol(ProtocolId NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol_ProtocolId_Union) {
	key := ProtocolId

	delete(t.Protocol, key)
}

// AppendProtocol appends the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol struct to the
// list Protocol of NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) AppendProtocol(v *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol) error {
	key := v.ProtocolId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Protocol == nil {
		t.Protocol = make(map[NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol_ProtocolId_Union]*NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol)
	}

	if _, ok := t.Protocol[key]; ok {
		return fmt.Errorf("duplicate key for list Protocol %v", key)
	}

	t.Protocol[key] = v
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetProtocolListName retrieves the value of the leaf ProtocolListName from the NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtocolListName is set, it can
// safely use t.GetProtocolListName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtocolListName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) GetProtocolListName() string {
	if t == nil || t.ProtocolListName == nil {
		return ""
	}
	return *t.ProtocolListName
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Protocol {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.ProtocolListName == nil {
		return nil, fmt.Errorf("nil value for key ProtocolListName")
	}

	return map[string]interface{}{
		"protocol-list-name": *t.ProtocolListName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol represents the /nokia-conf/configure/groups/group/filter/match-list/protocol-list/protocol YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol struct {
	ProtocolId NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol_ProtocolId_Union `path:"protocol-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol) IsYANGGoStruct() {}

// GetProtocolId retrieves the value of the leaf ProtocolId from the NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtocolId is set, it can
// safely use t.GetProtocolId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtocolId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol) GetProtocolId() NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol_ProtocolId_Union {
	if t == nil || t.ProtocolId == nil {
		return nil
	}
	return t.ProtocolId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"protocol-id": t.ProtocolId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol.
func (*NokiaConf_Configure_Groups_Group_Filter_MatchList_ProtocolList_Protocol) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MdAutoId represents the /nokia-conf/configure/groups/group/filter/md-auto-id YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MdAutoId struct {
	FilterIdRange *NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange `path:"filter-id-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MdAutoId implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MdAutoId) IsYANGGoStruct() {}

// GetOrCreateFilterIdRange retrieves the value of the FilterIdRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_MdAutoId) GetOrCreateFilterIdRange() *NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange {
	if t.FilterIdRange != nil {
		return t.FilterIdRange
	}
	t.FilterIdRange = &NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange{}
	return t.FilterIdRange
}

// GetFilterIdRange returns the value of the FilterIdRange struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_MdAutoId. If the receiver or the field FilterIdRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_MdAutoId) GetFilterIdRange() *NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange {
	if t != nil && t.FilterIdRange != nil {
		return t.FilterIdRange
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MdAutoId
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MdAutoId) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.FilterIdRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MdAutoId) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MdAutoId"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MdAutoId) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MdAutoId) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MdAutoId.
func (*NokiaConf_Configure_Groups_Group_Filter_MdAutoId) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange represents the /nokia-conf/configure/groups/group/filter/md-auto-id/filter-id-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange struct {
	End   *uint32 `path:"end" module:"nokia-conf"`
	Start *uint32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange) GetEnd() uint32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange) GetStart() uint32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange.
func (*NokiaConf_Configure_Groups_Group_Filter_MdAutoId_FilterIdRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy represents the /nokia-conf/configure/groups/group/filter/redirect-policy YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy struct {
	AdminState         E_NokiaTypesSros_AdminState                                                    `path:"admin-state" module:"nokia-conf"`
	Description        *string                                                                        `path:"description" module:"nokia-conf"`
	Destination        map[string]*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination `path:"destination" module:"nokia-conf"`
	NotifyDestChange   *bool                                                                          `path:"notify-dest-change" module:"nokia-conf"`
	RedirectPolicyName *string                                                                        `path:"redirect-policy-name" module:"nokia-conf"`
	RouterInstance     *string                                                                        `path:"router-instance" module:"nokia-conf"`
	StickyDest         NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_StickyDest_Union        `path:"sticky-dest" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) IsYANGGoStruct() {}

// NewDestination creates a new entry in the Destination list of the
// NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) NewDestination(DestinationAddress string) (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Destination == nil {
		t.Destination = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination)
	}

	key := DestinationAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Destination[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Destination", key)
	}

	t.Destination[key] = &NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination{
		DestinationAddress: &DestinationAddress,
	}

	return t.Destination[key], nil
}

// RenameDestination renames an entry in the list Destination within
// the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) RenameDestination(oldK, newK string) error {
	if _, ok := t.Destination[newK]; ok {
		return fmt.Errorf("key %v already exists in Destination", newK)
	}

	e, ok := t.Destination[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Destination", oldK)
	}
	e.DestinationAddress = &newK

	t.Destination[newK] = e
	delete(t.Destination, oldK)
	return nil
}

// GetOrCreateDestination retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) GetOrCreateDestination(DestinationAddress string) *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination {

	key := DestinationAddress

	if v, ok := t.Destination[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDestination(DestinationAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDestination got unexpected error: %v", err))
	}
	return v
}

// GetDestination retrieves the value with the specified key from
// the Destination map field of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) GetDestination(DestinationAddress string) *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination {

	if t == nil {
		return nil
	}

	key := DestinationAddress

	if lm, ok := t.Destination[key]; ok {
		return lm
	}
	return nil
}

// DeleteDestination deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) DeleteDestination(DestinationAddress string) {
	key := DestinationAddress

	delete(t.Destination, key)
}

// AppendDestination appends the supplied NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination struct to the
// list Destination of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) AppendDestination(v *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) error {
	if v.DestinationAddress == nil {
		return fmt.Errorf("invalid nil key received for DestinationAddress")
	}

	key := *v.DestinationAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Destination == nil {
		t.Destination = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination)
	}

	if _, ok := t.Destination[key]; ok {
		return fmt.Errorf("duplicate key for list Destination %v", key)
	}

	t.Destination[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetNotifyDestChange retrieves the value of the leaf NotifyDestChange from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NotifyDestChange is set, it can
// safely use t.GetNotifyDestChange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NotifyDestChange == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) GetNotifyDestChange() bool {
	if t == nil || t.NotifyDestChange == nil {
		return false
	}
	return *t.NotifyDestChange
}

// GetRedirectPolicyName retrieves the value of the leaf RedirectPolicyName from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RedirectPolicyName is set, it can
// safely use t.GetRedirectPolicyName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RedirectPolicyName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) GetRedirectPolicyName() string {
	if t == nil || t.RedirectPolicyName == nil {
		return ""
	}
	return *t.RedirectPolicyName
}

// GetRouterInstance retrieves the value of the leaf RouterInstance from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterInstance is set, it can
// safely use t.GetRouterInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterInstance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) GetRouterInstance() string {
	if t == nil || t.RouterInstance == nil {
		return ""
	}
	return *t.RouterInstance
}

// GetStickyDest retrieves the value of the leaf StickyDest from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StickyDest is set, it can
// safely use t.GetStickyDest() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StickyDest == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) GetStickyDest() NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_StickyDest_Union {
	if t == nil || t.StickyDest == nil {
		return nil
	}
	return t.StickyDest
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.NotifyDestChange == nil {
		var v bool = false
		t.NotifyDestChange = &v
	}
	for _, e := range t.Destination {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.RedirectPolicyName == nil {
		return nil, fmt.Errorf("nil value for key RedirectPolicyName")
	}

	return map[string]interface{}{
		"redirect-policy-name": *t.RedirectPolicyName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding represents the /nokia-conf/configure/groups/group/filter/redirect-policy-binding YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding struct {
	BindingName     *string                                                                                  `path:"binding-name" module:"nokia-conf"`
	BindingOperator E_NokiaTypesFilter_FilterBindingOperator                                                 `path:"binding-operator" module:"nokia-conf"`
	RedirectPolicy  map[string]*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy `path:"redirect-policy" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) IsYANGGoStruct() {}

// NewRedirectPolicy creates a new entry in the RedirectPolicy list of the
// NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) NewRedirectPolicy(RedirectPolicyName string) (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RedirectPolicy == nil {
		t.RedirectPolicy = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy)
	}

	key := RedirectPolicyName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RedirectPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RedirectPolicy", key)
	}

	t.RedirectPolicy[key] = &NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy{
		RedirectPolicyName: &RedirectPolicyName,
	}

	return t.RedirectPolicy[key], nil
}

// RenameRedirectPolicy renames an entry in the list RedirectPolicy within
// the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) RenameRedirectPolicy(oldK, newK string) error {
	if _, ok := t.RedirectPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in RedirectPolicy", newK)
	}

	e, ok := t.RedirectPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RedirectPolicy", oldK)
	}
	e.RedirectPolicyName = &newK

	t.RedirectPolicy[newK] = e
	delete(t.RedirectPolicy, oldK)
	return nil
}

// GetOrCreateRedirectPolicy retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) GetOrCreateRedirectPolicy(RedirectPolicyName string) *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy {

	key := RedirectPolicyName

	if v, ok := t.RedirectPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRedirectPolicy(RedirectPolicyName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRedirectPolicy got unexpected error: %v", err))
	}
	return v
}

// GetRedirectPolicy retrieves the value with the specified key from
// the RedirectPolicy map field of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) GetRedirectPolicy(RedirectPolicyName string) *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy {

	if t == nil {
		return nil
	}

	key := RedirectPolicyName

	if lm, ok := t.RedirectPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteRedirectPolicy deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) DeleteRedirectPolicy(RedirectPolicyName string) {
	key := RedirectPolicyName

	delete(t.RedirectPolicy, key)
}

// AppendRedirectPolicy appends the supplied NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy struct to the
// list RedirectPolicy of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) AppendRedirectPolicy(v *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) error {
	if v.RedirectPolicyName == nil {
		return fmt.Errorf("invalid nil key received for RedirectPolicyName")
	}

	key := *v.RedirectPolicyName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RedirectPolicy == nil {
		t.RedirectPolicy = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy)
	}

	if _, ok := t.RedirectPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list RedirectPolicy %v", key)
	}

	t.RedirectPolicy[key] = v
	return nil
}

// GetBindingName retrieves the value of the leaf BindingName from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BindingName is set, it can
// safely use t.GetBindingName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BindingName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) GetBindingName() string {
	if t == nil || t.BindingName == nil {
		return ""
	}
	return *t.BindingName
}

// GetBindingOperator retrieves the value of the leaf BindingOperator from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BindingOperator is set, it can
// safely use t.GetBindingOperator() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BindingOperator == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) GetBindingOperator() E_NokiaTypesFilter_FilterBindingOperator {
	if t == nil || t.BindingOperator == 0 {
		return NokiaTypesFilter_FilterBindingOperator_and
	}
	return t.BindingOperator
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.BindingOperator == 0 {
		t.BindingOperator = NokiaTypesFilter_FilterBindingOperator_and
	}
	for _, e := range t.RedirectPolicy {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) ΛListKeyMap() (map[string]interface{}, error) {
	if t.BindingName == nil {
		return nil, fmt.Errorf("nil value for key BindingName")
	}

	return map[string]interface{}{
		"binding-name": *t.BindingName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy represents the /nokia-conf/configure/groups/group/filter/redirect-policy-binding/redirect-policy YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy struct {
	Destination        map[string]*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination `path:"destination" module:"nokia-conf"`
	RedirectPolicyName *string                                                                                              `path:"redirect-policy-name" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) IsYANGGoStruct() {
}

// NewDestination creates a new entry in the Destination list of the
// NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) NewDestination(DestinationAddress string) (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Destination == nil {
		t.Destination = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination)
	}

	key := DestinationAddress

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Destination[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Destination", key)
	}

	t.Destination[key] = &NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination{
		DestinationAddress: &DestinationAddress,
	}

	return t.Destination[key], nil
}

// RenameDestination renames an entry in the list Destination within
// the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) RenameDestination(oldK, newK string) error {
	if _, ok := t.Destination[newK]; ok {
		return fmt.Errorf("key %v already exists in Destination", newK)
	}

	e, ok := t.Destination[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Destination", oldK)
	}
	e.DestinationAddress = &newK

	t.Destination[newK] = e
	delete(t.Destination, oldK)
	return nil
}

// GetOrCreateDestination retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) GetOrCreateDestination(DestinationAddress string) *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination {

	key := DestinationAddress

	if v, ok := t.Destination[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDestination(DestinationAddress)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDestination got unexpected error: %v", err))
	}
	return v
}

// GetDestination retrieves the value with the specified key from
// the Destination map field of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) GetDestination(DestinationAddress string) *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination {

	if t == nil {
		return nil
	}

	key := DestinationAddress

	if lm, ok := t.Destination[key]; ok {
		return lm
	}
	return nil
}

// DeleteDestination deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) DeleteDestination(DestinationAddress string) {
	key := DestinationAddress

	delete(t.Destination, key)
}

// AppendDestination appends the supplied NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination struct to the
// list Destination of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) AppendDestination(v *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination) error {
	if v.DestinationAddress == nil {
		return fmt.Errorf("invalid nil key received for DestinationAddress")
	}

	key := *v.DestinationAddress

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Destination == nil {
		t.Destination = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination)
	}

	if _, ok := t.Destination[key]; ok {
		return fmt.Errorf("duplicate key for list Destination %v", key)
	}

	t.Destination[key] = v
	return nil
}

// GetRedirectPolicyName retrieves the value of the leaf RedirectPolicyName from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RedirectPolicyName is set, it can
// safely use t.GetRedirectPolicyName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RedirectPolicyName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) GetRedirectPolicyName() string {
	if t == nil || t.RedirectPolicyName == nil {
		return ""
	}
	return *t.RedirectPolicyName
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Destination {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.RedirectPolicyName == nil {
		return nil, fmt.Errorf("nil value for key RedirectPolicyName")
	}

	return map[string]interface{}{
		"redirect-policy-name": *t.RedirectPolicyName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination represents the /nokia-conf/configure/groups/group/filter/redirect-policy-binding/redirect-policy/destination YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination struct {
	DestinationAddress *string `path:"destination-address" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination) IsYANGGoStruct() {
}

// GetDestinationAddress retrieves the value of the leaf DestinationAddress from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationAddress is set, it can
// safely use t.GetDestinationAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationAddress == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination) GetDestinationAddress() string {
	if t == nil || t.DestinationAddress == nil {
		return ""
	}
	return *t.DestinationAddress
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination) ΛListKeyMap() (map[string]interface{}, error) {
	if t.DestinationAddress == nil {
		return nil, fmt.Errorf("nil value for key DestinationAddress")
	}

	return map[string]interface{}{
		"destination-address": *t.DestinationAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicyBinding_RedirectPolicy_Destination) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination represents the /nokia-conf/configure/groups/group/filter/redirect-policy/destination YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination struct {
	AdminState         E_NokiaTypesSros_AdminState                                                       `path:"admin-state" module:"nokia-conf"`
	Description        *string                                                                           `path:"description" module:"nokia-conf"`
	DestinationAddress *string                                                                           `path:"destination-address" module:"nokia-conf"`
	PingTest           *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest      `path:"ping-test" module:"nokia-conf" yangPresence:"true"`
	Priority           *uint32                                                                           `path:"priority" module:"nokia-conf"`
	UnicastRtTest      *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest `path:"unicast-rt-test" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) IsYANGGoStruct() {}

// GetOrCreatePingTest retrieves the value of the PingTest field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) GetOrCreatePingTest() *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest {
	if t.PingTest != nil {
		return t.PingTest
	}
	t.PingTest = &NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest{}
	return t.PingTest
}

// GetOrCreateUnicastRtTest retrieves the value of the UnicastRtTest field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) GetOrCreateUnicastRtTest() *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest {
	if t.UnicastRtTest != nil {
		return t.UnicastRtTest
	}
	t.UnicastRtTest = &NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest{}
	return t.UnicastRtTest
}

// GetPingTest returns the value of the PingTest struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination. If the receiver or the field PingTest is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) GetPingTest() *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest {
	if t != nil && t.PingTest != nil {
		return t.PingTest
	}
	return nil
}

// GetUnicastRtTest returns the value of the UnicastRtTest struct pointer
// from NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination. If the receiver or the field UnicastRtTest is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) GetUnicastRtTest() *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest {
	if t != nil && t.UnicastRtTest != nil {
		return t.UnicastRtTest
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetDestinationAddress retrieves the value of the leaf DestinationAddress from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DestinationAddress is set, it can
// safely use t.GetDestinationAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DestinationAddress == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) GetDestinationAddress() string {
	if t == nil || t.DestinationAddress == nil {
		return ""
	}
	return *t.DestinationAddress
}

// GetPriority retrieves the value of the leaf Priority from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) GetPriority() uint32 {
	if t == nil || t.Priority == nil {
		return 100
	}
	return *t.Priority
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.Priority == nil {
		var v uint32 = 100
		t.Priority = &v
	}
	t.PingTest.PopulateDefaults()
	t.UnicastRtTest.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) ΛListKeyMap() (map[string]interface{}, error) {
	if t.DestinationAddress == nil {
		return nil, fmt.Errorf("nil value for key DestinationAddress")
	}

	return map[string]interface{}{
		"destination-address": *t.DestinationAddress,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest represents the /nokia-conf/configure/groups/group/filter/redirect-policy/destination/ping-test YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest struct {
	DropCount     *uint32 `path:"drop-count" module:"nokia-conf"`
	HoldDown      *uint32 `path:"hold-down" module:"nokia-conf"`
	Interval      *uint32 `path:"interval" module:"nokia-conf"`
	SourceAddress *string `path:"source-address" module:"nokia-conf"`
	Timeout       *uint32 `path:"timeout" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest) IsYANGGoStruct() {
}

// GetDropCount retrieves the value of the leaf DropCount from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DropCount is set, it can
// safely use t.GetDropCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DropCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest) GetDropCount() uint32 {
	if t == nil || t.DropCount == nil {
		return 3
	}
	return *t.DropCount
}

// GetHoldDown retrieves the value of the leaf HoldDown from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldDown is set, it can
// safely use t.GetHoldDown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldDown == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest) GetHoldDown() uint32 {
	if t == nil || t.HoldDown == nil {
		return 0
	}
	return *t.HoldDown
}

// GetInterval retrieves the value of the leaf Interval from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 1
	}
	return *t.Interval
}

// GetSourceAddress retrieves the value of the leaf SourceAddress from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SourceAddress is set, it can
// safely use t.GetSourceAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SourceAddress == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest) GetSourceAddress() string {
	if t == nil || t.SourceAddress == nil {
		return ""
	}
	return *t.SourceAddress
}

// GetTimeout retrieves the value of the leaf Timeout from the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Timeout is set, it can
// safely use t.GetTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Timeout == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest) GetTimeout() uint32 {
	if t == nil || t.Timeout == nil {
		return 1
	}
	return *t.Timeout
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DropCount == nil {
		var v uint32 = 3
		t.DropCount = &v
	}
	if t.HoldDown == nil {
		var v uint32 = 0
		t.HoldDown = &v
	}
	if t.Interval == nil {
		var v uint32 = 1
		t.Interval = &v
	}
	if t.Timeout == nil {
		var v uint32 = 1
		t.Timeout = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_PingTest) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest represents the /nokia-conf/configure/groups/group/filter/redirect-policy/destination/unicast-rt-test YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest struct {
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest) IsYANGGoStruct() {
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest.
func (*NokiaConf_Configure_Groups_Group_Filter_RedirectPolicy_Destination_UnicastRtTest) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_SystemFilter represents the /nokia-conf/configure/groups/group/filter/system-filter YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_SystemFilter struct {
	Ip   map[string]*NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip   `path:"ip" module:"nokia-conf"`
	Ipv6 map[string]*NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6 `path:"ipv6" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_SystemFilter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_SystemFilter) IsYANGGoStruct() {}

// NewIp creates a new entry in the Ip list of the
// NokiaConf_Configure_Groups_Group_Filter_SystemFilter struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) NewIp(IpFilter string) (*NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ip == nil {
		t.Ip = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip)
	}

	key := IpFilter

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ip[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ip", key)
	}

	t.Ip[key] = &NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip{
		IpFilter: &IpFilter,
	}

	return t.Ip[key], nil
}

// RenameIp renames an entry in the list Ip within
// the NokiaConf_Configure_Groups_Group_Filter_SystemFilter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) RenameIp(oldK, newK string) error {
	if _, ok := t.Ip[newK]; ok {
		return fmt.Errorf("key %v already exists in Ip", newK)
	}

	e, ok := t.Ip[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ip", oldK)
	}
	e.IpFilter = &newK

	t.Ip[newK] = e
	delete(t.Ip, oldK)
	return nil
}

// GetOrCreateIp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_SystemFilter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) GetOrCreateIp(IpFilter string) *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip {

	key := IpFilter

	if v, ok := t.Ip[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIp(IpFilter)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIp got unexpected error: %v", err))
	}
	return v
}

// GetIp retrieves the value with the specified key from
// the Ip map field of NokiaConf_Configure_Groups_Group_Filter_SystemFilter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) GetIp(IpFilter string) *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip {

	if t == nil {
		return nil
	}

	key := IpFilter

	if lm, ok := t.Ip[key]; ok {
		return lm
	}
	return nil
}

// DeleteIp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_SystemFilter. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) DeleteIp(IpFilter string) {
	key := IpFilter

	delete(t.Ip, key)
}

// AppendIp appends the supplied NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip struct to the
// list Ip of NokiaConf_Configure_Groups_Group_Filter_SystemFilter. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) AppendIp(v *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip) error {
	if v.IpFilter == nil {
		return fmt.Errorf("invalid nil key received for IpFilter")
	}

	key := *v.IpFilter

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ip == nil {
		t.Ip = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip)
	}

	if _, ok := t.Ip[key]; ok {
		return fmt.Errorf("duplicate key for list Ip %v", key)
	}

	t.Ip[key] = v
	return nil
}

// NewIpv6 creates a new entry in the Ipv6 list of the
// NokiaConf_Configure_Groups_Group_Filter_SystemFilter struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) NewIpv6(Ipv6Filter string) (*NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6 == nil {
		t.Ipv6 = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6)
	}

	key := Ipv6Filter

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipv6[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipv6", key)
	}

	t.Ipv6[key] = &NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6{
		Ipv6Filter: &Ipv6Filter,
	}

	return t.Ipv6[key], nil
}

// RenameIpv6 renames an entry in the list Ipv6 within
// the NokiaConf_Configure_Groups_Group_Filter_SystemFilter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) RenameIpv6(oldK, newK string) error {
	if _, ok := t.Ipv6[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipv6", newK)
	}

	e, ok := t.Ipv6[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipv6", oldK)
	}
	e.Ipv6Filter = &newK

	t.Ipv6[newK] = e
	delete(t.Ipv6, oldK)
	return nil
}

// GetOrCreateIpv6 retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_SystemFilter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) GetOrCreateIpv6(Ipv6Filter string) *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6 {

	key := Ipv6Filter

	if v, ok := t.Ipv6[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpv6(Ipv6Filter)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpv6 got unexpected error: %v", err))
	}
	return v
}

// GetIpv6 retrieves the value with the specified key from
// the Ipv6 map field of NokiaConf_Configure_Groups_Group_Filter_SystemFilter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) GetIpv6(Ipv6Filter string) *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6 {

	if t == nil {
		return nil
	}

	key := Ipv6Filter

	if lm, ok := t.Ipv6[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpv6 deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Filter_SystemFilter. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) DeleteIpv6(Ipv6Filter string) {
	key := Ipv6Filter

	delete(t.Ipv6, key)
}

// AppendIpv6 appends the supplied NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6 struct to the
// list Ipv6 of NokiaConf_Configure_Groups_Group_Filter_SystemFilter. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6 already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) AppendIpv6(v *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6) error {
	if v.Ipv6Filter == nil {
		return fmt.Errorf("invalid nil key received for Ipv6Filter")
	}

	key := *v.Ipv6Filter

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipv6 == nil {
		t.Ipv6 = make(map[string]*NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6)
	}

	if _, ok := t.Ipv6[key]; ok {
		return fmt.Errorf("duplicate key for list Ipv6 %v", key)
	}

	t.Ipv6[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_SystemFilter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Ip {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipv6 {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_SystemFilter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_SystemFilter.
func (*NokiaConf_Configure_Groups_Group_Filter_SystemFilter) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip represents the /nokia-conf/configure/groups/group/filter/system-filter/ip YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip struct {
	IpFilter *string `path:"ip-filter" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip) IsYANGGoStruct() {}

// GetIpFilter retrieves the value of the leaf IpFilter from the NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpFilter is set, it can
// safely use t.GetIpFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpFilter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip) GetIpFilter() string {
	if t == nil || t.IpFilter == nil {
		return ""
	}
	return *t.IpFilter
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IpFilter == nil {
		return nil, fmt.Errorf("nil value for key IpFilter")
	}

	return map[string]interface{}{
		"ip-filter": *t.IpFilter,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip.
func (*NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ip) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6 represents the /nokia-conf/configure/groups/group/filter/system-filter/ipv6 YANG schema element.
type NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6 struct {
	Ipv6Filter *string `path:"ipv6-filter" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6) IsYANGGoStruct() {}

// GetIpv6Filter retrieves the value of the leaf Ipv6Filter from the NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Filter is set, it can
// safely use t.GetIpv6Filter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6) GetIpv6Filter() string {
	if t == nil || t.Ipv6Filter == nil {
		return ""
	}
	return *t.Ipv6Filter
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6 struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Ipv6Filter == nil {
		return nil, fmt.Errorf("nil value for key Ipv6Filter")
	}

	return map[string]interface{}{
		"ipv6-filter": *t.Ipv6Filter,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6.
func (*NokiaConf_Configure_Groups_Group_Filter_SystemFilter_Ipv6) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt represents the /nokia-conf/configure/groups/group/fwd-path-ext YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt struct {
	Fpe        map[NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_FpeId_Union]*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe `path:"fpe" module:"nokia-conf"`
	SdpIdRange *NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange                                                          `path:"sdp-id-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt) IsYANGGoStruct() {}

// NewFpe creates a new entry in the Fpe list of the
// NokiaConf_Configure_Groups_Group_FwdPathExt struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt) NewFpe(FpeId NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_FpeId_Union) (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Fpe == nil {
		t.Fpe = make(map[NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_FpeId_Union]*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe)
	}

	key := FpeId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Fpe[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Fpe", key)
	}

	t.Fpe[key] = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe{
		FpeId: FpeId,
	}

	return t.Fpe[key], nil
}

// RenameFpe renames an entry in the list Fpe within
// the NokiaConf_Configure_Groups_Group_FwdPathExt struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt) RenameFpe(oldK, newK NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_FpeId_Union) error {
	if _, ok := t.Fpe[newK]; ok {
		return fmt.Errorf("key %v already exists in Fpe", newK)
	}

	e, ok := t.Fpe[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Fpe", oldK)
	}
	e.FpeId = newK

	t.Fpe[newK] = e
	delete(t.Fpe, oldK)
	return nil
}

// GetOrCreateFpe retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_FwdPathExt. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt) GetOrCreateFpe(FpeId NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_FpeId_Union) *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe {

	key := FpeId

	if v, ok := t.Fpe[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFpe(FpeId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFpe got unexpected error: %v", err))
	}
	return v
}

// GetFpe retrieves the value with the specified key from
// the Fpe map field of NokiaConf_Configure_Groups_Group_FwdPathExt. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt) GetFpe(FpeId NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_FpeId_Union) *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe {

	if t == nil {
		return nil
	}

	key := FpeId

	if lm, ok := t.Fpe[key]; ok {
		return lm
	}
	return nil
}

// DeleteFpe deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_FwdPathExt. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt) DeleteFpe(FpeId NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_FpeId_Union) {
	key := FpeId

	delete(t.Fpe, key)
}

// AppendFpe appends the supplied NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe struct to the
// list Fpe of NokiaConf_Configure_Groups_Group_FwdPathExt. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt) AppendFpe(v *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) error {
	key := v.FpeId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Fpe == nil {
		t.Fpe = make(map[NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_FpeId_Union]*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe)
	}

	if _, ok := t.Fpe[key]; ok {
		return fmt.Errorf("duplicate key for list Fpe %v", key)
	}

	t.Fpe[key] = v
	return nil
}

// GetOrCreateSdpIdRange retrieves the value of the SdpIdRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt) GetOrCreateSdpIdRange() *NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange {
	if t.SdpIdRange != nil {
		return t.SdpIdRange
	}
	t.SdpIdRange = &NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange{}
	return t.SdpIdRange
}

// GetSdpIdRange returns the value of the SdpIdRange struct pointer
// from NokiaConf_Configure_Groups_Group_FwdPathExt. If the receiver or the field SdpIdRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt) GetSdpIdRange() *NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange {
	if t != nil && t.SdpIdRange != nil {
		return t.SdpIdRange
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.SdpIdRange.PopulateDefaults()
	for _, e := range t.Fpe {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe struct {
	Application *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application `path:"application" module:"nokia-conf"`
	Description *string                                                      `path:"description" module:"nokia-conf"`
	FpeId       NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_FpeId_Union  `path:"fpe-id" module:"nokia-conf"`
	MultiPath   *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath   `path:"multi-path" module:"nokia-conf" yangPresence:"true"`
	Path        *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path        `path:"path" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) IsYANGGoStruct() {}

// GetOrCreateApplication retrieves the value of the Application field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) GetOrCreateApplication() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application {
	if t.Application != nil {
		return t.Application
	}
	t.Application = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application{}
	return t.Application
}

// GetOrCreateMultiPath retrieves the value of the MultiPath field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) GetOrCreateMultiPath() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath {
	if t.MultiPath != nil {
		return t.MultiPath
	}
	t.MultiPath = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath{}
	return t.MultiPath
}

// GetOrCreatePath retrieves the value of the Path field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) GetOrCreatePath() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path {
	if t.Path != nil {
		return t.Path
	}
	t.Path = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path{}
	return t.Path
}

// GetApplication returns the value of the Application struct pointer
// from NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe. If the receiver or the field Application is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) GetApplication() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application {
	if t != nil && t.Application != nil {
		return t.Application
	}
	return nil
}

// GetMultiPath returns the value of the MultiPath struct pointer
// from NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe. If the receiver or the field MultiPath is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) GetMultiPath() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath {
	if t != nil && t.MultiPath != nil {
		return t.MultiPath
	}
	return nil
}

// GetPath returns the value of the Path struct pointer
// from NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe. If the receiver or the field Path is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) GetPath() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path {
	if t != nil && t.Path != nil {
		return t.Path
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFpeId retrieves the value of the leaf FpeId from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FpeId is set, it can
// safely use t.GetFpeId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FpeId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) GetFpeId() NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_FpeId_Union {
	if t == nil || t.FpeId == nil {
		return nil
	}
	return t.FpeId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Application.PopulateDefaults()
	t.MultiPath.PopulateDefaults()
	t.Path.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"fpe-id": t.FpeId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe/application YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application struct {
	PwPort           *bool                                                                         `path:"pw-port" module:"nokia-conf"`
	PwPortExtension  *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension  `path:"pw-port-extension" module:"nokia-conf" yangPresence:"true"`
	Srv6             *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6             `path:"srv6" module:"nokia-conf" yangPresence:"true"`
	SubMgmtExtension *bool                                                                         `path:"sub-mgmt-extension" module:"nokia-conf"`
	Vxlan            *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan            `path:"vxlan" module:"nokia-conf" yangPresence:"true"`
	VxlanTermination *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination `path:"vxlan-termination" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) IsYANGGoStruct() {}

// GetOrCreatePwPortExtension retrieves the value of the PwPortExtension field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) GetOrCreatePwPortExtension() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension {
	if t.PwPortExtension != nil {
		return t.PwPortExtension
	}
	t.PwPortExtension = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension{}
	return t.PwPortExtension
}

// GetOrCreateSrv6 retrieves the value of the Srv6 field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) GetOrCreateSrv6() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6 {
	if t.Srv6 != nil {
		return t.Srv6
	}
	t.Srv6 = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6{}
	return t.Srv6
}

// GetOrCreateVxlan retrieves the value of the Vxlan field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) GetOrCreateVxlan() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan {
	if t.Vxlan != nil {
		return t.Vxlan
	}
	t.Vxlan = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan{}
	return t.Vxlan
}

// GetOrCreateVxlanTermination retrieves the value of the VxlanTermination field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) GetOrCreateVxlanTermination() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination {
	if t.VxlanTermination != nil {
		return t.VxlanTermination
	}
	t.VxlanTermination = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination{}
	return t.VxlanTermination
}

// GetPwPortExtension returns the value of the PwPortExtension struct pointer
// from NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application. If the receiver or the field PwPortExtension is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) GetPwPortExtension() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension {
	if t != nil && t.PwPortExtension != nil {
		return t.PwPortExtension
	}
	return nil
}

// GetSrv6 returns the value of the Srv6 struct pointer
// from NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application. If the receiver or the field Srv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) GetSrv6() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6 {
	if t != nil && t.Srv6 != nil {
		return t.Srv6
	}
	return nil
}

// GetVxlan returns the value of the Vxlan struct pointer
// from NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application. If the receiver or the field Vxlan is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) GetVxlan() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan {
	if t != nil && t.Vxlan != nil {
		return t.Vxlan
	}
	return nil
}

// GetVxlanTermination returns the value of the VxlanTermination struct pointer
// from NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application. If the receiver or the field VxlanTermination is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) GetVxlanTermination() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination {
	if t != nil && t.VxlanTermination != nil {
		return t.VxlanTermination
	}
	return nil
}

// GetPwPort retrieves the value of the leaf PwPort from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PwPort is set, it can
// safely use t.GetPwPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PwPort == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) GetPwPort() bool {
	if t == nil || t.PwPort == nil {
		return false
	}
	return *t.PwPort
}

// GetSubMgmtExtension retrieves the value of the leaf SubMgmtExtension from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubMgmtExtension is set, it can
// safely use t.GetSubMgmtExtension() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubMgmtExtension == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) GetSubMgmtExtension() bool {
	if t == nil || t.SubMgmtExtension == nil {
		return false
	}
	return *t.SubMgmtExtension
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.PwPort == nil {
		var v bool = false
		t.PwPort = &v
	}
	if t.SubMgmtExtension == nil {
		var v bool = false
		t.SubMgmtExtension = &v
	}
	t.PwPortExtension.PopulateDefaults()
	t.Srv6.PopulateDefaults()
	t.Vxlan.PopulateDefaults()
	t.VxlanTermination.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe/application/pw-port-extension YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension struct {
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension) IsYANGGoStruct() {
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_PwPortExtension) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6 represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe/application/srv6 YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6 struct {
	InterfaceA *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA `path:"interface-a" module:"nokia-conf"`
	InterfaceB *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB `path:"interface-b" module:"nokia-conf"`
	Type       E_NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_Type      `path:"type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6) IsYANGGoStruct() {}

// GetOrCreateInterfaceA retrieves the value of the InterfaceA field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6) GetOrCreateInterfaceA() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA {
	if t.InterfaceA != nil {
		return t.InterfaceA
	}
	t.InterfaceA = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA{}
	return t.InterfaceA
}

// GetOrCreateInterfaceB retrieves the value of the InterfaceB field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6) GetOrCreateInterfaceB() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB {
	if t.InterfaceB != nil {
		return t.InterfaceB
	}
	t.InterfaceB = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB{}
	return t.InterfaceB
}

// GetInterfaceA returns the value of the InterfaceA struct pointer
// from NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6. If the receiver or the field InterfaceA is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6) GetInterfaceA() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA {
	if t != nil && t.InterfaceA != nil {
		return t.InterfaceA
	}
	return nil
}

// GetInterfaceB returns the value of the InterfaceB struct pointer
// from NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6. If the receiver or the field InterfaceB is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6) GetInterfaceB() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB {
	if t != nil && t.InterfaceB != nil {
		return t.InterfaceB
	}
	return nil
}

// GetType retrieves the value of the leaf Type from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Type is set, it can
// safely use t.GetType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Type == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6) GetType() E_NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_Type {
	if t == nil || t.Type == 0 {
		return 0
	}
	return t.Type
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.InterfaceA.PopulateDefaults()
	t.InterfaceB.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe/application/srv6/interface-a YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA struct {
	Qos *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos `path:"qos" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA) IsYANGGoStruct() {
}

// GetOrCreateQos retrieves the value of the Qos field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA) GetOrCreateQos() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos {
	if t.Qos != nil {
		return t.Qos
	}
	t.Qos = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos{}
	return t.Qos
}

// GetQos returns the value of the Qos struct pointer
// from NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA. If the receiver or the field Qos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA) GetQos() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos {
	if t != nil && t.Qos != nil {
		return t.Qos
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Qos.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe/application/srv6/interface-a/qos YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos struct {
	NetworkPolicy *string `path:"network-policy" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos) IsYANGGoStruct() {
}

// GetNetworkPolicy retrieves the value of the leaf NetworkPolicy from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkPolicy is set, it can
// safely use t.GetNetworkPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos) GetNetworkPolicy() string {
	if t == nil || t.NetworkPolicy == nil {
		return ""
	}
	return *t.NetworkPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceA_Qos) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe/application/srv6/interface-b YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB struct {
	Mtu *uint32                                                                          `path:"mtu" module:"nokia-conf"`
	Qos *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos `path:"qos" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB) IsYANGGoStruct() {
}

// GetOrCreateQos retrieves the value of the Qos field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB) GetOrCreateQos() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos {
	if t.Qos != nil {
		return t.Qos
	}
	t.Qos = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos{}
	return t.Qos
}

// GetQos returns the value of the Qos struct pointer
// from NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB. If the receiver or the field Qos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB) GetQos() *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos {
	if t != nil && t.Qos != nil {
		return t.Qos
	}
	return nil
}

// GetMtu retrieves the value of the leaf Mtu from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB) GetMtu() uint32 {
	if t == nil || t.Mtu == nil {
		return 0
	}
	return *t.Mtu
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Qos.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe/application/srv6/interface-b/qos YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos struct {
	NetworkPolicy *string `path:"network-policy" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos) IsYANGGoStruct() {
}

// GetNetworkPolicy retrieves the value of the leaf NetworkPolicy from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NetworkPolicy is set, it can
// safely use t.GetNetworkPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NetworkPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos) GetNetworkPolicy() string {
	if t == nil || t.NetworkPolicy == nil {
		return ""
	}
	return *t.NetworkPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Srv6_InterfaceB_Qos) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe/application/vxlan YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan struct {
	RouterInstance *string `path:"router-instance" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan) IsYANGGoStruct() {}

// GetRouterInstance retrieves the value of the leaf RouterInstance from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterInstance is set, it can
// safely use t.GetRouterInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterInstance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan) GetRouterInstance() string {
	if t == nil || t.RouterInstance == nil {
		return "Base"
	}
	return *t.RouterInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RouterInstance == nil {
		var v string = "Base"
		t.RouterInstance = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_Vxlan) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe/application/vxlan-termination YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination struct {
	RouterInstance *string `path:"router-instance" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination) IsYANGGoStruct() {
}

// GetRouterInstance retrieves the value of the leaf RouterInstance from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterInstance is set, it can
// safely use t.GetRouterInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterInstance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination) GetRouterInstance() string {
	if t == nil || t.RouterInstance == nil {
		return "Base"
	}
	return *t.RouterInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RouterInstance == nil {
		var v string = "Base"
		t.RouterInstance = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Application_VxlanTermination) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe/multi-path YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath struct {
	Path map[NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path_PathId_Union]*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path `path:"path" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath) IsYANGGoStruct() {}

// NewPath creates a new entry in the Path list of the
// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath) NewPath(PathId NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path_PathId_Union) (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Path == nil {
		t.Path = make(map[NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path_PathId_Union]*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path)
	}

	key := PathId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Path[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Path", key)
	}

	t.Path[key] = &NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path{
		PathId: PathId,
	}

	return t.Path[key], nil
}

// RenamePath renames an entry in the list Path within
// the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath) RenamePath(oldK, newK NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path_PathId_Union) error {
	if _, ok := t.Path[newK]; ok {
		return fmt.Errorf("key %v already exists in Path", newK)
	}

	e, ok := t.Path[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Path", oldK)
	}
	e.PathId = newK

	t.Path[newK] = e
	delete(t.Path, oldK)
	return nil
}

// GetOrCreatePath retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath) GetOrCreatePath(PathId NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path_PathId_Union) *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path {

	key := PathId

	if v, ok := t.Path[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPath(PathId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePath got unexpected error: %v", err))
	}
	return v
}

// GetPath retrieves the value with the specified key from
// the Path map field of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath) GetPath(PathId NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path_PathId_Union) *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path {

	if t == nil {
		return nil
	}

	key := PathId

	if lm, ok := t.Path[key]; ok {
		return lm
	}
	return nil
}

// DeletePath deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath) DeletePath(PathId NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path_PathId_Union) {
	key := PathId

	delete(t.Path, key)
}

// AppendPath appends the supplied NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path struct to the
// list Path of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath) AppendPath(v *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path) error {
	key := v.PathId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Path == nil {
		t.Path = make(map[NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path_PathId_Union]*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path)
	}

	if _, ok := t.Path[key]; ok {
		return fmt.Errorf("duplicate key for list Path %v", key)
	}

	t.Path[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Path {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe/multi-path/path YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path struct {
	PathId NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path_PathId_Union `path:"path-id" module:"nokia-conf"`
	Pxc    *uint32                                                                     `path:"pxc" module:"nokia-conf"`
	XcLagA *string                                                                     `path:"xc-lag-a" module:"nokia-conf"`
	XcLagB *string                                                                     `path:"xc-lag-b" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path) IsYANGGoStruct() {}

// GetPathId retrieves the value of the leaf PathId from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PathId is set, it can
// safely use t.GetPathId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PathId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path) GetPathId() NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path_PathId_Union {
	if t == nil || t.PathId == nil {
		return nil
	}
	return t.PathId
}

// GetPxc retrieves the value of the leaf Pxc from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Pxc is set, it can
// safely use t.GetPxc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Pxc == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path) GetPxc() uint32 {
	if t == nil || t.Pxc == nil {
		return 0
	}
	return *t.Pxc
}

// GetXcLagA retrieves the value of the leaf XcLagA from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if XcLagA is set, it can
// safely use t.GetXcLagA() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.XcLagA == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path) GetXcLagA() string {
	if t == nil || t.XcLagA == nil {
		return ""
	}
	return *t.XcLagA
}

// GetXcLagB retrieves the value of the leaf XcLagB from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if XcLagB is set, it can
// safely use t.GetXcLagB() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.XcLagB == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path) GetXcLagB() string {
	if t == nil || t.XcLagB == nil {
		return ""
	}
	return *t.XcLagB
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"path-id": t.PathId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_MultiPath_Path) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path represents the /nokia-conf/configure/groups/group/fwd-path-ext/fpe/path YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path struct {
	Pxc    *uint32 `path:"pxc" module:"nokia-conf"`
	XcLagA *string `path:"xc-lag-a" module:"nokia-conf"`
	XcLagB *string `path:"xc-lag-b" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path) IsYANGGoStruct() {}

// GetPxc retrieves the value of the leaf Pxc from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Pxc is set, it can
// safely use t.GetPxc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Pxc == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path) GetPxc() uint32 {
	if t == nil || t.Pxc == nil {
		return 0
	}
	return *t.Pxc
}

// GetXcLagA retrieves the value of the leaf XcLagA from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if XcLagA is set, it can
// safely use t.GetXcLagA() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.XcLagA == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path) GetXcLagA() string {
	if t == nil || t.XcLagA == nil {
		return ""
	}
	return *t.XcLagA
}

// GetXcLagB retrieves the value of the leaf XcLagB from the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if XcLagB is set, it can
// safely use t.GetXcLagB() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.XcLagB == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path) GetXcLagB() string {
	if t == nil || t.XcLagB == nil {
		return ""
	}
	return *t.XcLagB
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_Fpe_Path) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange represents the /nokia-conf/configure/groups/group/fwd-path-ext/sdp-id-range YANG schema element.
type NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange struct {
	End   *uint32 `path:"end" module:"nokia-conf"`
	Start *uint32 `path:"start" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange) IsYANGGoStruct() {}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange) GetEnd() uint32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// GetStart retrieves the value of the leaf Start from the NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Start is set, it can
// safely use t.GetStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Start == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange) GetStart() uint32 {
	if t == nil || t.Start == nil {
		return 0
	}
	return *t.Start
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange.
func (*NokiaConf_Configure_Groups_Group_FwdPathExt_SdpIdRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_GroupEncryption represents the /nokia-conf/configure/groups/group/group-encryption YANG schema element.
type NokiaConf_Configure_Groups_Group_GroupEncryption struct {
	EncryptionKeygroup   map[NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_Id_Union]*NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup `path:"encryption-keygroup" module:"nokia-conf"`
	GroupEncryptionLabel *uint32                                                                                                                                               `path:"group-encryption-label" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_GroupEncryption implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_GroupEncryption) IsYANGGoStruct() {}

// NewEncryptionKeygroup creates a new entry in the EncryptionKeygroup list of the
// NokiaConf_Configure_Groups_Group_GroupEncryption struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption) NewEncryptionKeygroup(Id NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_Id_Union) (*NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EncryptionKeygroup == nil {
		t.EncryptionKeygroup = make(map[NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_Id_Union]*NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EncryptionKeygroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EncryptionKeygroup", key)
	}

	t.EncryptionKeygroup[key] = &NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup{
		Id: Id,
	}

	return t.EncryptionKeygroup[key], nil
}

// RenameEncryptionKeygroup renames an entry in the list EncryptionKeygroup within
// the NokiaConf_Configure_Groups_Group_GroupEncryption struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption) RenameEncryptionKeygroup(oldK, newK NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_Id_Union) error {
	if _, ok := t.EncryptionKeygroup[newK]; ok {
		return fmt.Errorf("key %v already exists in EncryptionKeygroup", newK)
	}

	e, ok := t.EncryptionKeygroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EncryptionKeygroup", oldK)
	}
	e.Id = newK

	t.EncryptionKeygroup[newK] = e
	delete(t.EncryptionKeygroup, oldK)
	return nil
}

// GetOrCreateEncryptionKeygroup retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_GroupEncryption. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption) GetOrCreateEncryptionKeygroup(Id NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_Id_Union) *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup {

	key := Id

	if v, ok := t.EncryptionKeygroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEncryptionKeygroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEncryptionKeygroup got unexpected error: %v", err))
	}
	return v
}

// GetEncryptionKeygroup retrieves the value with the specified key from
// the EncryptionKeygroup map field of NokiaConf_Configure_Groups_Group_GroupEncryption. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption) GetEncryptionKeygroup(Id NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_Id_Union) *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.EncryptionKeygroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteEncryptionKeygroup deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_GroupEncryption. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption) DeleteEncryptionKeygroup(Id NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_Id_Union) {
	key := Id

	delete(t.EncryptionKeygroup, key)
}

// AppendEncryptionKeygroup appends the supplied NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup struct to the
// list EncryptionKeygroup of NokiaConf_Configure_Groups_Group_GroupEncryption. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption) AppendEncryptionKeygroup(v *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EncryptionKeygroup == nil {
		t.EncryptionKeygroup = make(map[NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_Id_Union]*NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup)
	}

	if _, ok := t.EncryptionKeygroup[key]; ok {
		return fmt.Errorf("duplicate key for list EncryptionKeygroup %v", key)
	}

	t.EncryptionKeygroup[key] = v
	return nil
}

// GetGroupEncryptionLabel retrieves the value of the leaf GroupEncryptionLabel from the NokiaConf_Configure_Groups_Group_GroupEncryption
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GroupEncryptionLabel is set, it can
// safely use t.GetGroupEncryptionLabel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GroupEncryptionLabel == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption) GetGroupEncryptionLabel() uint32 {
	if t == nil || t.GroupEncryptionLabel == nil {
		return 0
	}
	return *t.GroupEncryptionLabel
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_GroupEncryption
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.EncryptionKeygroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_GroupEncryption"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_GroupEncryption.
func (*NokiaConf_Configure_Groups_Group_GroupEncryption) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup represents the /nokia-conf/configure/groups/group/group-encryption/encryption-keygroup YANG schema element.
type NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup struct {
	ActiveOutboundSecurityAssociation *uint32                                                                                                                                                                                                           `path:"active-outbound-security-association" module:"nokia-conf"`
	AuthenticationAlgorithm           E_NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_AuthenticationAlgorithm                                                                                                                     `path:"authentication-algorithm" module:"nokia-conf"`
	Description                       *string                                                                                                                                                                                                           `path:"description" module:"nokia-conf"`
	EncryptionAlgorithm               E_NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_EncryptionAlgorithm                                                                                                                         `path:"encryption-algorithm" module:"nokia-conf"`
	Id                                NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_Id_Union                                                                                                                                      `path:"id" module:"nokia-conf"`
	KeygroupName                      *string                                                                                                                                                                                                           `path:"keygroup-name" module:"nokia-conf"`
	SecurityAssociation               map[NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation_SecurityParameterIndex_Union]*NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation `path:"security-association" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) IsYANGGoStruct() {}

// NewSecurityAssociation creates a new entry in the SecurityAssociation list of the
// NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) NewSecurityAssociation(SecurityParameterIndex NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation_SecurityParameterIndex_Union) (*NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SecurityAssociation == nil {
		t.SecurityAssociation = make(map[NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation_SecurityParameterIndex_Union]*NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation)
	}

	key := SecurityParameterIndex

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SecurityAssociation[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SecurityAssociation", key)
	}

	t.SecurityAssociation[key] = &NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation{
		SecurityParameterIndex: SecurityParameterIndex,
	}

	return t.SecurityAssociation[key], nil
}

// RenameSecurityAssociation renames an entry in the list SecurityAssociation within
// the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) RenameSecurityAssociation(oldK, newK NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation_SecurityParameterIndex_Union) error {
	if _, ok := t.SecurityAssociation[newK]; ok {
		return fmt.Errorf("key %v already exists in SecurityAssociation", newK)
	}

	e, ok := t.SecurityAssociation[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SecurityAssociation", oldK)
	}
	e.SecurityParameterIndex = newK

	t.SecurityAssociation[newK] = e
	delete(t.SecurityAssociation, oldK)
	return nil
}

// GetOrCreateSecurityAssociation retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) GetOrCreateSecurityAssociation(SecurityParameterIndex NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation_SecurityParameterIndex_Union) *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation {

	key := SecurityParameterIndex

	if v, ok := t.SecurityAssociation[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSecurityAssociation(SecurityParameterIndex)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSecurityAssociation got unexpected error: %v", err))
	}
	return v
}

// GetSecurityAssociation retrieves the value with the specified key from
// the SecurityAssociation map field of NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) GetSecurityAssociation(SecurityParameterIndex NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation_SecurityParameterIndex_Union) *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation {

	if t == nil {
		return nil
	}

	key := SecurityParameterIndex

	if lm, ok := t.SecurityAssociation[key]; ok {
		return lm
	}
	return nil
}

// DeleteSecurityAssociation deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) DeleteSecurityAssociation(SecurityParameterIndex NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation_SecurityParameterIndex_Union) {
	key := SecurityParameterIndex

	delete(t.SecurityAssociation, key)
}

// AppendSecurityAssociation appends the supplied NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation struct to the
// list SecurityAssociation of NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) AppendSecurityAssociation(v *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation) error {
	key := v.SecurityParameterIndex

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SecurityAssociation == nil {
		t.SecurityAssociation = make(map[NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation_SecurityParameterIndex_Union]*NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation)
	}

	if _, ok := t.SecurityAssociation[key]; ok {
		return fmt.Errorf("duplicate key for list SecurityAssociation %v", key)
	}

	t.SecurityAssociation[key] = v
	return nil
}

// GetActiveOutboundSecurityAssociation retrieves the value of the leaf ActiveOutboundSecurityAssociation from the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ActiveOutboundSecurityAssociation is set, it can
// safely use t.GetActiveOutboundSecurityAssociation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ActiveOutboundSecurityAssociation == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) GetActiveOutboundSecurityAssociation() uint32 {
	if t == nil || t.ActiveOutboundSecurityAssociation == nil {
		return 0
	}
	return *t.ActiveOutboundSecurityAssociation
}

// GetAuthenticationAlgorithm retrieves the value of the leaf AuthenticationAlgorithm from the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationAlgorithm is set, it can
// safely use t.GetAuthenticationAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationAlgorithm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) GetAuthenticationAlgorithm() E_NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_AuthenticationAlgorithm {
	if t == nil || t.AuthenticationAlgorithm == 0 {
		return NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_AuthenticationAlgorithm_sha256
	}
	return t.AuthenticationAlgorithm
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEncryptionAlgorithm retrieves the value of the leaf EncryptionAlgorithm from the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncryptionAlgorithm is set, it can
// safely use t.GetEncryptionAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncryptionAlgorithm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) GetEncryptionAlgorithm() E_NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_EncryptionAlgorithm {
	if t == nil || t.EncryptionAlgorithm == 0 {
		return NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_EncryptionAlgorithm_aes128
	}
	return t.EncryptionAlgorithm
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) GetId() NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// GetKeygroupName retrieves the value of the leaf KeygroupName from the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeygroupName is set, it can
// safely use t.GetKeygroupName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeygroupName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) GetKeygroupName() string {
	if t == nil || t.KeygroupName == nil {
		return ""
	}
	return *t.KeygroupName
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AuthenticationAlgorithm == 0 {
		t.AuthenticationAlgorithm = NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_AuthenticationAlgorithm_sha256
	}
	if t.EncryptionAlgorithm == 0 {
		t.EncryptionAlgorithm = NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_EncryptionAlgorithm_aes128
	}
	if t.KeygroupName == nil {
		var v string = ""
		t.KeygroupName = &v
	}
	for _, e := range t.SecurityAssociation {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup.
func (*NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation represents the /nokia-conf/configure/groups/group/group-encryption/encryption-keygroup/security-association YANG schema element.
type NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation struct {
	AuthenticationKey      *string                                                                                                              `path:"authentication-key" module:"nokia-conf"`
	EncryptionKey          *string                                                                                                              `path:"encryption-key" module:"nokia-conf"`
	SecurityParameterIndex NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation_SecurityParameterIndex_Union `path:"security-parameter-index" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation) IsYANGGoStruct() {
}

// GetAuthenticationKey retrieves the value of the leaf AuthenticationKey from the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthenticationKey is set, it can
// safely use t.GetAuthenticationKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthenticationKey == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation) GetAuthenticationKey() string {
	if t == nil || t.AuthenticationKey == nil {
		return ""
	}
	return *t.AuthenticationKey
}

// GetEncryptionKey retrieves the value of the leaf EncryptionKey from the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncryptionKey is set, it can
// safely use t.GetEncryptionKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncryptionKey == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation) GetEncryptionKey() string {
	if t == nil || t.EncryptionKey == nil {
		return ""
	}
	return *t.EncryptionKey
}

// GetSecurityParameterIndex retrieves the value of the leaf SecurityParameterIndex from the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SecurityParameterIndex is set, it can
// safely use t.GetSecurityParameterIndex() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SecurityParameterIndex == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation) GetSecurityParameterIndex() NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation_SecurityParameterIndex_Union {
	if t == nil || t.SecurityParameterIndex == nil {
		return nil
	}
	return t.SecurityParameterIndex
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"security-parameter-index": t.SecurityParameterIndex,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation.
func (*NokiaConf_Configure_Groups_Group_GroupEncryption_EncryptionKeygroup_SecurityAssociation) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec represents the /nokia-conf/configure/groups/group/ipsec YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec struct {
	CertProfile               map[string]*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile                                                            `path:"cert-profile" module:"nokia-conf"`
	ClientDb                  map[string]*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb                                                               `path:"client-db" module:"nokia-conf"`
	IkePolicy                 map[NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy           `path:"ike-policy" module:"nokia-conf"`
	IkeTransform              map[NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform     `path:"ike-transform" module:"nokia-conf"`
	IpsecTransform            map[NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform `path:"ipsec-transform" module:"nokia-conf"`
	IpsecTransportModeProfile map[string]*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile                                              `path:"ipsec-transport-mode-profile" module:"nokia-conf"`
	Radius                    *NokiaConf_Configure_Groups_Group_Ipsec_Radius                                                                            `path:"radius" module:"nokia-conf"`
	ShowIpsecKeys             *bool                                                                                                                     `path:"show-ipsec-keys" module:"nokia-conf"`
	StaticSa                  map[string]*NokiaConf_Configure_Groups_Group_Ipsec_StaticSa                                                               `path:"static-sa" module:"nokia-conf"`
	TrustAnchorProfile        map[string]*NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile                                                     `path:"trust-anchor-profile" module:"nokia-conf"`
	TsList                    map[string]*NokiaConf_Configure_Groups_Group_Ipsec_TsList                                                                 `path:"ts-list" module:"nokia-conf"`
	TunnelTemplate            map[NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate `path:"tunnel-template" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec) IsYANGGoStruct() {}

// NewCertProfile creates a new entry in the CertProfile list of the
// NokiaConf_Configure_Groups_Group_Ipsec struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) NewCertProfile(Name string) (*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CertProfile == nil {
		t.CertProfile = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.CertProfile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list CertProfile", key)
	}

	t.CertProfile[key] = &NokiaConf_Configure_Groups_Group_Ipsec_CertProfile{
		Name: &Name,
	}

	return t.CertProfile[key], nil
}

// RenameCertProfile renames an entry in the list CertProfile within
// the NokiaConf_Configure_Groups_Group_Ipsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) RenameCertProfile(oldK, newK string) error {
	if _, ok := t.CertProfile[newK]; ok {
		return fmt.Errorf("key %v already exists in CertProfile", newK)
	}

	e, ok := t.CertProfile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in CertProfile", oldK)
	}
	e.Name = &newK

	t.CertProfile[newK] = e
	delete(t.CertProfile, oldK)
	return nil
}

// GetOrCreateCertProfile retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetOrCreateCertProfile(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile {

	key := Name

	if v, ok := t.CertProfile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCertProfile(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCertProfile got unexpected error: %v", err))
	}
	return v
}

// GetCertProfile retrieves the value with the specified key from
// the CertProfile map field of NokiaConf_Configure_Groups_Group_Ipsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetCertProfile(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.CertProfile[key]; ok {
		return lm
	}
	return nil
}

// DeleteCertProfile deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) DeleteCertProfile(Name string) {
	key := Name

	delete(t.CertProfile, key)
}

// AppendCertProfile appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_CertProfile struct to the
// list CertProfile of NokiaConf_Configure_Groups_Group_Ipsec. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_CertProfile already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) AppendCertProfile(v *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.CertProfile == nil {
		t.CertProfile = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile)
	}

	if _, ok := t.CertProfile[key]; ok {
		return fmt.Errorf("duplicate key for list CertProfile %v", key)
	}

	t.CertProfile[key] = v
	return nil
}

// NewClientDb creates a new entry in the ClientDb list of the
// NokiaConf_Configure_Groups_Group_Ipsec struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) NewClientDb(Name string) (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ClientDb == nil {
		t.ClientDb = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ClientDb[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ClientDb", key)
	}

	t.ClientDb[key] = &NokiaConf_Configure_Groups_Group_Ipsec_ClientDb{
		Name: &Name,
	}

	return t.ClientDb[key], nil
}

// RenameClientDb renames an entry in the list ClientDb within
// the NokiaConf_Configure_Groups_Group_Ipsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) RenameClientDb(oldK, newK string) error {
	if _, ok := t.ClientDb[newK]; ok {
		return fmt.Errorf("key %v already exists in ClientDb", newK)
	}

	e, ok := t.ClientDb[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ClientDb", oldK)
	}
	e.Name = &newK

	t.ClientDb[newK] = e
	delete(t.ClientDb, oldK)
	return nil
}

// GetOrCreateClientDb retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetOrCreateClientDb(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb {

	key := Name

	if v, ok := t.ClientDb[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewClientDb(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateClientDb got unexpected error: %v", err))
	}
	return v
}

// GetClientDb retrieves the value with the specified key from
// the ClientDb map field of NokiaConf_Configure_Groups_Group_Ipsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetClientDb(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.ClientDb[key]; ok {
		return lm
	}
	return nil
}

// DeleteClientDb deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) DeleteClientDb(Name string) {
	key := Name

	delete(t.ClientDb, key)
}

// AppendClientDb appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_ClientDb struct to the
// list ClientDb of NokiaConf_Configure_Groups_Group_Ipsec. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_ClientDb already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) AppendClientDb(v *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ClientDb == nil {
		t.ClientDb = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb)
	}

	if _, ok := t.ClientDb[key]; ok {
		return fmt.Errorf("duplicate key for list ClientDb %v", key)
	}

	t.ClientDb[key] = v
	return nil
}

// NewIkePolicy creates a new entry in the IkePolicy list of the
// NokiaConf_Configure_Groups_Group_Ipsec struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) NewIkePolicy(Id NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Id_Union) (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IkePolicy == nil {
		t.IkePolicy = make(map[NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IkePolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IkePolicy", key)
	}

	t.IkePolicy[key] = &NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy{
		Id: Id,
	}

	return t.IkePolicy[key], nil
}

// RenameIkePolicy renames an entry in the list IkePolicy within
// the NokiaConf_Configure_Groups_Group_Ipsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) RenameIkePolicy(oldK, newK NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Id_Union) error {
	if _, ok := t.IkePolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in IkePolicy", newK)
	}

	e, ok := t.IkePolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IkePolicy", oldK)
	}
	e.Id = newK

	t.IkePolicy[newK] = e
	delete(t.IkePolicy, oldK)
	return nil
}

// GetOrCreateIkePolicy retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetOrCreateIkePolicy(Id NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy {

	key := Id

	if v, ok := t.IkePolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIkePolicy(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIkePolicy got unexpected error: %v", err))
	}
	return v
}

// GetIkePolicy retrieves the value with the specified key from
// the IkePolicy map field of NokiaConf_Configure_Groups_Group_Ipsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetIkePolicy(Id NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.IkePolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteIkePolicy deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) DeleteIkePolicy(Id NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Id_Union) {
	key := Id

	delete(t.IkePolicy, key)
}

// AppendIkePolicy appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy struct to the
// list IkePolicy of NokiaConf_Configure_Groups_Group_Ipsec. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) AppendIkePolicy(v *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IkePolicy == nil {
		t.IkePolicy = make(map[NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy)
	}

	if _, ok := t.IkePolicy[key]; ok {
		return fmt.Errorf("duplicate key for list IkePolicy %v", key)
	}

	t.IkePolicy[key] = v
	return nil
}

// NewIkeTransform creates a new entry in the IkeTransform list of the
// NokiaConf_Configure_Groups_Group_Ipsec struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) NewIkeTransform(Id NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform_Id_Union) (*NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IkeTransform == nil {
		t.IkeTransform = make(map[NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IkeTransform[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IkeTransform", key)
	}

	t.IkeTransform[key] = &NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform{
		Id: Id,
	}

	return t.IkeTransform[key], nil
}

// RenameIkeTransform renames an entry in the list IkeTransform within
// the NokiaConf_Configure_Groups_Group_Ipsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) RenameIkeTransform(oldK, newK NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform_Id_Union) error {
	if _, ok := t.IkeTransform[newK]; ok {
		return fmt.Errorf("key %v already exists in IkeTransform", newK)
	}

	e, ok := t.IkeTransform[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IkeTransform", oldK)
	}
	e.Id = newK

	t.IkeTransform[newK] = e
	delete(t.IkeTransform, oldK)
	return nil
}

// GetOrCreateIkeTransform retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetOrCreateIkeTransform(Id NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform {

	key := Id

	if v, ok := t.IkeTransform[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIkeTransform(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIkeTransform got unexpected error: %v", err))
	}
	return v
}

// GetIkeTransform retrieves the value with the specified key from
// the IkeTransform map field of NokiaConf_Configure_Groups_Group_Ipsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetIkeTransform(Id NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.IkeTransform[key]; ok {
		return lm
	}
	return nil
}

// DeleteIkeTransform deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) DeleteIkeTransform(Id NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform_Id_Union) {
	key := Id

	delete(t.IkeTransform, key)
}

// AppendIkeTransform appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform struct to the
// list IkeTransform of NokiaConf_Configure_Groups_Group_Ipsec. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) AppendIkeTransform(v *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IkeTransform == nil {
		t.IkeTransform = make(map[NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform)
	}

	if _, ok := t.IkeTransform[key]; ok {
		return fmt.Errorf("duplicate key for list IkeTransform %v", key)
	}

	t.IkeTransform[key] = v
	return nil
}

// NewIpsecTransform creates a new entry in the IpsecTransform list of the
// NokiaConf_Configure_Groups_Group_Ipsec struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) NewIpsecTransform(Id NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform_Id_Union) (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpsecTransform == nil {
		t.IpsecTransform = make(map[NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IpsecTransform[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IpsecTransform", key)
	}

	t.IpsecTransform[key] = &NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform{
		Id: Id,
	}

	return t.IpsecTransform[key], nil
}

// RenameIpsecTransform renames an entry in the list IpsecTransform within
// the NokiaConf_Configure_Groups_Group_Ipsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) RenameIpsecTransform(oldK, newK NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform_Id_Union) error {
	if _, ok := t.IpsecTransform[newK]; ok {
		return fmt.Errorf("key %v already exists in IpsecTransform", newK)
	}

	e, ok := t.IpsecTransform[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IpsecTransform", oldK)
	}
	e.Id = newK

	t.IpsecTransform[newK] = e
	delete(t.IpsecTransform, oldK)
	return nil
}

// GetOrCreateIpsecTransform retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetOrCreateIpsecTransform(Id NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform {

	key := Id

	if v, ok := t.IpsecTransform[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpsecTransform(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpsecTransform got unexpected error: %v", err))
	}
	return v
}

// GetIpsecTransform retrieves the value with the specified key from
// the IpsecTransform map field of NokiaConf_Configure_Groups_Group_Ipsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetIpsecTransform(Id NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.IpsecTransform[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpsecTransform deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) DeleteIpsecTransform(Id NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform_Id_Union) {
	key := Id

	delete(t.IpsecTransform, key)
}

// AppendIpsecTransform appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform struct to the
// list IpsecTransform of NokiaConf_Configure_Groups_Group_Ipsec. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) AppendIpsecTransform(v *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpsecTransform == nil {
		t.IpsecTransform = make(map[NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform)
	}

	if _, ok := t.IpsecTransform[key]; ok {
		return fmt.Errorf("duplicate key for list IpsecTransform %v", key)
	}

	t.IpsecTransform[key] = v
	return nil
}

// NewIpsecTransportModeProfile creates a new entry in the IpsecTransportModeProfile list of the
// NokiaConf_Configure_Groups_Group_Ipsec struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) NewIpsecTransportModeProfile(Name string) (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpsecTransportModeProfile == nil {
		t.IpsecTransportModeProfile = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IpsecTransportModeProfile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IpsecTransportModeProfile", key)
	}

	t.IpsecTransportModeProfile[key] = &NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile{
		Name: &Name,
	}

	return t.IpsecTransportModeProfile[key], nil
}

// RenameIpsecTransportModeProfile renames an entry in the list IpsecTransportModeProfile within
// the NokiaConf_Configure_Groups_Group_Ipsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) RenameIpsecTransportModeProfile(oldK, newK string) error {
	if _, ok := t.IpsecTransportModeProfile[newK]; ok {
		return fmt.Errorf("key %v already exists in IpsecTransportModeProfile", newK)
	}

	e, ok := t.IpsecTransportModeProfile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IpsecTransportModeProfile", oldK)
	}
	e.Name = &newK

	t.IpsecTransportModeProfile[newK] = e
	delete(t.IpsecTransportModeProfile, oldK)
	return nil
}

// GetOrCreateIpsecTransportModeProfile retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetOrCreateIpsecTransportModeProfile(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile {

	key := Name

	if v, ok := t.IpsecTransportModeProfile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpsecTransportModeProfile(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpsecTransportModeProfile got unexpected error: %v", err))
	}
	return v
}

// GetIpsecTransportModeProfile retrieves the value with the specified key from
// the IpsecTransportModeProfile map field of NokiaConf_Configure_Groups_Group_Ipsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetIpsecTransportModeProfile(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.IpsecTransportModeProfile[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpsecTransportModeProfile deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) DeleteIpsecTransportModeProfile(Name string) {
	key := Name

	delete(t.IpsecTransportModeProfile, key)
}

// AppendIpsecTransportModeProfile appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile struct to the
// list IpsecTransportModeProfile of NokiaConf_Configure_Groups_Group_Ipsec. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) AppendIpsecTransportModeProfile(v *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IpsecTransportModeProfile == nil {
		t.IpsecTransportModeProfile = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile)
	}

	if _, ok := t.IpsecTransportModeProfile[key]; ok {
		return fmt.Errorf("duplicate key for list IpsecTransportModeProfile %v", key)
	}

	t.IpsecTransportModeProfile[key] = v
	return nil
}

// NewStaticSa creates a new entry in the StaticSa list of the
// NokiaConf_Configure_Groups_Group_Ipsec struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) NewStaticSa(Name string) (*NokiaConf_Configure_Groups_Group_Ipsec_StaticSa, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticSa == nil {
		t.StaticSa = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_StaticSa)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.StaticSa[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list StaticSa", key)
	}

	t.StaticSa[key] = &NokiaConf_Configure_Groups_Group_Ipsec_StaticSa{
		Name: &Name,
	}

	return t.StaticSa[key], nil
}

// RenameStaticSa renames an entry in the list StaticSa within
// the NokiaConf_Configure_Groups_Group_Ipsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) RenameStaticSa(oldK, newK string) error {
	if _, ok := t.StaticSa[newK]; ok {
		return fmt.Errorf("key %v already exists in StaticSa", newK)
	}

	e, ok := t.StaticSa[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in StaticSa", oldK)
	}
	e.Name = &newK

	t.StaticSa[newK] = e
	delete(t.StaticSa, oldK)
	return nil
}

// GetOrCreateStaticSa retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetOrCreateStaticSa(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa {

	key := Name

	if v, ok := t.StaticSa[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStaticSa(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStaticSa got unexpected error: %v", err))
	}
	return v
}

// GetStaticSa retrieves the value with the specified key from
// the StaticSa map field of NokiaConf_Configure_Groups_Group_Ipsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetStaticSa(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.StaticSa[key]; ok {
		return lm
	}
	return nil
}

// DeleteStaticSa deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) DeleteStaticSa(Name string) {
	key := Name

	delete(t.StaticSa, key)
}

// AppendStaticSa appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_StaticSa struct to the
// list StaticSa of NokiaConf_Configure_Groups_Group_Ipsec. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_StaticSa already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) AppendStaticSa(v *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StaticSa == nil {
		t.StaticSa = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_StaticSa)
	}

	if _, ok := t.StaticSa[key]; ok {
		return fmt.Errorf("duplicate key for list StaticSa %v", key)
	}

	t.StaticSa[key] = v
	return nil
}

// NewTrustAnchorProfile creates a new entry in the TrustAnchorProfile list of the
// NokiaConf_Configure_Groups_Group_Ipsec struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) NewTrustAnchorProfile(Name string) (*NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrustAnchorProfile == nil {
		t.TrustAnchorProfile = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TrustAnchorProfile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TrustAnchorProfile", key)
	}

	t.TrustAnchorProfile[key] = &NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile{
		Name: &Name,
	}

	return t.TrustAnchorProfile[key], nil
}

// RenameTrustAnchorProfile renames an entry in the list TrustAnchorProfile within
// the NokiaConf_Configure_Groups_Group_Ipsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) RenameTrustAnchorProfile(oldK, newK string) error {
	if _, ok := t.TrustAnchorProfile[newK]; ok {
		return fmt.Errorf("key %v already exists in TrustAnchorProfile", newK)
	}

	e, ok := t.TrustAnchorProfile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TrustAnchorProfile", oldK)
	}
	e.Name = &newK

	t.TrustAnchorProfile[newK] = e
	delete(t.TrustAnchorProfile, oldK)
	return nil
}

// GetOrCreateTrustAnchorProfile retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetOrCreateTrustAnchorProfile(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile {

	key := Name

	if v, ok := t.TrustAnchorProfile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTrustAnchorProfile(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTrustAnchorProfile got unexpected error: %v", err))
	}
	return v
}

// GetTrustAnchorProfile retrieves the value with the specified key from
// the TrustAnchorProfile map field of NokiaConf_Configure_Groups_Group_Ipsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetTrustAnchorProfile(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.TrustAnchorProfile[key]; ok {
		return lm
	}
	return nil
}

// DeleteTrustAnchorProfile deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) DeleteTrustAnchorProfile(Name string) {
	key := Name

	delete(t.TrustAnchorProfile, key)
}

// AppendTrustAnchorProfile appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile struct to the
// list TrustAnchorProfile of NokiaConf_Configure_Groups_Group_Ipsec. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) AppendTrustAnchorProfile(v *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrustAnchorProfile == nil {
		t.TrustAnchorProfile = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile)
	}

	if _, ok := t.TrustAnchorProfile[key]; ok {
		return fmt.Errorf("duplicate key for list TrustAnchorProfile %v", key)
	}

	t.TrustAnchorProfile[key] = v
	return nil
}

// NewTsList creates a new entry in the TsList list of the
// NokiaConf_Configure_Groups_Group_Ipsec struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) NewTsList(Name string) (*NokiaConf_Configure_Groups_Group_Ipsec_TsList, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TsList == nil {
		t.TsList = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_TsList)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TsList[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TsList", key)
	}

	t.TsList[key] = &NokiaConf_Configure_Groups_Group_Ipsec_TsList{
		Name: &Name,
	}

	return t.TsList[key], nil
}

// RenameTsList renames an entry in the list TsList within
// the NokiaConf_Configure_Groups_Group_Ipsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) RenameTsList(oldK, newK string) error {
	if _, ok := t.TsList[newK]; ok {
		return fmt.Errorf("key %v already exists in TsList", newK)
	}

	e, ok := t.TsList[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TsList", oldK)
	}
	e.Name = &newK

	t.TsList[newK] = e
	delete(t.TsList, oldK)
	return nil
}

// GetOrCreateTsList retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetOrCreateTsList(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_TsList {

	key := Name

	if v, ok := t.TsList[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTsList(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTsList got unexpected error: %v", err))
	}
	return v
}

// GetTsList retrieves the value with the specified key from
// the TsList map field of NokiaConf_Configure_Groups_Group_Ipsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetTsList(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_TsList {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.TsList[key]; ok {
		return lm
	}
	return nil
}

// DeleteTsList deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) DeleteTsList(Name string) {
	key := Name

	delete(t.TsList, key)
}

// AppendTsList appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_TsList struct to the
// list TsList of NokiaConf_Configure_Groups_Group_Ipsec. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_TsList already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) AppendTsList(v *NokiaConf_Configure_Groups_Group_Ipsec_TsList) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TsList == nil {
		t.TsList = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_TsList)
	}

	if _, ok := t.TsList[key]; ok {
		return fmt.Errorf("duplicate key for list TsList %v", key)
	}

	t.TsList[key] = v
	return nil
}

// NewTunnelTemplate creates a new entry in the TunnelTemplate list of the
// NokiaConf_Configure_Groups_Group_Ipsec struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) NewTunnelTemplate(Id NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Id_Union) (*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TunnelTemplate == nil {
		t.TunnelTemplate = make(map[NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TunnelTemplate[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TunnelTemplate", key)
	}

	t.TunnelTemplate[key] = &NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate{
		Id: Id,
	}

	return t.TunnelTemplate[key], nil
}

// RenameTunnelTemplate renames an entry in the list TunnelTemplate within
// the NokiaConf_Configure_Groups_Group_Ipsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) RenameTunnelTemplate(oldK, newK NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Id_Union) error {
	if _, ok := t.TunnelTemplate[newK]; ok {
		return fmt.Errorf("key %v already exists in TunnelTemplate", newK)
	}

	e, ok := t.TunnelTemplate[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TunnelTemplate", oldK)
	}
	e.Id = newK

	t.TunnelTemplate[newK] = e
	delete(t.TunnelTemplate, oldK)
	return nil
}

// GetOrCreateTunnelTemplate retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetOrCreateTunnelTemplate(Id NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate {

	key := Id

	if v, ok := t.TunnelTemplate[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTunnelTemplate(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTunnelTemplate got unexpected error: %v", err))
	}
	return v
}

// GetTunnelTemplate retrieves the value with the specified key from
// the TunnelTemplate map field of NokiaConf_Configure_Groups_Group_Ipsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetTunnelTemplate(Id NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.TunnelTemplate[key]; ok {
		return lm
	}
	return nil
}

// DeleteTunnelTemplate deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) DeleteTunnelTemplate(Id NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Id_Union) {
	key := Id

	delete(t.TunnelTemplate, key)
}

// AppendTunnelTemplate appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate struct to the
// list TunnelTemplate of NokiaConf_Configure_Groups_Group_Ipsec. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) AppendTunnelTemplate(v *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TunnelTemplate == nil {
		t.TunnelTemplate = make(map[NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate)
	}

	if _, ok := t.TunnelTemplate[key]; ok {
		return fmt.Errorf("duplicate key for list TunnelTemplate %v", key)
	}

	t.TunnelTemplate[key] = v
	return nil
}

// GetOrCreateRadius retrieves the value of the Radius field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetOrCreateRadius() *NokiaConf_Configure_Groups_Group_Ipsec_Radius {
	if t.Radius != nil {
		return t.Radius
	}
	t.Radius = &NokiaConf_Configure_Groups_Group_Ipsec_Radius{}
	return t.Radius
}

// GetRadius returns the value of the Radius struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec. If the receiver or the field Radius is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetRadius() *NokiaConf_Configure_Groups_Group_Ipsec_Radius {
	if t != nil && t.Radius != nil {
		return t.Radius
	}
	return nil
}

// GetShowIpsecKeys retrieves the value of the leaf ShowIpsecKeys from the NokiaConf_Configure_Groups_Group_Ipsec
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ShowIpsecKeys is set, it can
// safely use t.GetShowIpsecKeys() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ShowIpsecKeys == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) GetShowIpsecKeys() bool {
	if t == nil || t.ShowIpsecKeys == nil {
		return false
	}
	return *t.ShowIpsecKeys
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ShowIpsecKeys == nil {
		var v bool = false
		t.ShowIpsecKeys = &v
	}
	t.Radius.PopulateDefaults()
	for _, e := range t.CertProfile {
		e.PopulateDefaults()
	}
	for _, e := range t.ClientDb {
		e.PopulateDefaults()
	}
	for _, e := range t.IkePolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.IkeTransform {
		e.PopulateDefaults()
	}
	for _, e := range t.IpsecTransform {
		e.PopulateDefaults()
	}
	for _, e := range t.IpsecTransportModeProfile {
		e.PopulateDefaults()
	}
	for _, e := range t.StaticSa {
		e.PopulateDefaults()
	}
	for _, e := range t.TrustAnchorProfile {
		e.PopulateDefaults()
	}
	for _, e := range t.TsList {
		e.PopulateDefaults()
	}
	for _, e := range t.TunnelTemplate {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec.
func (*NokiaConf_Configure_Groups_Group_Ipsec) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_CertProfile represents the /nokia-conf/configure/groups/group/ipsec/cert-profile YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_CertProfile struct {
	AdminState E_NokiaTypesSros_AdminState                                                                                                     `path:"admin-state" module:"nokia-conf"`
	Entry      map[NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry `path:"entry" module:"nokia-conf"`
	Name       *string                                                                                                                         `path:"name" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_CertProfile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Ipsec_CertProfile struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) NewEntry(Id NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_CertProfile. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Ipsec_CertProfile. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) GetEntry(Id NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_CertProfile. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Ipsec_CertProfile. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) AppendEntry(v *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_CertProfile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_CertProfile.
func (*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry represents the /nokia-conf/configure/groups/group/ipsec/cert-profile/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry struct {
	Cert         *string                                                                 `path:"cert" module:"nokia-conf"`
	Id           NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_Id_Union       `path:"id" module:"nokia-conf"`
	Key          *string                                                                 `path:"key" module:"nokia-conf"`
	RsaSignature E_NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_RsaSignature `path:"rsa-signature" module:"nokia-conf"`
	SendChain    *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain     `path:"send-chain" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) IsYANGGoStruct() {}

// GetOrCreateSendChain retrieves the value of the SendChain field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) GetOrCreateSendChain() *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain {
	if t.SendChain != nil {
		return t.SendChain
	}
	t.SendChain = &NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain{}
	return t.SendChain
}

// GetSendChain returns the value of the SendChain struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry. If the receiver or the field SendChain is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) GetSendChain() *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain {
	if t != nil && t.SendChain != nil {
		return t.SendChain
	}
	return nil
}

// GetCert retrieves the value of the leaf Cert from the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cert is set, it can
// safely use t.GetCert() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cert == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) GetCert() string {
	if t == nil || t.Cert == nil {
		return ""
	}
	return *t.Cert
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) GetId() NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// GetKey retrieves the value of the leaf Key from the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Key is set, it can
// safely use t.GetKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Key == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) GetKey() string {
	if t == nil || t.Key == nil {
		return ""
	}
	return *t.Key
}

// GetRsaSignature retrieves the value of the leaf RsaSignature from the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RsaSignature is set, it can
// safely use t.GetRsaSignature() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RsaSignature == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) GetRsaSignature() E_NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_RsaSignature {
	if t == nil || t.RsaSignature == 0 {
		return NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_RsaSignature_pkcs1
	}
	return t.RsaSignature
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RsaSignature == 0 {
		t.RsaSignature = NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_RsaSignature_pkcs1
	}
	t.SendChain.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry.
func (*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain represents the /nokia-conf/configure/groups/group/ipsec/cert-profile/entry/send-chain YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain struct {
	CaProfile []string `path:"ca-profile" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain) IsYANGGoStruct() {}

// GetCaProfile retrieves the value of the leaf CaProfile from the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CaProfile is set, it can
// safely use t.GetCaProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CaProfile == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain) GetCaProfile() []string {
	if t == nil || t.CaProfile == nil {
		return nil
	}
	return t.CaProfile
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain.
func (*NokiaConf_Configure_Groups_Group_Ipsec_CertProfile_Entry_SendChain) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_ClientDb represents the /nokia-conf/configure/groups/group/ipsec/client-db YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_ClientDb struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                 `path:"admin-state" module:"nokia-conf"`
	Client      map[NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client `path:"client" module:"nokia-conf"`
	Description *string                                                                                                                     `path:"description" module:"nokia-conf"`
	MatchList   *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList                                                                  `path:"match-list" module:"nokia-conf"`
	Name        *string                                                                                                                     `path:"name" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_ClientDb implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) IsYANGGoStruct() {}

// NewClient creates a new entry in the Client list of the
// NokiaConf_Configure_Groups_Group_Ipsec_ClientDb struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) NewClient(Id NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Id_Union) (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Client == nil {
		t.Client = make(map[NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Client[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Client", key)
	}

	t.Client[key] = &NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client{
		Id: Id,
	}

	return t.Client[key], nil
}

// RenameClient renames an entry in the list Client within
// the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) RenameClient(oldK, newK NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Id_Union) error {
	if _, ok := t.Client[newK]; ok {
		return fmt.Errorf("key %v already exists in Client", newK)
	}

	e, ok := t.Client[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Client", oldK)
	}
	e.Id = newK

	t.Client[newK] = e
	delete(t.Client, oldK)
	return nil
}

// GetOrCreateClient retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_ClientDb. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) GetOrCreateClient(Id NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client {

	key := Id

	if v, ok := t.Client[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewClient(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateClient got unexpected error: %v", err))
	}
	return v
}

// GetClient retrieves the value with the specified key from
// the Client map field of NokiaConf_Configure_Groups_Group_Ipsec_ClientDb. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) GetClient(Id NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Client[key]; ok {
		return lm
	}
	return nil
}

// DeleteClient deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_ClientDb. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) DeleteClient(Id NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Id_Union) {
	key := Id

	delete(t.Client, key)
}

// AppendClient appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client struct to the
// list Client of NokiaConf_Configure_Groups_Group_Ipsec_ClientDb. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) AppendClient(v *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Client == nil {
		t.Client = make(map[NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client)
	}

	if _, ok := t.Client[key]; ok {
		return fmt.Errorf("duplicate key for list Client %v", key)
	}

	t.Client[key] = v
	return nil
}

// GetOrCreateMatchList retrieves the value of the MatchList field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) GetOrCreateMatchList() *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList {
	if t.MatchList != nil {
		return t.MatchList
	}
	t.MatchList = &NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList{}
	return t.MatchList
}

// GetMatchList returns the value of the MatchList struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_ClientDb. If the receiver or the field MatchList is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) GetMatchList() *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList {
	if t != nil && t.MatchList != nil {
		return t.MatchList
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	t.MatchList.PopulateDefaults()
	for _, e := range t.Client {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_ClientDb"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_ClientDb.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client represents the /nokia-conf/configure/groups/group/ipsec/client-db/client YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client struct {
	AdminState         E_NokiaTypesSros_AdminState                                            `path:"admin-state" module:"nokia-conf"`
	ClientName         *string                                                                `path:"client-name" module:"nokia-conf"`
	Credential         *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential     `path:"credential" module:"nokia-conf"`
	Id                 NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Id_Union        `path:"id" module:"nokia-conf"`
	Identification     *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification `path:"identification" module:"nokia-conf"`
	PrivateInterface   *string                                                                `path:"private-interface" module:"nokia-conf"`
	PrivateServiceName *string                                                                `path:"private-service-name" module:"nokia-conf"`
	TsList             *string                                                                `path:"ts-list" module:"nokia-conf"`
	TunnelTemplate     *uint32                                                                `path:"tunnel-template" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) IsYANGGoStruct() {}

// GetOrCreateCredential retrieves the value of the Credential field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) GetOrCreateCredential() *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential {
	if t.Credential != nil {
		return t.Credential
	}
	t.Credential = &NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential{}
	return t.Credential
}

// GetOrCreateIdentification retrieves the value of the Identification field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) GetOrCreateIdentification() *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification {
	if t.Identification != nil {
		return t.Identification
	}
	t.Identification = &NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification{}
	return t.Identification
}

// GetCredential returns the value of the Credential struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client. If the receiver or the field Credential is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) GetCredential() *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential {
	if t != nil && t.Credential != nil {
		return t.Credential
	}
	return nil
}

// GetIdentification returns the value of the Identification struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client. If the receiver or the field Identification is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) GetIdentification() *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification {
	if t != nil && t.Identification != nil {
		return t.Identification
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetClientName retrieves the value of the leaf ClientName from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClientName is set, it can
// safely use t.GetClientName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClientName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) GetClientName() string {
	if t == nil || t.ClientName == nil {
		return ""
	}
	return *t.ClientName
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) GetId() NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// GetPrivateInterface retrieves the value of the leaf PrivateInterface from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrivateInterface is set, it can
// safely use t.GetPrivateInterface() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrivateInterface == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) GetPrivateInterface() string {
	if t == nil || t.PrivateInterface == nil {
		return ""
	}
	return *t.PrivateInterface
}

// GetPrivateServiceName retrieves the value of the leaf PrivateServiceName from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrivateServiceName is set, it can
// safely use t.GetPrivateServiceName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrivateServiceName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) GetPrivateServiceName() string {
	if t == nil || t.PrivateServiceName == nil {
		return ""
	}
	return *t.PrivateServiceName
}

// GetTsList retrieves the value of the leaf TsList from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TsList is set, it can
// safely use t.GetTsList() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TsList == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) GetTsList() string {
	if t == nil || t.TsList == nil {
		return ""
	}
	return *t.TsList
}

// GetTunnelTemplate retrieves the value of the leaf TunnelTemplate from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TunnelTemplate is set, it can
// safely use t.GetTunnelTemplate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TunnelTemplate == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) GetTunnelTemplate() uint32 {
	if t == nil || t.TunnelTemplate == nil {
		return 0
	}
	return *t.TunnelTemplate
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	t.Credential.PopulateDefaults()
	t.Identification.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential represents the /nokia-conf/configure/groups/group/ipsec/client-db/client/credential YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential struct {
	PreSharedKey *string `path:"pre-shared-key" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential) IsYANGGoStruct() {}

// GetPreSharedKey retrieves the value of the leaf PreSharedKey from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreSharedKey is set, it can
// safely use t.GetPreSharedKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreSharedKey == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential) GetPreSharedKey() string {
	if t == nil || t.PreSharedKey == nil {
		return ""
	}
	return *t.PreSharedKey
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Credential) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification represents the /nokia-conf/configure/groups/group/ipsec/client-db/client/identification YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification struct {
	Idi          *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi          `path:"idi" module:"nokia-conf" yangPresence:"true"`
	PeerIpPrefix *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix `path:"peer-ip-prefix" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification) IsYANGGoStruct() {}

// GetOrCreateIdi retrieves the value of the Idi field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification) GetOrCreateIdi() *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi {
	if t.Idi != nil {
		return t.Idi
	}
	t.Idi = &NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi{}
	return t.Idi
}

// GetOrCreatePeerIpPrefix retrieves the value of the PeerIpPrefix field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification) GetOrCreatePeerIpPrefix() *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix {
	if t.PeerIpPrefix != nil {
		return t.PeerIpPrefix
	}
	t.PeerIpPrefix = &NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix{}
	return t.PeerIpPrefix
}

// GetIdi returns the value of the Idi struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification. If the receiver or the field Idi is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification) GetIdi() *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi {
	if t != nil && t.Idi != nil {
		return t.Idi
	}
	return nil
}

// GetPeerIpPrefix returns the value of the PeerIpPrefix struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification. If the receiver or the field PeerIpPrefix is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification) GetPeerIpPrefix() *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix {
	if t != nil && t.PeerIpPrefix != nil {
		return t.PeerIpPrefix
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Idi.PopulateDefaults()
	t.PeerIpPrefix.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi represents the /nokia-conf/configure/groups/group/ipsec/client-db/client/identification/idi YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi struct {
	Any           *bool   `path:"any" module:"nokia-conf"`
	Fqdn          *string `path:"fqdn" module:"nokia-conf"`
	FqdnSuffix    *string `path:"fqdn-suffix" module:"nokia-conf"`
	Ipv4Prefix    *string `path:"ipv4-prefix" module:"nokia-conf"`
	Ipv4PrefixAny *bool   `path:"ipv4-prefix-any" module:"nokia-conf"`
	Ipv6Prefix    *string `path:"ipv6-prefix" module:"nokia-conf"`
	Ipv6PrefixAny *bool   `path:"ipv6-prefix-any" module:"nokia-conf"`
	Rfc822        *string `path:"rfc822" module:"nokia-conf"`
	Rfc822Suffix  *string `path:"rfc822-suffix" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) IsYANGGoStruct() {}

// GetAny retrieves the value of the leaf Any from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Any is set, it can
// safely use t.GetAny() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Any == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) GetAny() bool {
	if t == nil || t.Any == nil {
		return false
	}
	return *t.Any
}

// GetFqdn retrieves the value of the leaf Fqdn from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fqdn is set, it can
// safely use t.GetFqdn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fqdn == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) GetFqdn() string {
	if t == nil || t.Fqdn == nil {
		return ""
	}
	return *t.Fqdn
}

// GetFqdnSuffix retrieves the value of the leaf FqdnSuffix from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FqdnSuffix is set, it can
// safely use t.GetFqdnSuffix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FqdnSuffix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) GetFqdnSuffix() string {
	if t == nil || t.FqdnSuffix == nil {
		return ""
	}
	return *t.FqdnSuffix
}

// GetIpv4Prefix retrieves the value of the leaf Ipv4Prefix from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Prefix is set, it can
// safely use t.GetIpv4Prefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Prefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) GetIpv4Prefix() string {
	if t == nil || t.Ipv4Prefix == nil {
		return ""
	}
	return *t.Ipv4Prefix
}

// GetIpv4PrefixAny retrieves the value of the leaf Ipv4PrefixAny from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4PrefixAny is set, it can
// safely use t.GetIpv4PrefixAny() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4PrefixAny == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) GetIpv4PrefixAny() bool {
	if t == nil || t.Ipv4PrefixAny == nil {
		return false
	}
	return *t.Ipv4PrefixAny
}

// GetIpv6Prefix retrieves the value of the leaf Ipv6Prefix from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Prefix is set, it can
// safely use t.GetIpv6Prefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Prefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) GetIpv6Prefix() string {
	if t == nil || t.Ipv6Prefix == nil {
		return ""
	}
	return *t.Ipv6Prefix
}

// GetIpv6PrefixAny retrieves the value of the leaf Ipv6PrefixAny from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6PrefixAny is set, it can
// safely use t.GetIpv6PrefixAny() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6PrefixAny == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) GetIpv6PrefixAny() bool {
	if t == nil || t.Ipv6PrefixAny == nil {
		return false
	}
	return *t.Ipv6PrefixAny
}

// GetRfc822 retrieves the value of the leaf Rfc822 from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Rfc822 is set, it can
// safely use t.GetRfc822() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Rfc822 == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) GetRfc822() string {
	if t == nil || t.Rfc822 == nil {
		return ""
	}
	return *t.Rfc822
}

// GetRfc822Suffix retrieves the value of the leaf Rfc822Suffix from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Rfc822Suffix is set, it can
// safely use t.GetRfc822Suffix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Rfc822Suffix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) GetRfc822Suffix() string {
	if t == nil || t.Rfc822Suffix == nil {
		return ""
	}
	return *t.Rfc822Suffix
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_Idi) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix represents the /nokia-conf/configure/groups/group/ipsec/client-db/client/identification/peer-ip-prefix YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix struct {
	IpPrefix *string `path:"ip-prefix" module:"nokia-conf"`
	Ipv4Only *bool   `path:"ipv4-only" module:"nokia-conf"`
	Ipv6Only *bool   `path:"ipv6-only" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix) IsYANGGoStruct() {
}

// GetIpPrefix retrieves the value of the leaf IpPrefix from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpPrefix is set, it can
// safely use t.GetIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpPrefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix) GetIpPrefix() string {
	if t == nil || t.IpPrefix == nil {
		return ""
	}
	return *t.IpPrefix
}

// GetIpv4Only retrieves the value of the leaf Ipv4Only from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Only is set, it can
// safely use t.GetIpv4Only() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Only == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix) GetIpv4Only() bool {
	if t == nil || t.Ipv4Only == nil {
		return false
	}
	return *t.Ipv4Only
}

// GetIpv6Only retrieves the value of the leaf Ipv6Only from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Only is set, it can
// safely use t.GetIpv6Only() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Only == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix) GetIpv6Only() bool {
	if t == nil || t.Ipv6Only == nil {
		return false
	}
	return *t.Ipv6Only
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_Client_Identification_PeerIpPrefix) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList represents the /nokia-conf/configure/groups/group/ipsec/client-db/match-list YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList struct {
	Idi          *bool `path:"idi" module:"nokia-conf"`
	PeerIpPrefix *bool `path:"peer-ip-prefix" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList) IsYANGGoStruct() {}

// GetIdi retrieves the value of the leaf Idi from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Idi is set, it can
// safely use t.GetIdi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Idi == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList) GetIdi() bool {
	if t == nil || t.Idi == nil {
		return false
	}
	return *t.Idi
}

// GetPeerIpPrefix retrieves the value of the leaf PeerIpPrefix from the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PeerIpPrefix is set, it can
// safely use t.GetPeerIpPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PeerIpPrefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList) GetPeerIpPrefix() bool {
	if t == nil || t.PeerIpPrefix == nil {
		return false
	}
	return *t.PeerIpPrefix
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Idi == nil {
		var v bool = false
		t.Idi = &v
	}
	if t.PeerIpPrefix == nil {
		var v bool = false
		t.PeerIpPrefix = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList.
func (*NokiaConf_Configure_Groups_Group_Ipsec_ClientDb_MatchList) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy represents the /nokia-conf/configure/groups/group/ipsec/ike-policy YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy struct {
	Description                  *string                                                                        `path:"description" module:"nokia-conf"`
	Dpd                          *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd                          `path:"dpd" module:"nokia-conf" yangPresence:"true"`
	Id                           NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Id_Union                      `path:"id" module:"nokia-conf"`
	IkeTransform                 []uint32                                                                       `path:"ike-transform" module:"nokia-conf"`
	IkeVersion_1                 *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1                 `path:"ike-version-1" module:"nokia-conf"`
	IkeVersion_2                 *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2                 `path:"ike-version-2" module:"nokia-conf" yangPresence:"true"`
	IpsecLifetime                *uint32                                                                        `path:"ipsec-lifetime" module:"nokia-conf"`
	LimitInitExchange            *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange            `path:"limit-init-exchange" module:"nokia-conf"`
	Lockout                      *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout                      `path:"lockout" module:"nokia-conf" yangPresence:"true"`
	MatchPeerIdToCert            *bool                                                                          `path:"match-peer-id-to-cert" module:"nokia-conf"`
	NatTraversal                 *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal                 `path:"nat-traversal" module:"nokia-conf" yangPresence:"true"`
	Pfs                          *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs                          `path:"pfs" module:"nokia-conf" yangPresence:"true"`
	RelayUnsolicitedCfgAttribute *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute `path:"relay-unsolicited-cfg-attribute" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) IsYANGGoStruct() {}

// GetOrCreateDpd retrieves the value of the Dpd field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetOrCreateDpd() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd {
	if t.Dpd != nil {
		return t.Dpd
	}
	t.Dpd = &NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd{}
	return t.Dpd
}

// GetOrCreateIkeVersion_1 retrieves the value of the IkeVersion_1 field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetOrCreateIkeVersion_1() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1 {
	if t.IkeVersion_1 != nil {
		return t.IkeVersion_1
	}
	t.IkeVersion_1 = &NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1{}
	return t.IkeVersion_1
}

// GetOrCreateIkeVersion_2 retrieves the value of the IkeVersion_2 field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetOrCreateIkeVersion_2() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2 {
	if t.IkeVersion_2 != nil {
		return t.IkeVersion_2
	}
	t.IkeVersion_2 = &NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2{}
	return t.IkeVersion_2
}

// GetOrCreateLimitInitExchange retrieves the value of the LimitInitExchange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetOrCreateLimitInitExchange() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange {
	if t.LimitInitExchange != nil {
		return t.LimitInitExchange
	}
	t.LimitInitExchange = &NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange{}
	return t.LimitInitExchange
}

// GetOrCreateLockout retrieves the value of the Lockout field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetOrCreateLockout() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout {
	if t.Lockout != nil {
		return t.Lockout
	}
	t.Lockout = &NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout{}
	return t.Lockout
}

// GetOrCreateNatTraversal retrieves the value of the NatTraversal field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetOrCreateNatTraversal() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal {
	if t.NatTraversal != nil {
		return t.NatTraversal
	}
	t.NatTraversal = &NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal{}
	return t.NatTraversal
}

// GetOrCreatePfs retrieves the value of the Pfs field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetOrCreatePfs() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs {
	if t.Pfs != nil {
		return t.Pfs
	}
	t.Pfs = &NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs{}
	return t.Pfs
}

// GetOrCreateRelayUnsolicitedCfgAttribute retrieves the value of the RelayUnsolicitedCfgAttribute field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetOrCreateRelayUnsolicitedCfgAttribute() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute {
	if t.RelayUnsolicitedCfgAttribute != nil {
		return t.RelayUnsolicitedCfgAttribute
	}
	t.RelayUnsolicitedCfgAttribute = &NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute{}
	return t.RelayUnsolicitedCfgAttribute
}

// GetDpd returns the value of the Dpd struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy. If the receiver or the field Dpd is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetDpd() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd {
	if t != nil && t.Dpd != nil {
		return t.Dpd
	}
	return nil
}

// GetIkeVersion_1 returns the value of the IkeVersion_1 struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy. If the receiver or the field IkeVersion_1 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetIkeVersion_1() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1 {
	if t != nil && t.IkeVersion_1 != nil {
		return t.IkeVersion_1
	}
	return nil
}

// GetIkeVersion_2 returns the value of the IkeVersion_2 struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy. If the receiver or the field IkeVersion_2 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetIkeVersion_2() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2 {
	if t != nil && t.IkeVersion_2 != nil {
		return t.IkeVersion_2
	}
	return nil
}

// GetLimitInitExchange returns the value of the LimitInitExchange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy. If the receiver or the field LimitInitExchange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetLimitInitExchange() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange {
	if t != nil && t.LimitInitExchange != nil {
		return t.LimitInitExchange
	}
	return nil
}

// GetLockout returns the value of the Lockout struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy. If the receiver or the field Lockout is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetLockout() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout {
	if t != nil && t.Lockout != nil {
		return t.Lockout
	}
	return nil
}

// GetNatTraversal returns the value of the NatTraversal struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy. If the receiver or the field NatTraversal is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetNatTraversal() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal {
	if t != nil && t.NatTraversal != nil {
		return t.NatTraversal
	}
	return nil
}

// GetPfs returns the value of the Pfs struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy. If the receiver or the field Pfs is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetPfs() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs {
	if t != nil && t.Pfs != nil {
		return t.Pfs
	}
	return nil
}

// GetRelayUnsolicitedCfgAttribute returns the value of the RelayUnsolicitedCfgAttribute struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy. If the receiver or the field RelayUnsolicitedCfgAttribute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetRelayUnsolicitedCfgAttribute() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute {
	if t != nil && t.RelayUnsolicitedCfgAttribute != nil {
		return t.RelayUnsolicitedCfgAttribute
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetId() NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// GetIkeTransform retrieves the value of the leaf IkeTransform from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IkeTransform is set, it can
// safely use t.GetIkeTransform() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IkeTransform == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetIkeTransform() []uint32 {
	if t == nil || t.IkeTransform == nil {
		return nil
	}
	return t.IkeTransform
}

// GetIpsecLifetime retrieves the value of the leaf IpsecLifetime from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpsecLifetime is set, it can
// safely use t.GetIpsecLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpsecLifetime == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetIpsecLifetime() uint32 {
	if t == nil || t.IpsecLifetime == nil {
		return 3600
	}
	return *t.IpsecLifetime
}

// GetMatchPeerIdToCert retrieves the value of the leaf MatchPeerIdToCert from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MatchPeerIdToCert is set, it can
// safely use t.GetMatchPeerIdToCert() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MatchPeerIdToCert == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) GetMatchPeerIdToCert() bool {
	if t == nil || t.MatchPeerIdToCert == nil {
		return false
	}
	return *t.MatchPeerIdToCert
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.IpsecLifetime == nil {
		var v uint32 = 3600
		t.IpsecLifetime = &v
	}
	if t.MatchPeerIdToCert == nil {
		var v bool = false
		t.MatchPeerIdToCert = &v
	}
	t.Dpd.PopulateDefaults()
	t.IkeVersion_1.PopulateDefaults()
	t.IkeVersion_2.PopulateDefaults()
	t.LimitInitExchange.PopulateDefaults()
	t.Lockout.PopulateDefaults()
	t.NatTraversal.PopulateDefaults()
	t.Pfs.PopulateDefaults()
	t.RelayUnsolicitedCfgAttribute.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd represents the /nokia-conf/configure/groups/group/ipsec/ike-policy/dpd YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd struct {
	Interval   *uint32 `path:"interval" module:"nokia-conf"`
	MaxRetries *uint32 `path:"max-retries" module:"nokia-conf"`
	ReplyOnly  *bool   `path:"reply-only" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd) IsYANGGoStruct() {}

// GetInterval retrieves the value of the leaf Interval from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 30
	}
	return *t.Interval
}

// GetMaxRetries retrieves the value of the leaf MaxRetries from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxRetries is set, it can
// safely use t.GetMaxRetries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxRetries == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd) GetMaxRetries() uint32 {
	if t == nil || t.MaxRetries == nil {
		return 3
	}
	return *t.MaxRetries
}

// GetReplyOnly retrieves the value of the leaf ReplyOnly from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReplyOnly is set, it can
// safely use t.GetReplyOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReplyOnly == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd) GetReplyOnly() bool {
	if t == nil || t.ReplyOnly == nil {
		return false
	}
	return *t.ReplyOnly
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Interval == nil {
		var v uint32 = 30
		t.Interval = &v
	}
	if t.MaxRetries == nil {
		var v uint32 = 3
		t.MaxRetries = &v
	}
	if t.ReplyOnly == nil {
		var v bool = false
		t.ReplyOnly = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Dpd) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1 represents the /nokia-conf/configure/groups/group/ipsec/ike-policy/ike-version-1 YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1 struct {
	AuthMethod               E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1_AuthMethod    `path:"auth-method" module:"nokia-conf"`
	IkeMode                  E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1_IkeMode       `path:"ike-mode" module:"nokia-conf"`
	OwnAuthMethod            E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1_OwnAuthMethod `path:"own-auth-method" module:"nokia-conf"`
	Ph1ResponderDeleteNotify *bool                                                                         `path:"ph1-responder-delete-notify" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1) IsYANGGoStruct() {}

// GetAuthMethod retrieves the value of the leaf AuthMethod from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthMethod is set, it can
// safely use t.GetAuthMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthMethod == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1) GetAuthMethod() E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1_AuthMethod {
	if t == nil || t.AuthMethod == 0 {
		return NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1_AuthMethod_psk
	}
	return t.AuthMethod
}

// GetIkeMode retrieves the value of the leaf IkeMode from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IkeMode is set, it can
// safely use t.GetIkeMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IkeMode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1) GetIkeMode() E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1_IkeMode {
	if t == nil || t.IkeMode == 0 {
		return NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1_IkeMode_main
	}
	return t.IkeMode
}

// GetOwnAuthMethod retrieves the value of the leaf OwnAuthMethod from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OwnAuthMethod is set, it can
// safely use t.GetOwnAuthMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OwnAuthMethod == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1) GetOwnAuthMethod() E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1_OwnAuthMethod {
	if t == nil || t.OwnAuthMethod == 0 {
		return NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1_OwnAuthMethod_symmetric
	}
	return t.OwnAuthMethod
}

// GetPh1ResponderDeleteNotify retrieves the value of the leaf Ph1ResponderDeleteNotify from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ph1ResponderDeleteNotify is set, it can
// safely use t.GetPh1ResponderDeleteNotify() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ph1ResponderDeleteNotify == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1) GetPh1ResponderDeleteNotify() bool {
	if t == nil || t.Ph1ResponderDeleteNotify == nil {
		return true
	}
	return *t.Ph1ResponderDeleteNotify
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AuthMethod == 0 {
		t.AuthMethod = NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1_AuthMethod_psk
	}
	if t.IkeMode == 0 {
		t.IkeMode = NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1_IkeMode_main
	}
	if t.OwnAuthMethod == 0 {
		t.OwnAuthMethod = NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1_OwnAuthMethod_symmetric
	}
	if t.Ph1ResponderDeleteNotify == nil {
		var v bool = true
		t.Ph1ResponderDeleteNotify = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_1) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2 represents the /nokia-conf/configure/groups/group/ipsec/ike-policy/ike-version-2 YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2 struct {
	AuthMethod             E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_AuthMethod       `path:"auth-method" module:"nokia-conf"`
	AutoEapMethod          E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_AutoEapMethod    `path:"auto-eap-method" module:"nokia-conf"`
	Ikev2Fragment          *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment     `path:"ikev2-fragment" module:"nokia-conf" yangPresence:"true"`
	OwnAuthMethod          E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_OwnAuthMethod    `path:"own-auth-method" module:"nokia-conf"`
	OwnAutoEapMethod       E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_OwnAutoEapMethod `path:"own-auto-eap-method" module:"nokia-conf"`
	SendIdrAfterEapSuccess *bool                                                                            `path:"send-idr-after-eap-success" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) IsYANGGoStruct() {}

// GetOrCreateIkev2Fragment retrieves the value of the Ikev2Fragment field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) GetOrCreateIkev2Fragment() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment {
	if t.Ikev2Fragment != nil {
		return t.Ikev2Fragment
	}
	t.Ikev2Fragment = &NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment{}
	return t.Ikev2Fragment
}

// GetIkev2Fragment returns the value of the Ikev2Fragment struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2. If the receiver or the field Ikev2Fragment is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) GetIkev2Fragment() *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment {
	if t != nil && t.Ikev2Fragment != nil {
		return t.Ikev2Fragment
	}
	return nil
}

// GetAuthMethod retrieves the value of the leaf AuthMethod from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AuthMethod is set, it can
// safely use t.GetAuthMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AuthMethod == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) GetAuthMethod() E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_AuthMethod {
	if t == nil || t.AuthMethod == 0 {
		return NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_AuthMethod_psk
	}
	return t.AuthMethod
}

// GetAutoEapMethod retrieves the value of the leaf AutoEapMethod from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutoEapMethod is set, it can
// safely use t.GetAutoEapMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutoEapMethod == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) GetAutoEapMethod() E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_AutoEapMethod {
	if t == nil || t.AutoEapMethod == 0 {
		return NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_AutoEapMethod_cert
	}
	return t.AutoEapMethod
}

// GetOwnAuthMethod retrieves the value of the leaf OwnAuthMethod from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OwnAuthMethod is set, it can
// safely use t.GetOwnAuthMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OwnAuthMethod == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) GetOwnAuthMethod() E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_OwnAuthMethod {
	if t == nil || t.OwnAuthMethod == 0 {
		return NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_OwnAuthMethod_symmetric
	}
	return t.OwnAuthMethod
}

// GetOwnAutoEapMethod retrieves the value of the leaf OwnAutoEapMethod from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OwnAutoEapMethod is set, it can
// safely use t.GetOwnAutoEapMethod() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OwnAutoEapMethod == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) GetOwnAutoEapMethod() E_NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_OwnAutoEapMethod {
	if t == nil || t.OwnAutoEapMethod == 0 {
		return NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_OwnAutoEapMethod_cert
	}
	return t.OwnAutoEapMethod
}

// GetSendIdrAfterEapSuccess retrieves the value of the leaf SendIdrAfterEapSuccess from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SendIdrAfterEapSuccess is set, it can
// safely use t.GetSendIdrAfterEapSuccess() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SendIdrAfterEapSuccess == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) GetSendIdrAfterEapSuccess() bool {
	if t == nil || t.SendIdrAfterEapSuccess == nil {
		return true
	}
	return *t.SendIdrAfterEapSuccess
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AuthMethod == 0 {
		t.AuthMethod = NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_AuthMethod_psk
	}
	if t.AutoEapMethod == 0 {
		t.AutoEapMethod = NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_AutoEapMethod_cert
	}
	if t.OwnAuthMethod == 0 {
		t.OwnAuthMethod = NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_OwnAuthMethod_symmetric
	}
	if t.OwnAutoEapMethod == 0 {
		t.OwnAutoEapMethod = NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_OwnAutoEapMethod_cert
	}
	if t.SendIdrAfterEapSuccess == nil {
		var v bool = true
		t.SendIdrAfterEapSuccess = &v
	}
	t.Ikev2Fragment.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment represents the /nokia-conf/configure/groups/group/ipsec/ike-policy/ike-version-2/ikev2-fragment YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment struct {
	Mtu               *uint32 `path:"mtu" module:"nokia-conf"`
	ReassemblyTimeout *uint32 `path:"reassembly-timeout" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment) IsYANGGoStruct() {
}

// GetMtu retrieves the value of the leaf Mtu from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mtu is set, it can
// safely use t.GetMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mtu == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment) GetMtu() uint32 {
	if t == nil || t.Mtu == nil {
		return 1500
	}
	return *t.Mtu
}

// GetReassemblyTimeout retrieves the value of the leaf ReassemblyTimeout from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReassemblyTimeout is set, it can
// safely use t.GetReassemblyTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReassemblyTimeout == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment) GetReassemblyTimeout() uint32 {
	if t == nil || t.ReassemblyTimeout == nil {
		return 2
	}
	return *t.ReassemblyTimeout
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mtu == nil {
		var v uint32 = 1500
		t.Mtu = &v
	}
	if t.ReassemblyTimeout == nil {
		var v uint32 = 2
		t.ReassemblyTimeout = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_IkeVersion_2_Ikev2Fragment) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange represents the /nokia-conf/configure/groups/group/ipsec/ike-policy/limit-init-exchange YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange struct {
	AdminState                E_NokiaTypesSros_AdminState                                                                        `path:"admin-state" module:"nokia-conf"`
	ReducedMaxExchangeTimeout NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange_ReducedMaxExchangeTimeout_Union `path:"reduced-max-exchange-timeout" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetReducedMaxExchangeTimeout retrieves the value of the leaf ReducedMaxExchangeTimeout from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReducedMaxExchangeTimeout is set, it can
// safely use t.GetReducedMaxExchangeTimeout() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReducedMaxExchangeTimeout == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange) GetReducedMaxExchangeTimeout() NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange_ReducedMaxExchangeTimeout_Union {
	if t == nil || t.ReducedMaxExchangeTimeout == nil {
		return UnionUint32(2)
	}
	return t.ReducedMaxExchangeTimeout
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	if t.ReducedMaxExchangeTimeout == nil {
		t.ReducedMaxExchangeTimeout = UnionUint32(2)
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_LimitInitExchange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout represents the /nokia-conf/configure/groups/group/ipsec/ike-policy/lockout YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout struct {
	Block          NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout_Block_Union `path:"block" module:"nokia-conf"`
	Duration       *uint32                                                              `path:"duration" module:"nokia-conf"`
	FailedAttempts *uint32                                                              `path:"failed-attempts" module:"nokia-conf"`
	MaxPortPerIp   *uint32                                                              `path:"max-port-per-ip" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout) IsYANGGoStruct() {}

// GetBlock retrieves the value of the leaf Block from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Block is set, it can
// safely use t.GetBlock() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Block == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout) GetBlock() NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout_Block_Union {
	if t == nil || t.Block == nil {
		return UnionUint32(10)
	}
	return t.Block
}

// GetDuration retrieves the value of the leaf Duration from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Duration is set, it can
// safely use t.GetDuration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Duration == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout) GetDuration() uint32 {
	if t == nil || t.Duration == nil {
		return 5
	}
	return *t.Duration
}

// GetFailedAttempts retrieves the value of the leaf FailedAttempts from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FailedAttempts is set, it can
// safely use t.GetFailedAttempts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FailedAttempts == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout) GetFailedAttempts() uint32 {
	if t == nil || t.FailedAttempts == nil {
		return 3
	}
	return *t.FailedAttempts
}

// GetMaxPortPerIp retrieves the value of the leaf MaxPortPerIp from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPortPerIp is set, it can
// safely use t.GetMaxPortPerIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPortPerIp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout) GetMaxPortPerIp() uint32 {
	if t == nil || t.MaxPortPerIp == nil {
		return 16
	}
	return *t.MaxPortPerIp
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Block == nil {
		t.Block = UnionUint32(10)
	}
	if t.Duration == nil {
		var v uint32 = 5
		t.Duration = &v
	}
	if t.FailedAttempts == nil {
		var v uint32 = 3
		t.FailedAttempts = &v
	}
	if t.MaxPortPerIp == nil {
		var v uint32 = 16
		t.MaxPortPerIp = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Lockout) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal represents the /nokia-conf/configure/groups/group/ipsec/ike-policy/nat-traversal YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal struct {
	Force             *bool   `path:"force" module:"nokia-conf"`
	ForceKeepAlive    *bool   `path:"force-keep-alive" module:"nokia-conf"`
	KeepAliveInterval *uint32 `path:"keep-alive-interval" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal) IsYANGGoStruct() {}

// GetForce retrieves the value of the leaf Force from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Force is set, it can
// safely use t.GetForce() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Force == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal) GetForce() bool {
	if t == nil || t.Force == nil {
		return false
	}
	return *t.Force
}

// GetForceKeepAlive retrieves the value of the leaf ForceKeepAlive from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForceKeepAlive is set, it can
// safely use t.GetForceKeepAlive() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForceKeepAlive == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal) GetForceKeepAlive() bool {
	if t == nil || t.ForceKeepAlive == nil {
		return true
	}
	return *t.ForceKeepAlive
}

// GetKeepAliveInterval retrieves the value of the leaf KeepAliveInterval from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if KeepAliveInterval is set, it can
// safely use t.GetKeepAliveInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.KeepAliveInterval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal) GetKeepAliveInterval() uint32 {
	if t == nil || t.KeepAliveInterval == nil {
		return 0
	}
	return *t.KeepAliveInterval
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Force == nil {
		var v bool = false
		t.Force = &v
	}
	if t.ForceKeepAlive == nil {
		var v bool = true
		t.ForceKeepAlive = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_NatTraversal) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs represents the /nokia-conf/configure/groups/group/ipsec/ike-policy/pfs YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs struct {
	DhGroup E_NokiaTypesIpsec_DhGroup `path:"dh-group" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs) IsYANGGoStruct() {}

// GetDhGroup retrieves the value of the leaf DhGroup from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhGroup is set, it can
// safely use t.GetDhGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhGroup == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs) GetDhGroup() E_NokiaTypesIpsec_DhGroup {
	if t == nil || t.DhGroup == 0 {
		return NokiaTypesIpsec_DhGroup_group_2
	}
	return t.DhGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DhGroup == 0 {
		t.DhGroup = NokiaTypesIpsec_DhGroup_group_2
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_Pfs) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute represents the /nokia-conf/configure/groups/group/ipsec/ike-policy/relay-unsolicited-cfg-attribute YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute struct {
	InternalIp4Address *bool `path:"internal-ip4-address" module:"nokia-conf"`
	InternalIp4Dns     *bool `path:"internal-ip4-dns" module:"nokia-conf"`
	InternalIp4Netmask *bool `path:"internal-ip4-netmask" module:"nokia-conf"`
	InternalIp6Address *bool `path:"internal-ip6-address" module:"nokia-conf"`
	InternalIp6Dns     *bool `path:"internal-ip6-dns" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute) IsYANGGoStruct() {
}

// GetInternalIp4Address retrieves the value of the leaf InternalIp4Address from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InternalIp4Address is set, it can
// safely use t.GetInternalIp4Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InternalIp4Address == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute) GetInternalIp4Address() bool {
	if t == nil || t.InternalIp4Address == nil {
		return false
	}
	return *t.InternalIp4Address
}

// GetInternalIp4Dns retrieves the value of the leaf InternalIp4Dns from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InternalIp4Dns is set, it can
// safely use t.GetInternalIp4Dns() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InternalIp4Dns == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute) GetInternalIp4Dns() bool {
	if t == nil || t.InternalIp4Dns == nil {
		return false
	}
	return *t.InternalIp4Dns
}

// GetInternalIp4Netmask retrieves the value of the leaf InternalIp4Netmask from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InternalIp4Netmask is set, it can
// safely use t.GetInternalIp4Netmask() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InternalIp4Netmask == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute) GetInternalIp4Netmask() bool {
	if t == nil || t.InternalIp4Netmask == nil {
		return false
	}
	return *t.InternalIp4Netmask
}

// GetInternalIp6Address retrieves the value of the leaf InternalIp6Address from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InternalIp6Address is set, it can
// safely use t.GetInternalIp6Address() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InternalIp6Address == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute) GetInternalIp6Address() bool {
	if t == nil || t.InternalIp6Address == nil {
		return false
	}
	return *t.InternalIp6Address
}

// GetInternalIp6Dns retrieves the value of the leaf InternalIp6Dns from the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InternalIp6Dns is set, it can
// safely use t.GetInternalIp6Dns() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InternalIp6Dns == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute) GetInternalIp6Dns() bool {
	if t == nil || t.InternalIp6Dns == nil {
		return false
	}
	return *t.InternalIp6Dns
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.InternalIp4Address == nil {
		var v bool = false
		t.InternalIp4Address = &v
	}
	if t.InternalIp4Dns == nil {
		var v bool = false
		t.InternalIp4Dns = &v
	}
	if t.InternalIp4Netmask == nil {
		var v bool = false
		t.InternalIp4Netmask = &v
	}
	if t.InternalIp6Address == nil {
		var v bool = false
		t.InternalIp6Address = &v
	}
	if t.InternalIp6Dns == nil {
		var v bool = false
		t.InternalIp6Dns = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkePolicy_RelayUnsolicitedCfgAttribute) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform represents the /nokia-conf/configure/groups/group/ipsec/ike-transform YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform struct {
	DhGroup                E_NokiaTypesIpsec_DhGroup                                    `path:"dh-group" module:"nokia-conf"`
	Id                     NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform_Id_Union `path:"id" module:"nokia-conf"`
	IkeAuthAlgorithm       E_NokiaTypesIpsec_IkeAuthAlgorithms                          `path:"ike-auth-algorithm" module:"nokia-conf"`
	IkeEncryptionAlgorithm E_NokiaTypesIpsec_IkeEncryptionAlgorithms                    `path:"ike-encryption-algorithm" module:"nokia-conf"`
	IkePrfAlgorithm        E_NokiaTypesIpsec_PrfAlgorithms                              `path:"ike-prf-algorithm" module:"nokia-conf"`
	IsakmpLifetime         *uint32                                                      `path:"isakmp-lifetime" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) IsYANGGoStruct() {}

// GetDhGroup retrieves the value of the leaf DhGroup from the NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DhGroup is set, it can
// safely use t.GetDhGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DhGroup == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) GetDhGroup() E_NokiaTypesIpsec_DhGroup {
	if t == nil || t.DhGroup == 0 {
		return NokiaTypesIpsec_DhGroup_group_2
	}
	return t.DhGroup
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) GetId() NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// GetIkeAuthAlgorithm retrieves the value of the leaf IkeAuthAlgorithm from the NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IkeAuthAlgorithm is set, it can
// safely use t.GetIkeAuthAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IkeAuthAlgorithm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) GetIkeAuthAlgorithm() E_NokiaTypesIpsec_IkeAuthAlgorithms {
	if t == nil || t.IkeAuthAlgorithm == 0 {
		return NokiaTypesIpsec_IkeAuthAlgorithms_sha_1
	}
	return t.IkeAuthAlgorithm
}

// GetIkeEncryptionAlgorithm retrieves the value of the leaf IkeEncryptionAlgorithm from the NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IkeEncryptionAlgorithm is set, it can
// safely use t.GetIkeEncryptionAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IkeEncryptionAlgorithm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) GetIkeEncryptionAlgorithm() E_NokiaTypesIpsec_IkeEncryptionAlgorithms {
	if t == nil || t.IkeEncryptionAlgorithm == 0 {
		return NokiaTypesIpsec_IkeEncryptionAlgorithms_aes_128
	}
	return t.IkeEncryptionAlgorithm
}

// GetIkePrfAlgorithm retrieves the value of the leaf IkePrfAlgorithm from the NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IkePrfAlgorithm is set, it can
// safely use t.GetIkePrfAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IkePrfAlgorithm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) GetIkePrfAlgorithm() E_NokiaTypesIpsec_PrfAlgorithms {
	if t == nil || t.IkePrfAlgorithm == 0 {
		return NokiaTypesIpsec_PrfAlgorithms_same_as_auth
	}
	return t.IkePrfAlgorithm
}

// GetIsakmpLifetime retrieves the value of the leaf IsakmpLifetime from the NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsakmpLifetime is set, it can
// safely use t.GetIsakmpLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsakmpLifetime == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) GetIsakmpLifetime() uint32 {
	if t == nil || t.IsakmpLifetime == nil {
		return 86400
	}
	return *t.IsakmpLifetime
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DhGroup == 0 {
		t.DhGroup = NokiaTypesIpsec_DhGroup_group_2
	}
	if t.IkeAuthAlgorithm == 0 {
		t.IkeAuthAlgorithm = NokiaTypesIpsec_IkeAuthAlgorithms_sha_1
	}
	if t.IkeEncryptionAlgorithm == 0 {
		t.IkeEncryptionAlgorithm = NokiaTypesIpsec_IkeEncryptionAlgorithms_aes_128
	}
	if t.IkePrfAlgorithm == 0 {
		t.IkePrfAlgorithm = NokiaTypesIpsec_PrfAlgorithms_same_as_auth
	}
	if t.IsakmpLifetime == nil {
		var v uint32 = 86400
		t.IsakmpLifetime = &v
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IkeTransform) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform represents the /nokia-conf/configure/groups/group/ipsec/ipsec-transform YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform struct {
	EspAuthAlgorithm       E_NokiaTypesIpsec_AuthAlgorithms                                   `path:"esp-auth-algorithm" module:"nokia-conf"`
	EspEncryptionAlgorithm E_NokiaTypesIpsec_EncryptionAlgorithms                             `path:"esp-encryption-algorithm" module:"nokia-conf"`
	ExtendedSequenceNumber *bool                                                              `path:"extended-sequence-number" module:"nokia-conf"`
	Id                     NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform_Id_Union     `path:"id" module:"nokia-conf"`
	IpsecLifetime          *uint32                                                            `path:"ipsec-lifetime" module:"nokia-conf"`
	PfsDhGroup             E_NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform_PfsDhGroup `path:"pfs-dh-group" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) IsYANGGoStruct() {}

// GetEspAuthAlgorithm retrieves the value of the leaf EspAuthAlgorithm from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EspAuthAlgorithm is set, it can
// safely use t.GetEspAuthAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EspAuthAlgorithm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) GetEspAuthAlgorithm() E_NokiaTypesIpsec_AuthAlgorithms {
	if t == nil || t.EspAuthAlgorithm == 0 {
		return NokiaTypesIpsec_AuthAlgorithms_sha_1
	}
	return t.EspAuthAlgorithm
}

// GetEspEncryptionAlgorithm retrieves the value of the leaf EspEncryptionAlgorithm from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EspEncryptionAlgorithm is set, it can
// safely use t.GetEspEncryptionAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EspEncryptionAlgorithm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) GetEspEncryptionAlgorithm() E_NokiaTypesIpsec_EncryptionAlgorithms {
	if t == nil || t.EspEncryptionAlgorithm == 0 {
		return NokiaTypesIpsec_EncryptionAlgorithms_aes_128
	}
	return t.EspEncryptionAlgorithm
}

// GetExtendedSequenceNumber retrieves the value of the leaf ExtendedSequenceNumber from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExtendedSequenceNumber is set, it can
// safely use t.GetExtendedSequenceNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExtendedSequenceNumber == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) GetExtendedSequenceNumber() bool {
	if t == nil || t.ExtendedSequenceNumber == nil {
		return false
	}
	return *t.ExtendedSequenceNumber
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) GetId() NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// GetIpsecLifetime retrieves the value of the leaf IpsecLifetime from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpsecLifetime is set, it can
// safely use t.GetIpsecLifetime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpsecLifetime == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) GetIpsecLifetime() uint32 {
	if t == nil || t.IpsecLifetime == nil {
		return 0
	}
	return *t.IpsecLifetime
}

// GetPfsDhGroup retrieves the value of the leaf PfsDhGroup from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PfsDhGroup is set, it can
// safely use t.GetPfsDhGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PfsDhGroup == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) GetPfsDhGroup() E_NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform_PfsDhGroup {
	if t == nil || t.PfsDhGroup == 0 {
		return 0
	}
	return t.PfsDhGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.EspAuthAlgorithm == 0 {
		t.EspAuthAlgorithm = NokiaTypesIpsec_AuthAlgorithms_sha_1
	}
	if t.EspEncryptionAlgorithm == 0 {
		t.EspEncryptionAlgorithm = NokiaTypesIpsec_EncryptionAlgorithms_aes_128
	}
	if t.ExtendedSequenceNumber == nil {
		var v bool = false
		t.ExtendedSequenceNumber = &v
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransform) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile represents the /nokia-conf/configure/groups/group/ipsec/ipsec-transport-mode-profile YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile struct {
	Description          *string                                                                                `path:"description" module:"nokia-conf"`
	KeyExchange          *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange          `path:"key-exchange" module:"nokia-conf"`
	MaxHistoryKeyRecords *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords `path:"max-history-key-records" module:"nokia-conf"`
	Name                 *string                                                                                `path:"name" module:"nokia-conf"`
	ReplayWindow         *uint32                                                                                `path:"replay-window" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) IsYANGGoStruct() {}

// GetOrCreateKeyExchange retrieves the value of the KeyExchange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) GetOrCreateKeyExchange() *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange {
	if t.KeyExchange != nil {
		return t.KeyExchange
	}
	t.KeyExchange = &NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange{}
	return t.KeyExchange
}

// GetOrCreateMaxHistoryKeyRecords retrieves the value of the MaxHistoryKeyRecords field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) GetOrCreateMaxHistoryKeyRecords() *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords {
	if t.MaxHistoryKeyRecords != nil {
		return t.MaxHistoryKeyRecords
	}
	t.MaxHistoryKeyRecords = &NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords{}
	return t.MaxHistoryKeyRecords
}

// GetKeyExchange returns the value of the KeyExchange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile. If the receiver or the field KeyExchange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) GetKeyExchange() *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange {
	if t != nil && t.KeyExchange != nil {
		return t.KeyExchange
	}
	return nil
}

// GetMaxHistoryKeyRecords returns the value of the MaxHistoryKeyRecords struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile. If the receiver or the field MaxHistoryKeyRecords is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) GetMaxHistoryKeyRecords() *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords {
	if t != nil && t.MaxHistoryKeyRecords != nil {
		return t.MaxHistoryKeyRecords
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetReplayWindow retrieves the value of the leaf ReplayWindow from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReplayWindow is set, it can
// safely use t.GetReplayWindow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReplayWindow == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) GetReplayWindow() uint32 {
	if t == nil || t.ReplayWindow == nil {
		return 0
	}
	return *t.ReplayWindow
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.KeyExchange.PopulateDefaults()
	t.MaxHistoryKeyRecords.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange represents the /nokia-conf/configure/groups/group/ipsec/ipsec-transport-mode-profile/key-exchange YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange struct {
	Dynamic *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic `path:"dynamic" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange) IsYANGGoStruct() {
}

// GetOrCreateDynamic retrieves the value of the Dynamic field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange) GetOrCreateDynamic() *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic {
	if t.Dynamic != nil {
		return t.Dynamic
	}
	t.Dynamic = &NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic{}
	return t.Dynamic
}

// GetDynamic returns the value of the Dynamic struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange. If the receiver or the field Dynamic is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange) GetDynamic() *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic {
	if t != nil && t.Dynamic != nil {
		return t.Dynamic
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Dynamic.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic represents the /nokia-conf/configure/groups/group/ipsec/ipsec-transport-mode-profile/key-exchange/dynamic YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic struct {
	AutoEstablish  *bool                                                                                      `path:"auto-establish" module:"nokia-conf"`
	Cert           *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert `path:"cert" module:"nokia-conf"`
	Id             *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id   `path:"id" module:"nokia-conf"`
	IkePolicy      *uint32                                                                                    `path:"ike-policy" module:"nokia-conf"`
	IpsecTransform []uint32                                                                                   `path:"ipsec-transform" module:"nokia-conf"`
	PreSharedKey   *string                                                                                    `path:"pre-shared-key" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) IsYANGGoStruct() {
}

// GetOrCreateCert retrieves the value of the Cert field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) GetOrCreateCert() *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert {
	if t.Cert != nil {
		return t.Cert
	}
	t.Cert = &NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert{}
	return t.Cert
}

// GetOrCreateId retrieves the value of the Id field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) GetOrCreateId() *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id {
	if t.Id != nil {
		return t.Id
	}
	t.Id = &NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id{}
	return t.Id
}

// GetCert returns the value of the Cert struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic. If the receiver or the field Cert is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) GetCert() *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert {
	if t != nil && t.Cert != nil {
		return t.Cert
	}
	return nil
}

// GetId returns the value of the Id struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic. If the receiver or the field Id is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) GetId() *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id {
	if t != nil && t.Id != nil {
		return t.Id
	}
	return nil
}

// GetAutoEstablish retrieves the value of the leaf AutoEstablish from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutoEstablish is set, it can
// safely use t.GetAutoEstablish() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutoEstablish == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) GetAutoEstablish() bool {
	if t == nil || t.AutoEstablish == nil {
		return false
	}
	return *t.AutoEstablish
}

// GetIkePolicy retrieves the value of the leaf IkePolicy from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IkePolicy is set, it can
// safely use t.GetIkePolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IkePolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) GetIkePolicy() uint32 {
	if t == nil || t.IkePolicy == nil {
		return 0
	}
	return *t.IkePolicy
}

// GetIpsecTransform retrieves the value of the leaf IpsecTransform from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpsecTransform is set, it can
// safely use t.GetIpsecTransform() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpsecTransform == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) GetIpsecTransform() []uint32 {
	if t == nil || t.IpsecTransform == nil {
		return nil
	}
	return t.IpsecTransform
}

// GetPreSharedKey retrieves the value of the leaf PreSharedKey from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PreSharedKey is set, it can
// safely use t.GetPreSharedKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PreSharedKey == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) GetPreSharedKey() string {
	if t == nil || t.PreSharedKey == nil {
		return ""
	}
	return *t.PreSharedKey
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AutoEstablish == nil {
		var v bool = false
		t.AutoEstablish = &v
	}
	t.Cert.PopulateDefaults()
	t.Id.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert represents the /nokia-conf/configure/groups/group/ipsec/ipsec-transport-mode-profile/key-exchange/dynamic/cert YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert struct {
	CertProfile        *string                                                                                                 `path:"cert-profile" module:"nokia-conf"`
	StatusVerify       *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify `path:"status-verify" module:"nokia-conf"`
	TrustAnchorProfile *string                                                                                                 `path:"trust-anchor-profile" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert) IsYANGGoStruct() {
}

// GetOrCreateStatusVerify retrieves the value of the StatusVerify field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert) GetOrCreateStatusVerify() *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify {
	if t.StatusVerify != nil {
		return t.StatusVerify
	}
	t.StatusVerify = &NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify{}
	return t.StatusVerify
}

// GetStatusVerify returns the value of the StatusVerify struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert. If the receiver or the field StatusVerify is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert) GetStatusVerify() *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify {
	if t != nil && t.StatusVerify != nil {
		return t.StatusVerify
	}
	return nil
}

// GetCertProfile retrieves the value of the leaf CertProfile from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CertProfile is set, it can
// safely use t.GetCertProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CertProfile == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert) GetCertProfile() string {
	if t == nil || t.CertProfile == nil {
		return ""
	}
	return *t.CertProfile
}

// GetTrustAnchorProfile retrieves the value of the leaf TrustAnchorProfile from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TrustAnchorProfile is set, it can
// safely use t.GetTrustAnchorProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TrustAnchorProfile == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert) GetTrustAnchorProfile() string {
	if t == nil || t.TrustAnchorProfile == nil {
		return ""
	}
	return *t.TrustAnchorProfile
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.StatusVerify.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify represents the /nokia-conf/configure/groups/group/ipsec/ipsec-transport-mode-profile/key-exchange/dynamic/cert/status-verify YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify struct {
	DefaultResult E_NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify_DefaultResult `path:"default-result" module:"nokia-conf"`
	Primary       E_NokiaTypesIpsec_CertRevocationStatus                                                                                 `path:"primary" module:"nokia-conf"`
	Secondary     E_NokiaTypesIpsec_CertRevocationStatusWithNone                                                                         `path:"secondary" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify) IsYANGGoStruct() {
}

// GetDefaultResult retrieves the value of the leaf DefaultResult from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DefaultResult is set, it can
// safely use t.GetDefaultResult() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DefaultResult == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify) GetDefaultResult() E_NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify_DefaultResult {
	if t == nil || t.DefaultResult == 0 {
		return NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify_DefaultResult_revoked
	}
	return t.DefaultResult
}

// GetPrimary retrieves the value of the leaf Primary from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Primary is set, it can
// safely use t.GetPrimary() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Primary == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify) GetPrimary() E_NokiaTypesIpsec_CertRevocationStatus {
	if t == nil || t.Primary == 0 {
		return NokiaTypesIpsec_CertRevocationStatus_crl
	}
	return t.Primary
}

// GetSecondary retrieves the value of the leaf Secondary from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Secondary is set, it can
// safely use t.GetSecondary() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Secondary == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify) GetSecondary() E_NokiaTypesIpsec_CertRevocationStatusWithNone {
	if t == nil || t.Secondary == 0 {
		return NokiaTypesIpsec_CertRevocationStatusWithNone_none
	}
	return t.Secondary
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.DefaultResult == 0 {
		t.DefaultResult = NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify_DefaultResult_revoked
	}
	if t.Primary == 0 {
		t.Primary = NokiaTypesIpsec_CertRevocationStatus_crl
	}
	if t.Secondary == 0 {
		t.Secondary = NokiaTypesIpsec_CertRevocationStatusWithNone_none
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Cert_StatusVerify) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id represents the /nokia-conf/configure/groups/group/ipsec/ipsec-transport-mode-profile/key-exchange/dynamic/id YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id struct {
	Fqdn *string `path:"fqdn" module:"nokia-conf"`
	Ipv4 *string `path:"ipv4" module:"nokia-conf"`
	Ipv6 *string `path:"ipv6" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id) IsYANGGoStruct() {
}

// GetFqdn retrieves the value of the leaf Fqdn from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fqdn is set, it can
// safely use t.GetFqdn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fqdn == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id) GetFqdn() string {
	if t == nil || t.Fqdn == nil {
		return ""
	}
	return *t.Fqdn
}

// GetIpv4 retrieves the value of the leaf Ipv4 from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4 is set, it can
// safely use t.GetIpv4() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4 == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id) GetIpv4() string {
	if t == nil || t.Ipv4 == nil {
		return ""
	}
	return *t.Ipv4
}

// GetIpv6 retrieves the value of the leaf Ipv6 from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6 is set, it can
// safely use t.GetIpv6() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6 == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id) GetIpv6() string {
	if t == nil || t.Ipv6 == nil {
		return ""
	}
	return *t.Ipv6
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_KeyExchange_Dynamic_Id) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords represents the /nokia-conf/configure/groups/group/ipsec/ipsec-transport-mode-profile/max-history-key-records YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords struct {
	Esp *uint32 `path:"esp" module:"nokia-conf"`
	Ike *uint32 `path:"ike" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords) IsYANGGoStruct() {
}

// GetEsp retrieves the value of the leaf Esp from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Esp is set, it can
// safely use t.GetEsp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Esp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords) GetEsp() uint32 {
	if t == nil || t.Esp == nil {
		return 0
	}
	return *t.Esp
}

// GetIke retrieves the value of the leaf Ike from the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ike is set, it can
// safely use t.GetIke() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ike == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords) GetIke() uint32 {
	if t == nil || t.Ike == nil {
		return 0
	}
	return *t.Ike
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords.
func (*NokiaConf_Configure_Groups_Group_Ipsec_IpsecTransportModeProfile_MaxHistoryKeyRecords) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_Radius represents the /nokia-conf/configure/groups/group/ipsec/radius YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_Radius struct {
	AccountingPolicy     map[string]*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy     `path:"accounting-policy" module:"nokia-conf"`
	AuthenticationPolicy map[string]*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy `path:"authentication-policy" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_Radius implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_Radius) IsYANGGoStruct() {}

// NewAccountingPolicy creates a new entry in the AccountingPolicy list of the
// NokiaConf_Configure_Groups_Group_Ipsec_Radius struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) NewAccountingPolicy(Name string) (*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AccountingPolicy == nil {
		t.AccountingPolicy = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AccountingPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AccountingPolicy", key)
	}

	t.AccountingPolicy[key] = &NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy{
		Name: &Name,
	}

	return t.AccountingPolicy[key], nil
}

// RenameAccountingPolicy renames an entry in the list AccountingPolicy within
// the NokiaConf_Configure_Groups_Group_Ipsec_Radius struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) RenameAccountingPolicy(oldK, newK string) error {
	if _, ok := t.AccountingPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in AccountingPolicy", newK)
	}

	e, ok := t.AccountingPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AccountingPolicy", oldK)
	}
	e.Name = &newK

	t.AccountingPolicy[newK] = e
	delete(t.AccountingPolicy, oldK)
	return nil
}

// GetOrCreateAccountingPolicy retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_Radius. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) GetOrCreateAccountingPolicy(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy {

	key := Name

	if v, ok := t.AccountingPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAccountingPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAccountingPolicy got unexpected error: %v", err))
	}
	return v
}

// GetAccountingPolicy retrieves the value with the specified key from
// the AccountingPolicy map field of NokiaConf_Configure_Groups_Group_Ipsec_Radius. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) GetAccountingPolicy(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.AccountingPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteAccountingPolicy deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_Radius. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) DeleteAccountingPolicy(Name string) {
	key := Name

	delete(t.AccountingPolicy, key)
}

// AppendAccountingPolicy appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy struct to the
// list AccountingPolicy of NokiaConf_Configure_Groups_Group_Ipsec_Radius. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) AppendAccountingPolicy(v *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AccountingPolicy == nil {
		t.AccountingPolicy = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy)
	}

	if _, ok := t.AccountingPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list AccountingPolicy %v", key)
	}

	t.AccountingPolicy[key] = v
	return nil
}

// NewAuthenticationPolicy creates a new entry in the AuthenticationPolicy list of the
// NokiaConf_Configure_Groups_Group_Ipsec_Radius struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) NewAuthenticationPolicy(Name string) (*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AuthenticationPolicy == nil {
		t.AuthenticationPolicy = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AuthenticationPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AuthenticationPolicy", key)
	}

	t.AuthenticationPolicy[key] = &NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy{
		Name: &Name,
	}

	return t.AuthenticationPolicy[key], nil
}

// RenameAuthenticationPolicy renames an entry in the list AuthenticationPolicy within
// the NokiaConf_Configure_Groups_Group_Ipsec_Radius struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) RenameAuthenticationPolicy(oldK, newK string) error {
	if _, ok := t.AuthenticationPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in AuthenticationPolicy", newK)
	}

	e, ok := t.AuthenticationPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AuthenticationPolicy", oldK)
	}
	e.Name = &newK

	t.AuthenticationPolicy[newK] = e
	delete(t.AuthenticationPolicy, oldK)
	return nil
}

// GetOrCreateAuthenticationPolicy retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_Radius. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) GetOrCreateAuthenticationPolicy(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy {

	key := Name

	if v, ok := t.AuthenticationPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAuthenticationPolicy(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAuthenticationPolicy got unexpected error: %v", err))
	}
	return v
}

// GetAuthenticationPolicy retrieves the value with the specified key from
// the AuthenticationPolicy map field of NokiaConf_Configure_Groups_Group_Ipsec_Radius. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) GetAuthenticationPolicy(Name string) *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.AuthenticationPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteAuthenticationPolicy deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_Radius. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) DeleteAuthenticationPolicy(Name string) {
	key := Name

	delete(t.AuthenticationPolicy, key)
}

// AppendAuthenticationPolicy appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy struct to the
// list AuthenticationPolicy of NokiaConf_Configure_Groups_Group_Ipsec_Radius. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) AppendAuthenticationPolicy(v *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AuthenticationPolicy == nil {
		t.AuthenticationPolicy = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy)
	}

	if _, ok := t.AuthenticationPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list AuthenticationPolicy %v", key)
	}

	t.AuthenticationPolicy[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_Radius
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.AccountingPolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.AuthenticationPolicy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_Radius"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_Radius.
func (*NokiaConf_Configure_Groups_Group_Ipsec_Radius) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy represents the /nokia-conf/configure/groups/group/ipsec/radius/accounting-policy YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy struct {
	IncludeRadiusAttribute *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute `path:"include-radius-attribute" module:"nokia-conf"`
	Name                   *string                                                                                `path:"name" module:"nokia-conf"`
	RadiusServerPolicy     *string                                                                                `path:"radius-server-policy" module:"nokia-conf"`
	UpdateInterval         *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval         `path:"update-interval" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) IsYANGGoStruct() {}

// GetOrCreateIncludeRadiusAttribute retrieves the value of the IncludeRadiusAttribute field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) GetOrCreateIncludeRadiusAttribute() *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute {
	if t.IncludeRadiusAttribute != nil {
		return t.IncludeRadiusAttribute
	}
	t.IncludeRadiusAttribute = &NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute{}
	return t.IncludeRadiusAttribute
}

// GetOrCreateUpdateInterval retrieves the value of the UpdateInterval field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) GetOrCreateUpdateInterval() *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval {
	if t.UpdateInterval != nil {
		return t.UpdateInterval
	}
	t.UpdateInterval = &NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval{}
	return t.UpdateInterval
}

// GetIncludeRadiusAttribute returns the value of the IncludeRadiusAttribute struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy. If the receiver or the field IncludeRadiusAttribute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) GetIncludeRadiusAttribute() *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute {
	if t != nil && t.IncludeRadiusAttribute != nil {
		return t.IncludeRadiusAttribute
	}
	return nil
}

// GetUpdateInterval returns the value of the UpdateInterval struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy. If the receiver or the field UpdateInterval is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) GetUpdateInterval() *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval {
	if t != nil && t.UpdateInterval != nil {
		return t.UpdateInterval
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetRadiusServerPolicy retrieves the value of the leaf RadiusServerPolicy from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RadiusServerPolicy is set, it can
// safely use t.GetRadiusServerPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RadiusServerPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) GetRadiusServerPolicy() string {
	if t == nil || t.RadiusServerPolicy == nil {
		return ""
	}
	return *t.RadiusServerPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.IncludeRadiusAttribute.PopulateDefaults()
	t.UpdateInterval.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy.
func (*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute represents the /nokia-conf/configure/groups/group/ipsec/radius/accounting-policy/include-radius-attribute YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute struct {
	AcctStats        *bool `path:"acct-stats" module:"nokia-conf"`
	CalledStationId  *bool `path:"called-station-id" module:"nokia-conf"`
	CallingStationId *bool `path:"calling-station-id" module:"nokia-conf"`
	FramedIpAddr     *bool `path:"framed-ip-addr" module:"nokia-conf"`
	FramedIpv6Prefix *bool `path:"framed-ipv6-prefix" module:"nokia-conf"`
	NasIdentifier    *bool `path:"nas-identifier" module:"nokia-conf"`
	NasIpAddr        *bool `path:"nas-ip-addr" module:"nokia-conf"`
	NasPortId        *bool `path:"nas-port-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) IsYANGGoStruct() {
}

// GetAcctStats retrieves the value of the leaf AcctStats from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AcctStats is set, it can
// safely use t.GetAcctStats() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AcctStats == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) GetAcctStats() bool {
	if t == nil || t.AcctStats == nil {
		return false
	}
	return *t.AcctStats
}

// GetCalledStationId retrieves the value of the leaf CalledStationId from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CalledStationId is set, it can
// safely use t.GetCalledStationId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CalledStationId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) GetCalledStationId() bool {
	if t == nil || t.CalledStationId == nil {
		return false
	}
	return *t.CalledStationId
}

// GetCallingStationId retrieves the value of the leaf CallingStationId from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CallingStationId is set, it can
// safely use t.GetCallingStationId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CallingStationId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) GetCallingStationId() bool {
	if t == nil || t.CallingStationId == nil {
		return false
	}
	return *t.CallingStationId
}

// GetFramedIpAddr retrieves the value of the leaf FramedIpAddr from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FramedIpAddr is set, it can
// safely use t.GetFramedIpAddr() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FramedIpAddr == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) GetFramedIpAddr() bool {
	if t == nil || t.FramedIpAddr == nil {
		return false
	}
	return *t.FramedIpAddr
}

// GetFramedIpv6Prefix retrieves the value of the leaf FramedIpv6Prefix from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FramedIpv6Prefix is set, it can
// safely use t.GetFramedIpv6Prefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FramedIpv6Prefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) GetFramedIpv6Prefix() bool {
	if t == nil || t.FramedIpv6Prefix == nil {
		return false
	}
	return *t.FramedIpv6Prefix
}

// GetNasIdentifier retrieves the value of the leaf NasIdentifier from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NasIdentifier is set, it can
// safely use t.GetNasIdentifier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NasIdentifier == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) GetNasIdentifier() bool {
	if t == nil || t.NasIdentifier == nil {
		return false
	}
	return *t.NasIdentifier
}

// GetNasIpAddr retrieves the value of the leaf NasIpAddr from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NasIpAddr is set, it can
// safely use t.GetNasIpAddr() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NasIpAddr == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) GetNasIpAddr() bool {
	if t == nil || t.NasIpAddr == nil {
		return false
	}
	return *t.NasIpAddr
}

// GetNasPortId retrieves the value of the leaf NasPortId from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NasPortId is set, it can
// safely use t.GetNasPortId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NasPortId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) GetNasPortId() bool {
	if t == nil || t.NasPortId == nil {
		return false
	}
	return *t.NasPortId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AcctStats == nil {
		var v bool = false
		t.AcctStats = &v
	}
	if t.CalledStationId == nil {
		var v bool = false
		t.CalledStationId = &v
	}
	if t.CallingStationId == nil {
		var v bool = false
		t.CallingStationId = &v
	}
	if t.FramedIpAddr == nil {
		var v bool = false
		t.FramedIpAddr = &v
	}
	if t.FramedIpv6Prefix == nil {
		var v bool = false
		t.FramedIpv6Prefix = &v
	}
	if t.NasIdentifier == nil {
		var v bool = false
		t.NasIdentifier = &v
	}
	if t.NasIpAddr == nil {
		var v bool = false
		t.NasIpAddr = &v
	}
	if t.NasPortId == nil {
		var v bool = false
		t.NasPortId = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute.
func (*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_IncludeRadiusAttribute) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval represents the /nokia-conf/configure/groups/group/ipsec/radius/accounting-policy/update-interval YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval struct {
	Jitter *int32 `path:"jitter" module:"nokia-conf"`
	Value  *int32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval) IsYANGGoStruct() {
}

// GetJitter retrieves the value of the leaf Jitter from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Jitter is set, it can
// safely use t.GetJitter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Jitter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval) GetJitter() int32 {
	if t == nil || t.Jitter == nil {
		return 0
	}
	return *t.Jitter
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval) GetValue() int32 {
	if t == nil || t.Value == nil {
		return 10
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Value == nil {
		var v int32 = 10
		t.Value = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval.
func (*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AccountingPolicy_UpdateInterval) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy represents the /nokia-conf/configure/groups/group/ipsec/radius/authentication-policy YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy struct {
	IncludeRadiusAttribute *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute `path:"include-radius-attribute" module:"nokia-conf"`
	Name                   *string                                                                                    `path:"name" module:"nokia-conf"`
	Password               *string                                                                                    `path:"password" module:"nokia-conf"`
	RadiusServerPolicy     *string                                                                                    `path:"radius-server-policy" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) IsYANGGoStruct() {}

// GetOrCreateIncludeRadiusAttribute retrieves the value of the IncludeRadiusAttribute field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) GetOrCreateIncludeRadiusAttribute() *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute {
	if t.IncludeRadiusAttribute != nil {
		return t.IncludeRadiusAttribute
	}
	t.IncludeRadiusAttribute = &NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute{}
	return t.IncludeRadiusAttribute
}

// GetIncludeRadiusAttribute returns the value of the IncludeRadiusAttribute struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy. If the receiver or the field IncludeRadiusAttribute is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) GetIncludeRadiusAttribute() *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute {
	if t != nil && t.IncludeRadiusAttribute != nil {
		return t.IncludeRadiusAttribute
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetPassword retrieves the value of the leaf Password from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Password is set, it can
// safely use t.GetPassword() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Password == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) GetPassword() string {
	if t == nil || t.Password == nil {
		return ""
	}
	return *t.Password
}

// GetRadiusServerPolicy retrieves the value of the leaf RadiusServerPolicy from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RadiusServerPolicy is set, it can
// safely use t.GetRadiusServerPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RadiusServerPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) GetRadiusServerPolicy() string {
	if t == nil || t.RadiusServerPolicy == nil {
		return ""
	}
	return *t.RadiusServerPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.IncludeRadiusAttribute.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy.
func (*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute represents the /nokia-conf/configure/groups/group/ipsec/radius/authentication-policy/include-radius-attribute YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute struct {
	CalledStationId        *bool `path:"called-station-id" module:"nokia-conf"`
	CallingStationId       *bool `path:"calling-station-id" module:"nokia-conf"`
	ClientCertSubjectKeyId *bool `path:"client-cert-subject-key-id" module:"nokia-conf"`
	NasIdentifier          *bool `path:"nas-identifier" module:"nokia-conf"`
	NasIpAddr              *bool `path:"nas-ip-addr" module:"nokia-conf"`
	NasPortId              *bool `path:"nas-port-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute) IsYANGGoStruct() {
}

// GetCalledStationId retrieves the value of the leaf CalledStationId from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CalledStationId is set, it can
// safely use t.GetCalledStationId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CalledStationId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute) GetCalledStationId() bool {
	if t == nil || t.CalledStationId == nil {
		return false
	}
	return *t.CalledStationId
}

// GetCallingStationId retrieves the value of the leaf CallingStationId from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CallingStationId is set, it can
// safely use t.GetCallingStationId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CallingStationId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute) GetCallingStationId() bool {
	if t == nil || t.CallingStationId == nil {
		return false
	}
	return *t.CallingStationId
}

// GetClientCertSubjectKeyId retrieves the value of the leaf ClientCertSubjectKeyId from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClientCertSubjectKeyId is set, it can
// safely use t.GetClientCertSubjectKeyId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClientCertSubjectKeyId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute) GetClientCertSubjectKeyId() bool {
	if t == nil || t.ClientCertSubjectKeyId == nil {
		return false
	}
	return *t.ClientCertSubjectKeyId
}

// GetNasIdentifier retrieves the value of the leaf NasIdentifier from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NasIdentifier is set, it can
// safely use t.GetNasIdentifier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NasIdentifier == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute) GetNasIdentifier() bool {
	if t == nil || t.NasIdentifier == nil {
		return false
	}
	return *t.NasIdentifier
}

// GetNasIpAddr retrieves the value of the leaf NasIpAddr from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NasIpAddr is set, it can
// safely use t.GetNasIpAddr() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NasIpAddr == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute) GetNasIpAddr() bool {
	if t == nil || t.NasIpAddr == nil {
		return false
	}
	return *t.NasIpAddr
}

// GetNasPortId retrieves the value of the leaf NasPortId from the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if NasPortId is set, it can
// safely use t.GetNasPortId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.NasPortId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute) GetNasPortId() bool {
	if t == nil || t.NasPortId == nil {
		return false
	}
	return *t.NasPortId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CalledStationId == nil {
		var v bool = false
		t.CalledStationId = &v
	}
	if t.CallingStationId == nil {
		var v bool = false
		t.CallingStationId = &v
	}
	if t.ClientCertSubjectKeyId == nil {
		var v bool = false
		t.ClientCertSubjectKeyId = &v
	}
	if t.NasIdentifier == nil {
		var v bool = false
		t.NasIdentifier = &v
	}
	if t.NasIpAddr == nil {
		var v bool = false
		t.NasIpAddr = &v
	}
	if t.NasPortId == nil {
		var v bool = false
		t.NasPortId = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute.
func (*NokiaConf_Configure_Groups_Group_Ipsec_Radius_AuthenticationPolicy_IncludeRadiusAttribute) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_StaticSa represents the /nokia-conf/configure/groups/group/ipsec/static-sa YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_StaticSa struct {
	Authentication *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication `path:"authentication" module:"nokia-conf" yangPresence:"true"`
	Description    *string                                                         `path:"description" module:"nokia-conf"`
	Direction      E_NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Direction     `path:"direction" module:"nokia-conf"`
	Name           *string                                                         `path:"name" module:"nokia-conf"`
	Protocol       E_NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Protocol      `path:"protocol" module:"nokia-conf"`
	Spi            *uint32                                                         `path:"spi" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_StaticSa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) IsYANGGoStruct() {}

// GetOrCreateAuthentication retrieves the value of the Authentication field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) GetOrCreateAuthentication() *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication {
	if t.Authentication != nil {
		return t.Authentication
	}
	t.Authentication = &NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication{}
	return t.Authentication
}

// GetAuthentication returns the value of the Authentication struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_StaticSa. If the receiver or the field Authentication is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) GetAuthentication() *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication {
	if t != nil && t.Authentication != nil {
		return t.Authentication
	}
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Ipsec_StaticSa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetDirection retrieves the value of the leaf Direction from the NokiaConf_Configure_Groups_Group_Ipsec_StaticSa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Direction is set, it can
// safely use t.GetDirection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Direction == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) GetDirection() E_NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Direction {
	if t == nil || t.Direction == 0 {
		return NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Direction_bidirectional
	}
	return t.Direction
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Ipsec_StaticSa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetProtocol retrieves the value of the leaf Protocol from the NokiaConf_Configure_Groups_Group_Ipsec_StaticSa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Protocol is set, it can
// safely use t.GetProtocol() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Protocol == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) GetProtocol() E_NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Protocol {
	if t == nil || t.Protocol == 0 {
		return NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Protocol_esp
	}
	return t.Protocol
}

// GetSpi retrieves the value of the leaf Spi from the NokiaConf_Configure_Groups_Group_Ipsec_StaticSa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Spi is set, it can
// safely use t.GetSpi() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Spi == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) GetSpi() uint32 {
	if t == nil || t.Spi == nil {
		return 0
	}
	return *t.Spi
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_StaticSa
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Direction == 0 {
		t.Direction = NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Direction_bidirectional
	}
	if t.Protocol == 0 {
		t.Protocol = NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Protocol_esp
	}
	t.Authentication.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_StaticSa struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_StaticSa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_StaticSa.
func (*NokiaConf_Configure_Groups_Group_Ipsec_StaticSa) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication represents the /nokia-conf/configure/groups/group/ipsec/static-sa/authentication YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication struct {
	Algorithm E_NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication_Algorithm `path:"algorithm" module:"nokia-conf"`
	Key       *string                                                                    `path:"key" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication) IsYANGGoStruct() {}

// GetAlgorithm retrieves the value of the leaf Algorithm from the NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Algorithm is set, it can
// safely use t.GetAlgorithm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Algorithm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication) GetAlgorithm() E_NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication_Algorithm {
	if t == nil || t.Algorithm == 0 {
		return 0
	}
	return t.Algorithm
}

// GetKey retrieves the value of the leaf Key from the NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Key is set, it can
// safely use t.GetKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Key == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication) GetKey() string {
	if t == nil || t.Key == nil {
		return ""
	}
	return *t.Key
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication.
func (*NokiaConf_Configure_Groups_Group_Ipsec_StaticSa_Authentication) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile represents the /nokia-conf/configure/groups/group/ipsec/trust-anchor-profile YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile struct {
	Name        *string                                                                           `path:"name" module:"nokia-conf"`
	TrustAnchor map[string]*NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor `path:"trust-anchor" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) IsYANGGoStruct() {}

// NewTrustAnchor creates a new entry in the TrustAnchor list of the
// NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) NewTrustAnchor(CaProfile string) (*NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrustAnchor == nil {
		t.TrustAnchor = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor)
	}

	key := CaProfile

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TrustAnchor[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TrustAnchor", key)
	}

	t.TrustAnchor[key] = &NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor{
		CaProfile: &CaProfile,
	}

	return t.TrustAnchor[key], nil
}

// RenameTrustAnchor renames an entry in the list TrustAnchor within
// the NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) RenameTrustAnchor(oldK, newK string) error {
	if _, ok := t.TrustAnchor[newK]; ok {
		return fmt.Errorf("key %v already exists in TrustAnchor", newK)
	}

	e, ok := t.TrustAnchor[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TrustAnchor", oldK)
	}
	e.CaProfile = &newK

	t.TrustAnchor[newK] = e
	delete(t.TrustAnchor, oldK)
	return nil
}

// GetOrCreateTrustAnchor retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) GetOrCreateTrustAnchor(CaProfile string) *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor {

	key := CaProfile

	if v, ok := t.TrustAnchor[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTrustAnchor(CaProfile)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTrustAnchor got unexpected error: %v", err))
	}
	return v
}

// GetTrustAnchor retrieves the value with the specified key from
// the TrustAnchor map field of NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) GetTrustAnchor(CaProfile string) *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor {

	if t == nil {
		return nil
	}

	key := CaProfile

	if lm, ok := t.TrustAnchor[key]; ok {
		return lm
	}
	return nil
}

// DeleteTrustAnchor deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) DeleteTrustAnchor(CaProfile string) {
	key := CaProfile

	delete(t.TrustAnchor, key)
}

// AppendTrustAnchor appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor struct to the
// list TrustAnchor of NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) AppendTrustAnchor(v *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor) error {
	if v.CaProfile == nil {
		return fmt.Errorf("invalid nil key received for CaProfile")
	}

	key := *v.CaProfile

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TrustAnchor == nil {
		t.TrustAnchor = make(map[string]*NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor)
	}

	if _, ok := t.TrustAnchor[key]; ok {
		return fmt.Errorf("duplicate key for list TrustAnchor %v", key)
	}

	t.TrustAnchor[key] = v
	return nil
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.TrustAnchor {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor represents the /nokia-conf/configure/groups/group/ipsec/trust-anchor-profile/trust-anchor YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor struct {
	CaProfile *string `path:"ca-profile" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor) IsYANGGoStruct() {}

// GetCaProfile retrieves the value of the leaf CaProfile from the NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CaProfile is set, it can
// safely use t.GetCaProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CaProfile == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor) GetCaProfile() string {
	if t == nil || t.CaProfile == nil {
		return ""
	}
	return *t.CaProfile
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor) ΛListKeyMap() (map[string]interface{}, error) {
	if t.CaProfile == nil {
		return nil, fmt.Errorf("nil value for key CaProfile")
	}

	return map[string]interface{}{
		"ca-profile": *t.CaProfile,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TrustAnchorProfile_TrustAnchor) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList represents the /nokia-conf/configure/groups/group/ipsec/ts-list YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList struct {
	Local  *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local  `path:"local" module:"nokia-conf"`
	Name   *string                                               `path:"name" module:"nokia-conf"`
	Remote *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote `path:"remote" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList) IsYANGGoStruct() {}

// GetOrCreateLocal retrieves the value of the Local field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList) GetOrCreateLocal() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local {
	if t.Local != nil {
		return t.Local
	}
	t.Local = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local{}
	return t.Local
}

// GetOrCreateRemote retrieves the value of the Remote field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList) GetOrCreateRemote() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote {
	if t.Remote != nil {
		return t.Remote
	}
	t.Remote = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote{}
	return t.Remote
}

// GetLocal returns the value of the Local struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList. If the receiver or the field Local is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList) GetLocal() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local {
	if t != nil && t.Local != nil {
		return t.Local
	}
	return nil
}

// GetRemote returns the value of the Remote struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList. If the receiver or the field Remote is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList) GetRemote() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote {
	if t != nil && t.Remote != nil {
		return t.Remote
	}
	return nil
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Ipsec_TsList
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Local.PopulateDefaults()
	t.Remote.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_TsList struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local struct {
	Entry map[NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry `path:"entry" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local) NewEntry(Id NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local) GetEntry(Id NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local) AppendEntry(v *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry struct {
	Address  *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address  `path:"address" module:"nokia-conf" yangPresence:"true"`
	Id       NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Id_Union  `path:"id" module:"nokia-conf"`
	Protocol *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol `path:"protocol" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) IsYANGGoStruct() {}

// GetOrCreateAddress retrieves the value of the Address field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) GetOrCreateAddress() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address {
	if t.Address != nil {
		return t.Address
	}
	t.Address = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address{}
	return t.Address
}

// GetOrCreateProtocol retrieves the value of the Protocol field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) GetOrCreateProtocol() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol {
	if t.Protocol != nil {
		return t.Protocol
	}
	t.Protocol = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol{}
	return t.Protocol
}

// GetAddress returns the value of the Address struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry. If the receiver or the field Address is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) GetAddress() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address {
	if t != nil && t.Address != nil {
		return t.Address
	}
	return nil
}

// GetProtocol returns the value of the Protocol struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry. If the receiver or the field Protocol is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) GetProtocol() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol {
	if t != nil && t.Protocol != nil {
		return t.Protocol
	}
	return nil
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) GetId() NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Address.PopulateDefaults()
	t.Protocol.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/address YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address struct {
	Prefix *string                                                                  `path:"prefix" module:"nokia-conf"`
	Range  *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address) GetRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetPrefix retrieves the value of the leaf Prefix from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/address/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range struct {
	Begin *string `path:"begin" module:"nokia-conf"`
	End   *string `path:"end" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range) IsYANGGoStruct() {}

// GetBegin retrieves the value of the leaf Begin from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Begin is set, it can
// safely use t.GetBegin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Begin == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range) GetBegin() string {
	if t == nil || t.Begin == nil {
		return ""
	}
	return *t.Begin
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range) GetEnd() string {
	if t == nil || t.End == nil {
		return ""
	}
	return *t.End
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Address_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol struct {
	Any YANGEmpty                                                              `path:"any" module:"nokia-conf"`
	Id  *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id `path:"id" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol) IsYANGGoStruct() {}

// GetOrCreateId retrieves the value of the Id field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol) GetOrCreateId() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id {
	if t.Id != nil {
		return t.Id
	}
	t.Id = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id{}
	return t.Id
}

// GetId returns the value of the Id struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol. If the receiver or the field Id is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol) GetId() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id {
	if t != nil && t.Id != nil {
		return t.Id
	}
	return nil
}

// GetAny retrieves the value of the leaf Any from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Any is set, it can
// safely use t.GetAny() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Any == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol) GetAny() YANGEmpty {
	if t == nil || t.Any == false {
		return false
	}
	return t.Any
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Id.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id struct {
	Icmp                  *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp                       `path:"icmp" module:"nokia-conf"`
	Icmp6                 *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6                      `path:"icmp6" module:"nokia-conf"`
	Mipv6                 *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6                      `path:"mipv6" module:"nokia-conf"`
	ProtocolIdWithAnyPort NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_ProtocolIdWithAnyPort_Union `path:"protocol-id-with-any-port" module:"nokia-conf"`
	Sctp                  *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp                       `path:"sctp" module:"nokia-conf"`
	Tcp                   *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp                        `path:"tcp" module:"nokia-conf"`
	Udp                   *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp                        `path:"udp" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) IsYANGGoStruct() {}

// GetOrCreateIcmp retrieves the value of the Icmp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetOrCreateIcmp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp {
	if t.Icmp != nil {
		return t.Icmp
	}
	t.Icmp = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp{}
	return t.Icmp
}

// GetOrCreateIcmp6 retrieves the value of the Icmp6 field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetOrCreateIcmp6() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6 {
	if t.Icmp6 != nil {
		return t.Icmp6
	}
	t.Icmp6 = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6{}
	return t.Icmp6
}

// GetOrCreateMipv6 retrieves the value of the Mipv6 field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetOrCreateMipv6() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6 {
	if t.Mipv6 != nil {
		return t.Mipv6
	}
	t.Mipv6 = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6{}
	return t.Mipv6
}

// GetOrCreateSctp retrieves the value of the Sctp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetOrCreateSctp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp {
	if t.Sctp != nil {
		return t.Sctp
	}
	t.Sctp = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp{}
	return t.Sctp
}

// GetOrCreateTcp retrieves the value of the Tcp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetOrCreateTcp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp {
	if t.Tcp != nil {
		return t.Tcp
	}
	t.Tcp = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp{}
	return t.Tcp
}

// GetOrCreateUdp retrieves the value of the Udp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetOrCreateUdp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp {
	if t.Udp != nil {
		return t.Udp
	}
	t.Udp = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp{}
	return t.Udp
}

// GetIcmp returns the value of the Icmp struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id. If the receiver or the field Icmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetIcmp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp {
	if t != nil && t.Icmp != nil {
		return t.Icmp
	}
	return nil
}

// GetIcmp6 returns the value of the Icmp6 struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id. If the receiver or the field Icmp6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetIcmp6() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6 {
	if t != nil && t.Icmp6 != nil {
		return t.Icmp6
	}
	return nil
}

// GetMipv6 returns the value of the Mipv6 struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id. If the receiver or the field Mipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetMipv6() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6 {
	if t != nil && t.Mipv6 != nil {
		return t.Mipv6
	}
	return nil
}

// GetSctp returns the value of the Sctp struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id. If the receiver or the field Sctp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetSctp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp {
	if t != nil && t.Sctp != nil {
		return t.Sctp
	}
	return nil
}

// GetTcp returns the value of the Tcp struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id. If the receiver or the field Tcp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetTcp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp {
	if t != nil && t.Tcp != nil {
		return t.Tcp
	}
	return nil
}

// GetUdp returns the value of the Udp struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id. If the receiver or the field Udp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetUdp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp {
	if t != nil && t.Udp != nil {
		return t.Udp
	}
	return nil
}

// GetProtocolIdWithAnyPort retrieves the value of the leaf ProtocolIdWithAnyPort from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtocolIdWithAnyPort is set, it can
// safely use t.GetProtocolIdWithAnyPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtocolIdWithAnyPort == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) GetProtocolIdWithAnyPort() NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_ProtocolIdWithAnyPort_Union {
	if t == nil || t.ProtocolIdWithAnyPort == nil {
		return nil
	}
	return t.ProtocolIdWithAnyPort
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Icmp.PopulateDefaults()
	t.Icmp6.PopulateDefaults()
	t.Mipv6.PopulateDefaults()
	t.Sctp.PopulateDefaults()
	t.Tcp.PopulateDefaults()
	t.Udp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id/icmp YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp struct {
	Opaque    YANGEmpty                                                                             `path:"opaque" module:"nokia-conf"`
	PortRange *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange `path:"port-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp) IsYANGGoStruct() {}

// GetOrCreatePortRange retrieves the value of the PortRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp) GetOrCreatePortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange {
	if t.PortRange != nil {
		return t.PortRange
	}
	t.PortRange = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange{}
	return t.PortRange
}

// GetPortRange returns the value of the PortRange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp. If the receiver or the field PortRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp) GetPortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange {
	if t != nil && t.PortRange != nil {
		return t.PortRange
	}
	return nil
}

// GetOpaque retrieves the value of the leaf Opaque from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Opaque is set, it can
// safely use t.GetOpaque() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Opaque == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp) GetOpaque() YANGEmpty {
	if t == nil || t.Opaque == false {
		return false
	}
	return t.Opaque
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PortRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6 represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id/icmp6 YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6 struct {
	Opaque    YANGEmpty                                                                              `path:"opaque" module:"nokia-conf"`
	PortRange *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange `path:"port-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6) IsYANGGoStruct() {
}

// GetOrCreatePortRange retrieves the value of the PortRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6) GetOrCreatePortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange {
	if t.PortRange != nil {
		return t.PortRange
	}
	t.PortRange = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange{}
	return t.PortRange
}

// GetPortRange returns the value of the PortRange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6. If the receiver or the field PortRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6) GetPortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange {
	if t != nil && t.PortRange != nil {
		return t.PortRange
	}
	return nil
}

// GetOpaque retrieves the value of the leaf Opaque from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Opaque is set, it can
// safely use t.GetOpaque() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Opaque == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6) GetOpaque() YANGEmpty {
	if t == nil || t.Opaque == false {
		return false
	}
	return t.Opaque
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PortRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id/icmp6/port-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange struct {
	BeginIcmpCode *uint16 `path:"begin-icmp-code" module:"nokia-conf"`
	BeginIcmpType *uint16 `path:"begin-icmp-type" module:"nokia-conf"`
	EndIcmpCode   *uint16 `path:"end-icmp-code" module:"nokia-conf"`
	EndIcmpType   *uint16 `path:"end-icmp-type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange) IsYANGGoStruct() {
}

// GetBeginIcmpCode retrieves the value of the leaf BeginIcmpCode from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BeginIcmpCode is set, it can
// safely use t.GetBeginIcmpCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BeginIcmpCode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange) GetBeginIcmpCode() uint16 {
	if t == nil || t.BeginIcmpCode == nil {
		return 0
	}
	return *t.BeginIcmpCode
}

// GetBeginIcmpType retrieves the value of the leaf BeginIcmpType from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BeginIcmpType is set, it can
// safely use t.GetBeginIcmpType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BeginIcmpType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange) GetBeginIcmpType() uint16 {
	if t == nil || t.BeginIcmpType == nil {
		return 0
	}
	return *t.BeginIcmpType
}

// GetEndIcmpCode retrieves the value of the leaf EndIcmpCode from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndIcmpCode is set, it can
// safely use t.GetEndIcmpCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndIcmpCode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange) GetEndIcmpCode() uint16 {
	if t == nil || t.EndIcmpCode == nil {
		return 0
	}
	return *t.EndIcmpCode
}

// GetEndIcmpType retrieves the value of the leaf EndIcmpType from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndIcmpType is set, it can
// safely use t.GetEndIcmpType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndIcmpType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange) GetEndIcmpType() uint16 {
	if t == nil || t.EndIcmpType == nil {
		return 0
	}
	return *t.EndIcmpType
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp6_PortRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id/icmp/port-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange struct {
	BeginIcmpCode *uint16 `path:"begin-icmp-code" module:"nokia-conf"`
	BeginIcmpType *uint16 `path:"begin-icmp-type" module:"nokia-conf"`
	EndIcmpCode   *uint16 `path:"end-icmp-code" module:"nokia-conf"`
	EndIcmpType   *uint16 `path:"end-icmp-type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange) IsYANGGoStruct() {
}

// GetBeginIcmpCode retrieves the value of the leaf BeginIcmpCode from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BeginIcmpCode is set, it can
// safely use t.GetBeginIcmpCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BeginIcmpCode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange) GetBeginIcmpCode() uint16 {
	if t == nil || t.BeginIcmpCode == nil {
		return 0
	}
	return *t.BeginIcmpCode
}

// GetBeginIcmpType retrieves the value of the leaf BeginIcmpType from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BeginIcmpType is set, it can
// safely use t.GetBeginIcmpType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BeginIcmpType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange) GetBeginIcmpType() uint16 {
	if t == nil || t.BeginIcmpType == nil {
		return 0
	}
	return *t.BeginIcmpType
}

// GetEndIcmpCode retrieves the value of the leaf EndIcmpCode from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndIcmpCode is set, it can
// safely use t.GetEndIcmpCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndIcmpCode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange) GetEndIcmpCode() uint16 {
	if t == nil || t.EndIcmpCode == nil {
		return 0
	}
	return *t.EndIcmpCode
}

// GetEndIcmpType retrieves the value of the leaf EndIcmpType from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndIcmpType is set, it can
// safely use t.GetEndIcmpType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndIcmpType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange) GetEndIcmpType() uint16 {
	if t == nil || t.EndIcmpType == nil {
		return 0
	}
	return *t.EndIcmpType
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Icmp_PortRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6 represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id/mipv6 YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6 struct {
	Opaque    YANGEmpty                                                                              `path:"opaque" module:"nokia-conf"`
	PortRange *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange `path:"port-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6) IsYANGGoStruct() {
}

// GetOrCreatePortRange retrieves the value of the PortRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6) GetOrCreatePortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange {
	if t.PortRange != nil {
		return t.PortRange
	}
	t.PortRange = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange{}
	return t.PortRange
}

// GetPortRange returns the value of the PortRange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6. If the receiver or the field PortRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6) GetPortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange {
	if t != nil && t.PortRange != nil {
		return t.PortRange
	}
	return nil
}

// GetOpaque retrieves the value of the leaf Opaque from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Opaque is set, it can
// safely use t.GetOpaque() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Opaque == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6) GetOpaque() YANGEmpty {
	if t == nil || t.Opaque == false {
		return false
	}
	return t.Opaque
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PortRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id/mipv6/port-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange struct {
	Begin *uint16 `path:"begin" module:"nokia-conf"`
	End   *uint16 `path:"end" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange) IsYANGGoStruct() {
}

// GetBegin retrieves the value of the leaf Begin from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Begin is set, it can
// safely use t.GetBegin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Begin == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange) GetBegin() uint16 {
	if t == nil || t.Begin == nil {
		return 0
	}
	return *t.Begin
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange) GetEnd() uint16 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Mipv6_PortRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id/sctp YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp struct {
	Opaque    YANGEmpty                                                                             `path:"opaque" module:"nokia-conf"`
	PortRange *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange `path:"port-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp) IsYANGGoStruct() {}

// GetOrCreatePortRange retrieves the value of the PortRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp) GetOrCreatePortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange {
	if t.PortRange != nil {
		return t.PortRange
	}
	t.PortRange = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange{}
	return t.PortRange
}

// GetPortRange returns the value of the PortRange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp. If the receiver or the field PortRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp) GetPortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange {
	if t != nil && t.PortRange != nil {
		return t.PortRange
	}
	return nil
}

// GetOpaque retrieves the value of the leaf Opaque from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Opaque is set, it can
// safely use t.GetOpaque() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Opaque == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp) GetOpaque() YANGEmpty {
	if t == nil || t.Opaque == false {
		return false
	}
	return t.Opaque
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PortRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id/sctp/port-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange struct {
	Begin *uint32 `path:"begin" module:"nokia-conf"`
	End   *uint32 `path:"end" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange) IsYANGGoStruct() {
}

// GetBegin retrieves the value of the leaf Begin from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Begin is set, it can
// safely use t.GetBegin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Begin == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange) GetBegin() uint32 {
	if t == nil || t.Begin == nil {
		return 0
	}
	return *t.Begin
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange) GetEnd() uint32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Sctp_PortRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id/tcp YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp struct {
	Opaque    YANGEmpty                                                                            `path:"opaque" module:"nokia-conf"`
	PortRange *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange `path:"port-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp) IsYANGGoStruct() {}

// GetOrCreatePortRange retrieves the value of the PortRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp) GetOrCreatePortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange {
	if t.PortRange != nil {
		return t.PortRange
	}
	t.PortRange = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange{}
	return t.PortRange
}

// GetPortRange returns the value of the PortRange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp. If the receiver or the field PortRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp) GetPortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange {
	if t != nil && t.PortRange != nil {
		return t.PortRange
	}
	return nil
}

// GetOpaque retrieves the value of the leaf Opaque from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Opaque is set, it can
// safely use t.GetOpaque() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Opaque == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp) GetOpaque() YANGEmpty {
	if t == nil || t.Opaque == false {
		return false
	}
	return t.Opaque
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PortRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id/tcp/port-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange struct {
	Begin *uint32 `path:"begin" module:"nokia-conf"`
	End   *uint32 `path:"end" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange) IsYANGGoStruct() {
}

// GetBegin retrieves the value of the leaf Begin from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Begin is set, it can
// safely use t.GetBegin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Begin == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange) GetBegin() uint32 {
	if t == nil || t.Begin == nil {
		return 0
	}
	return *t.Begin
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange) GetEnd() uint32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Tcp_PortRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id/udp YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp struct {
	Opaque    YANGEmpty                                                                            `path:"opaque" module:"nokia-conf"`
	PortRange *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange `path:"port-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp) IsYANGGoStruct() {}

// GetOrCreatePortRange retrieves the value of the PortRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp) GetOrCreatePortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange {
	if t.PortRange != nil {
		return t.PortRange
	}
	t.PortRange = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange{}
	return t.PortRange
}

// GetPortRange returns the value of the PortRange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp. If the receiver or the field PortRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp) GetPortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange {
	if t != nil && t.PortRange != nil {
		return t.PortRange
	}
	return nil
}

// GetOpaque retrieves the value of the leaf Opaque from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Opaque is set, it can
// safely use t.GetOpaque() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Opaque == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp) GetOpaque() YANGEmpty {
	if t == nil || t.Opaque == false {
		return false
	}
	return t.Opaque
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PortRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange represents the /nokia-conf/configure/groups/group/ipsec/ts-list/local/entry/protocol/id/udp/port-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange struct {
	Begin *uint32 `path:"begin" module:"nokia-conf"`
	End   *uint32 `path:"end" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange) IsYANGGoStruct() {
}

// GetBegin retrieves the value of the leaf Begin from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Begin is set, it can
// safely use t.GetBegin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Begin == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange) GetBegin() uint32 {
	if t == nil || t.Begin == nil {
		return 0
	}
	return *t.Begin
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange) GetEnd() uint32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Local_Entry_Protocol_Id_Udp_PortRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote struct {
	Entry map[NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry `path:"entry" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote) NewEntry(Id NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote) GetEntry(Id NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote) AppendEntry(v *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry struct {
	Address  *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address  `path:"address" module:"nokia-conf" yangPresence:"true"`
	Id       NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Id_Union  `path:"id" module:"nokia-conf"`
	Protocol *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol `path:"protocol" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) IsYANGGoStruct() {}

// GetOrCreateAddress retrieves the value of the Address field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) GetOrCreateAddress() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address {
	if t.Address != nil {
		return t.Address
	}
	t.Address = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address{}
	return t.Address
}

// GetOrCreateProtocol retrieves the value of the Protocol field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) GetOrCreateProtocol() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol {
	if t.Protocol != nil {
		return t.Protocol
	}
	t.Protocol = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol{}
	return t.Protocol
}

// GetAddress returns the value of the Address struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry. If the receiver or the field Address is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) GetAddress() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address {
	if t != nil && t.Address != nil {
		return t.Address
	}
	return nil
}

// GetProtocol returns the value of the Protocol struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry. If the receiver or the field Protocol is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) GetProtocol() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol {
	if t != nil && t.Protocol != nil {
		return t.Protocol
	}
	return nil
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) GetId() NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Address.PopulateDefaults()
	t.Protocol.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/address YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address struct {
	Prefix *string                                                                   `path:"prefix" module:"nokia-conf"`
	Range  *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range `path:"range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address) IsYANGGoStruct() {}

// GetOrCreateRange retrieves the value of the Range field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address) GetOrCreateRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range {
	if t.Range != nil {
		return t.Range
	}
	t.Range = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range{}
	return t.Range
}

// GetRange returns the value of the Range struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address. If the receiver or the field Range is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address) GetRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range {
	if t != nil && t.Range != nil {
		return t.Range
	}
	return nil
}

// GetPrefix retrieves the value of the leaf Prefix from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Prefix is set, it can
// safely use t.GetPrefix() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Prefix == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address) GetPrefix() string {
	if t == nil || t.Prefix == nil {
		return ""
	}
	return *t.Prefix
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Range.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/address/range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range struct {
	Begin *string `path:"begin" module:"nokia-conf"`
	End   *string `path:"end" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range) IsYANGGoStruct() {}

// GetBegin retrieves the value of the leaf Begin from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Begin is set, it can
// safely use t.GetBegin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Begin == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range) GetBegin() string {
	if t == nil || t.Begin == nil {
		return ""
	}
	return *t.Begin
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range) GetEnd() string {
	if t == nil || t.End == nil {
		return ""
	}
	return *t.End
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Address_Range) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol struct {
	Any YANGEmpty                                                               `path:"any" module:"nokia-conf"`
	Id  *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id `path:"id" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol) IsYANGGoStruct() {}

// GetOrCreateId retrieves the value of the Id field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol) GetOrCreateId() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id {
	if t.Id != nil {
		return t.Id
	}
	t.Id = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id{}
	return t.Id
}

// GetId returns the value of the Id struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol. If the receiver or the field Id is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol) GetId() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id {
	if t != nil && t.Id != nil {
		return t.Id
	}
	return nil
}

// GetAny retrieves the value of the leaf Any from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Any is set, it can
// safely use t.GetAny() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Any == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol) GetAny() YANGEmpty {
	if t == nil || t.Any == false {
		return false
	}
	return t.Any
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Id.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id struct {
	Icmp                  *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp                       `path:"icmp" module:"nokia-conf"`
	Icmp6                 *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6                      `path:"icmp6" module:"nokia-conf"`
	Mipv6                 *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6                      `path:"mipv6" module:"nokia-conf"`
	ProtocolIdWithAnyPort NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_ProtocolIdWithAnyPort_Union `path:"protocol-id-with-any-port" module:"nokia-conf"`
	Sctp                  *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp                       `path:"sctp" module:"nokia-conf"`
	Tcp                   *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp                        `path:"tcp" module:"nokia-conf"`
	Udp                   *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp                        `path:"udp" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) IsYANGGoStruct() {}

// GetOrCreateIcmp retrieves the value of the Icmp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetOrCreateIcmp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp {
	if t.Icmp != nil {
		return t.Icmp
	}
	t.Icmp = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp{}
	return t.Icmp
}

// GetOrCreateIcmp6 retrieves the value of the Icmp6 field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetOrCreateIcmp6() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6 {
	if t.Icmp6 != nil {
		return t.Icmp6
	}
	t.Icmp6 = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6{}
	return t.Icmp6
}

// GetOrCreateMipv6 retrieves the value of the Mipv6 field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetOrCreateMipv6() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6 {
	if t.Mipv6 != nil {
		return t.Mipv6
	}
	t.Mipv6 = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6{}
	return t.Mipv6
}

// GetOrCreateSctp retrieves the value of the Sctp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetOrCreateSctp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp {
	if t.Sctp != nil {
		return t.Sctp
	}
	t.Sctp = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp{}
	return t.Sctp
}

// GetOrCreateTcp retrieves the value of the Tcp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetOrCreateTcp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp {
	if t.Tcp != nil {
		return t.Tcp
	}
	t.Tcp = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp{}
	return t.Tcp
}

// GetOrCreateUdp retrieves the value of the Udp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetOrCreateUdp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp {
	if t.Udp != nil {
		return t.Udp
	}
	t.Udp = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp{}
	return t.Udp
}

// GetIcmp returns the value of the Icmp struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id. If the receiver or the field Icmp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetIcmp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp {
	if t != nil && t.Icmp != nil {
		return t.Icmp
	}
	return nil
}

// GetIcmp6 returns the value of the Icmp6 struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id. If the receiver or the field Icmp6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetIcmp6() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6 {
	if t != nil && t.Icmp6 != nil {
		return t.Icmp6
	}
	return nil
}

// GetMipv6 returns the value of the Mipv6 struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id. If the receiver or the field Mipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetMipv6() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6 {
	if t != nil && t.Mipv6 != nil {
		return t.Mipv6
	}
	return nil
}

// GetSctp returns the value of the Sctp struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id. If the receiver or the field Sctp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetSctp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp {
	if t != nil && t.Sctp != nil {
		return t.Sctp
	}
	return nil
}

// GetTcp returns the value of the Tcp struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id. If the receiver or the field Tcp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetTcp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp {
	if t != nil && t.Tcp != nil {
		return t.Tcp
	}
	return nil
}

// GetUdp returns the value of the Udp struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id. If the receiver or the field Udp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetUdp() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp {
	if t != nil && t.Udp != nil {
		return t.Udp
	}
	return nil
}

// GetProtocolIdWithAnyPort retrieves the value of the leaf ProtocolIdWithAnyPort from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ProtocolIdWithAnyPort is set, it can
// safely use t.GetProtocolIdWithAnyPort() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ProtocolIdWithAnyPort == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) GetProtocolIdWithAnyPort() NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_ProtocolIdWithAnyPort_Union {
	if t == nil || t.ProtocolIdWithAnyPort == nil {
		return nil
	}
	return t.ProtocolIdWithAnyPort
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Icmp.PopulateDefaults()
	t.Icmp6.PopulateDefaults()
	t.Mipv6.PopulateDefaults()
	t.Sctp.PopulateDefaults()
	t.Tcp.PopulateDefaults()
	t.Udp.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id/icmp YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp struct {
	Opaque    YANGEmpty                                                                              `path:"opaque" module:"nokia-conf"`
	PortRange *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange `path:"port-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp) IsYANGGoStruct() {
}

// GetOrCreatePortRange retrieves the value of the PortRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp) GetOrCreatePortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange {
	if t.PortRange != nil {
		return t.PortRange
	}
	t.PortRange = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange{}
	return t.PortRange
}

// GetPortRange returns the value of the PortRange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp. If the receiver or the field PortRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp) GetPortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange {
	if t != nil && t.PortRange != nil {
		return t.PortRange
	}
	return nil
}

// GetOpaque retrieves the value of the leaf Opaque from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Opaque is set, it can
// safely use t.GetOpaque() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Opaque == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp) GetOpaque() YANGEmpty {
	if t == nil || t.Opaque == false {
		return false
	}
	return t.Opaque
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PortRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6 represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id/icmp6 YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6 struct {
	Opaque    YANGEmpty                                                                               `path:"opaque" module:"nokia-conf"`
	PortRange *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange `path:"port-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6) IsYANGGoStruct() {
}

// GetOrCreatePortRange retrieves the value of the PortRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6) GetOrCreatePortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange {
	if t.PortRange != nil {
		return t.PortRange
	}
	t.PortRange = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange{}
	return t.PortRange
}

// GetPortRange returns the value of the PortRange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6. If the receiver or the field PortRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6) GetPortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange {
	if t != nil && t.PortRange != nil {
		return t.PortRange
	}
	return nil
}

// GetOpaque retrieves the value of the leaf Opaque from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Opaque is set, it can
// safely use t.GetOpaque() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Opaque == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6) GetOpaque() YANGEmpty {
	if t == nil || t.Opaque == false {
		return false
	}
	return t.Opaque
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PortRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id/icmp6/port-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange struct {
	BeginIcmpCode *uint16 `path:"begin-icmp-code" module:"nokia-conf"`
	BeginIcmpType *uint16 `path:"begin-icmp-type" module:"nokia-conf"`
	EndIcmpCode   *uint16 `path:"end-icmp-code" module:"nokia-conf"`
	EndIcmpType   *uint16 `path:"end-icmp-type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange) IsYANGGoStruct() {
}

// GetBeginIcmpCode retrieves the value of the leaf BeginIcmpCode from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BeginIcmpCode is set, it can
// safely use t.GetBeginIcmpCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BeginIcmpCode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange) GetBeginIcmpCode() uint16 {
	if t == nil || t.BeginIcmpCode == nil {
		return 0
	}
	return *t.BeginIcmpCode
}

// GetBeginIcmpType retrieves the value of the leaf BeginIcmpType from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BeginIcmpType is set, it can
// safely use t.GetBeginIcmpType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BeginIcmpType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange) GetBeginIcmpType() uint16 {
	if t == nil || t.BeginIcmpType == nil {
		return 0
	}
	return *t.BeginIcmpType
}

// GetEndIcmpCode retrieves the value of the leaf EndIcmpCode from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndIcmpCode is set, it can
// safely use t.GetEndIcmpCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndIcmpCode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange) GetEndIcmpCode() uint16 {
	if t == nil || t.EndIcmpCode == nil {
		return 0
	}
	return *t.EndIcmpCode
}

// GetEndIcmpType retrieves the value of the leaf EndIcmpType from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndIcmpType is set, it can
// safely use t.GetEndIcmpType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndIcmpType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange) GetEndIcmpType() uint16 {
	if t == nil || t.EndIcmpType == nil {
		return 0
	}
	return *t.EndIcmpType
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp6_PortRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id/icmp/port-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange struct {
	BeginIcmpCode *uint16 `path:"begin-icmp-code" module:"nokia-conf"`
	BeginIcmpType *uint16 `path:"begin-icmp-type" module:"nokia-conf"`
	EndIcmpCode   *uint16 `path:"end-icmp-code" module:"nokia-conf"`
	EndIcmpType   *uint16 `path:"end-icmp-type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange) IsYANGGoStruct() {
}

// GetBeginIcmpCode retrieves the value of the leaf BeginIcmpCode from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BeginIcmpCode is set, it can
// safely use t.GetBeginIcmpCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BeginIcmpCode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange) GetBeginIcmpCode() uint16 {
	if t == nil || t.BeginIcmpCode == nil {
		return 0
	}
	return *t.BeginIcmpCode
}

// GetBeginIcmpType retrieves the value of the leaf BeginIcmpType from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BeginIcmpType is set, it can
// safely use t.GetBeginIcmpType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BeginIcmpType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange) GetBeginIcmpType() uint16 {
	if t == nil || t.BeginIcmpType == nil {
		return 0
	}
	return *t.BeginIcmpType
}

// GetEndIcmpCode retrieves the value of the leaf EndIcmpCode from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndIcmpCode is set, it can
// safely use t.GetEndIcmpCode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndIcmpCode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange) GetEndIcmpCode() uint16 {
	if t == nil || t.EndIcmpCode == nil {
		return 0
	}
	return *t.EndIcmpCode
}

// GetEndIcmpType retrieves the value of the leaf EndIcmpType from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EndIcmpType is set, it can
// safely use t.GetEndIcmpType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EndIcmpType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange) GetEndIcmpType() uint16 {
	if t == nil || t.EndIcmpType == nil {
		return 0
	}
	return *t.EndIcmpType
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Icmp_PortRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6 represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id/mipv6 YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6 struct {
	Opaque    YANGEmpty                                                                               `path:"opaque" module:"nokia-conf"`
	PortRange *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange `path:"port-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6) IsYANGGoStruct() {
}

// GetOrCreatePortRange retrieves the value of the PortRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6) GetOrCreatePortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange {
	if t.PortRange != nil {
		return t.PortRange
	}
	t.PortRange = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange{}
	return t.PortRange
}

// GetPortRange returns the value of the PortRange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6. If the receiver or the field PortRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6) GetPortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange {
	if t != nil && t.PortRange != nil {
		return t.PortRange
	}
	return nil
}

// GetOpaque retrieves the value of the leaf Opaque from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Opaque is set, it can
// safely use t.GetOpaque() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Opaque == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6) GetOpaque() YANGEmpty {
	if t == nil || t.Opaque == false {
		return false
	}
	return t.Opaque
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PortRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id/mipv6/port-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange struct {
	Begin *uint16 `path:"begin" module:"nokia-conf"`
	End   *uint16 `path:"end" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange) IsYANGGoStruct() {
}

// GetBegin retrieves the value of the leaf Begin from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Begin is set, it can
// safely use t.GetBegin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Begin == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange) GetBegin() uint16 {
	if t == nil || t.Begin == nil {
		return 0
	}
	return *t.Begin
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange) GetEnd() uint16 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Mipv6_PortRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id/sctp YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp struct {
	Opaque    YANGEmpty                                                                              `path:"opaque" module:"nokia-conf"`
	PortRange *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange `path:"port-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp) IsYANGGoStruct() {
}

// GetOrCreatePortRange retrieves the value of the PortRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp) GetOrCreatePortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange {
	if t.PortRange != nil {
		return t.PortRange
	}
	t.PortRange = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange{}
	return t.PortRange
}

// GetPortRange returns the value of the PortRange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp. If the receiver or the field PortRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp) GetPortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange {
	if t != nil && t.PortRange != nil {
		return t.PortRange
	}
	return nil
}

// GetOpaque retrieves the value of the leaf Opaque from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Opaque is set, it can
// safely use t.GetOpaque() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Opaque == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp) GetOpaque() YANGEmpty {
	if t == nil || t.Opaque == false {
		return false
	}
	return t.Opaque
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PortRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id/sctp/port-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange struct {
	Begin *uint32 `path:"begin" module:"nokia-conf"`
	End   *uint32 `path:"end" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange) IsYANGGoStruct() {
}

// GetBegin retrieves the value of the leaf Begin from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Begin is set, it can
// safely use t.GetBegin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Begin == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange) GetBegin() uint32 {
	if t == nil || t.Begin == nil {
		return 0
	}
	return *t.Begin
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange) GetEnd() uint32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Sctp_PortRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id/tcp YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp struct {
	Opaque    YANGEmpty                                                                             `path:"opaque" module:"nokia-conf"`
	PortRange *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange `path:"port-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp) IsYANGGoStruct() {}

// GetOrCreatePortRange retrieves the value of the PortRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp) GetOrCreatePortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange {
	if t.PortRange != nil {
		return t.PortRange
	}
	t.PortRange = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange{}
	return t.PortRange
}

// GetPortRange returns the value of the PortRange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp. If the receiver or the field PortRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp) GetPortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange {
	if t != nil && t.PortRange != nil {
		return t.PortRange
	}
	return nil
}

// GetOpaque retrieves the value of the leaf Opaque from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Opaque is set, it can
// safely use t.GetOpaque() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Opaque == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp) GetOpaque() YANGEmpty {
	if t == nil || t.Opaque == false {
		return false
	}
	return t.Opaque
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PortRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id/tcp/port-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange struct {
	Begin *uint32 `path:"begin" module:"nokia-conf"`
	End   *uint32 `path:"end" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange) IsYANGGoStruct() {
}

// GetBegin retrieves the value of the leaf Begin from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Begin is set, it can
// safely use t.GetBegin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Begin == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange) GetBegin() uint32 {
	if t == nil || t.Begin == nil {
		return 0
	}
	return *t.Begin
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange) GetEnd() uint32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Tcp_PortRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id/udp YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp struct {
	Opaque    YANGEmpty                                                                             `path:"opaque" module:"nokia-conf"`
	PortRange *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange `path:"port-range" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp) IsYANGGoStruct() {}

// GetOrCreatePortRange retrieves the value of the PortRange field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp) GetOrCreatePortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange {
	if t.PortRange != nil {
		return t.PortRange
	}
	t.PortRange = &NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange{}
	return t.PortRange
}

// GetPortRange returns the value of the PortRange struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp. If the receiver or the field PortRange is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp) GetPortRange() *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange {
	if t != nil && t.PortRange != nil {
		return t.PortRange
	}
	return nil
}

// GetOpaque retrieves the value of the leaf Opaque from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Opaque is set, it can
// safely use t.GetOpaque() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Opaque == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp) GetOpaque() YANGEmpty {
	if t == nil || t.Opaque == false {
		return false
	}
	return t.Opaque
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PortRange.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange represents the /nokia-conf/configure/groups/group/ipsec/ts-list/remote/entry/protocol/id/udp/port-range YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange struct {
	Begin *uint32 `path:"begin" module:"nokia-conf"`
	End   *uint32 `path:"end" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange) IsYANGGoStruct() {
}

// GetBegin retrieves the value of the leaf Begin from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Begin is set, it can
// safely use t.GetBegin() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Begin == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange) GetBegin() uint32 {
	if t == nil || t.Begin == nil {
		return 0
	}
	return *t.Begin
}

// GetEnd retrieves the value of the leaf End from the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if End is set, it can
// safely use t.GetEnd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.End == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange) GetEnd() uint32 {
	if t == nil || t.End == nil {
		return 0
	}
	return *t.End
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TsList_Remote_Entry_Protocol_Id_Udp_PortRange) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate represents the /nokia-conf/configure/groups/group/ipsec/tunnel-template YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate struct {
	ClearDfBit                        *bool                                                                          `path:"clear-df-bit" module:"nokia-conf"`
	CopyTrafficClassUponDecapsulation *bool                                                                          `path:"copy-traffic-class-upon-decapsulation" module:"nokia-conf"`
	Description                       *string                                                                        `path:"description" module:"nokia-conf"`
	EncapsulatedIpMtu                 *uint32                                                                        `path:"encapsulated-ip-mtu" module:"nokia-conf"`
	IcmpGeneration                    *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration          `path:"icmp-generation" module:"nokia-conf"`
	Icmp6Generation                   *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation         `path:"icmp6-generation" module:"nokia-conf"`
	Id                                NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Id_Union                 `path:"id" module:"nokia-conf"`
	IgnoreDefaultRoute                *bool                                                                          `path:"ignore-default-route" module:"nokia-conf"`
	IpMtu                             *uint32                                                                        `path:"ip-mtu" module:"nokia-conf"`
	IpsecTransform                    []uint32                                                                       `path:"ipsec-transform" module:"nokia-conf"`
	PmtuDiscoveryAging                *uint32                                                                        `path:"pmtu-discovery-aging" module:"nokia-conf"`
	PrivateTcpMssAdjust               *int32                                                                         `path:"private-tcp-mss-adjust" module:"nokia-conf"`
	PropagatePmtuV4                   *bool                                                                          `path:"propagate-pmtu-v4" module:"nokia-conf"`
	PropagatePmtuV6                   *bool                                                                          `path:"propagate-pmtu-v6" module:"nokia-conf"`
	PublicTcpMssAdjust                NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_PublicTcpMssAdjust_Union `path:"public-tcp-mss-adjust" module:"nokia-conf"`
	ReplayWindow                      *uint32                                                                        `path:"replay-window" module:"nokia-conf"`
	SpReverseRoute                    E_NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_SpReverseRoute         `path:"sp-reverse-route" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) IsYANGGoStruct() {}

// GetOrCreateIcmpGeneration retrieves the value of the IcmpGeneration field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetOrCreateIcmpGeneration() *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration {
	if t.IcmpGeneration != nil {
		return t.IcmpGeneration
	}
	t.IcmpGeneration = &NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration{}
	return t.IcmpGeneration
}

// GetOrCreateIcmp6Generation retrieves the value of the Icmp6Generation field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetOrCreateIcmp6Generation() *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation {
	if t.Icmp6Generation != nil {
		return t.Icmp6Generation
	}
	t.Icmp6Generation = &NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation{}
	return t.Icmp6Generation
}

// GetIcmpGeneration returns the value of the IcmpGeneration struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate. If the receiver or the field IcmpGeneration is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetIcmpGeneration() *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration {
	if t != nil && t.IcmpGeneration != nil {
		return t.IcmpGeneration
	}
	return nil
}

// GetIcmp6Generation returns the value of the Icmp6Generation struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate. If the receiver or the field Icmp6Generation is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetIcmp6Generation() *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation {
	if t != nil && t.Icmp6Generation != nil {
		return t.Icmp6Generation
	}
	return nil
}

// GetClearDfBit retrieves the value of the leaf ClearDfBit from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClearDfBit is set, it can
// safely use t.GetClearDfBit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClearDfBit == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetClearDfBit() bool {
	if t == nil || t.ClearDfBit == nil {
		return false
	}
	return *t.ClearDfBit
}

// GetCopyTrafficClassUponDecapsulation retrieves the value of the leaf CopyTrafficClassUponDecapsulation from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CopyTrafficClassUponDecapsulation is set, it can
// safely use t.GetCopyTrafficClassUponDecapsulation() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CopyTrafficClassUponDecapsulation == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetCopyTrafficClassUponDecapsulation() bool {
	if t == nil || t.CopyTrafficClassUponDecapsulation == nil {
		return false
	}
	return *t.CopyTrafficClassUponDecapsulation
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEncapsulatedIpMtu retrieves the value of the leaf EncapsulatedIpMtu from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapsulatedIpMtu is set, it can
// safely use t.GetEncapsulatedIpMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapsulatedIpMtu == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetEncapsulatedIpMtu() uint32 {
	if t == nil || t.EncapsulatedIpMtu == nil {
		return 0
	}
	return *t.EncapsulatedIpMtu
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetId() NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// GetIgnoreDefaultRoute retrieves the value of the leaf IgnoreDefaultRoute from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IgnoreDefaultRoute is set, it can
// safely use t.GetIgnoreDefaultRoute() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IgnoreDefaultRoute == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetIgnoreDefaultRoute() bool {
	if t == nil || t.IgnoreDefaultRoute == nil {
		return false
	}
	return *t.IgnoreDefaultRoute
}

// GetIpMtu retrieves the value of the leaf IpMtu from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMtu is set, it can
// safely use t.GetIpMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMtu == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetIpMtu() uint32 {
	if t == nil || t.IpMtu == nil {
		return 0
	}
	return *t.IpMtu
}

// GetIpsecTransform retrieves the value of the leaf IpsecTransform from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpsecTransform is set, it can
// safely use t.GetIpsecTransform() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpsecTransform == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetIpsecTransform() []uint32 {
	if t == nil || t.IpsecTransform == nil {
		return nil
	}
	return t.IpsecTransform
}

// GetPmtuDiscoveryAging retrieves the value of the leaf PmtuDiscoveryAging from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PmtuDiscoveryAging is set, it can
// safely use t.GetPmtuDiscoveryAging() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PmtuDiscoveryAging == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetPmtuDiscoveryAging() uint32 {
	if t == nil || t.PmtuDiscoveryAging == nil {
		return 900
	}
	return *t.PmtuDiscoveryAging
}

// GetPrivateTcpMssAdjust retrieves the value of the leaf PrivateTcpMssAdjust from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PrivateTcpMssAdjust is set, it can
// safely use t.GetPrivateTcpMssAdjust() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PrivateTcpMssAdjust == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetPrivateTcpMssAdjust() int32 {
	if t == nil || t.PrivateTcpMssAdjust == nil {
		return 0
	}
	return *t.PrivateTcpMssAdjust
}

// GetPropagatePmtuV4 retrieves the value of the leaf PropagatePmtuV4 from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PropagatePmtuV4 is set, it can
// safely use t.GetPropagatePmtuV4() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PropagatePmtuV4 == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetPropagatePmtuV4() bool {
	if t == nil || t.PropagatePmtuV4 == nil {
		return true
	}
	return *t.PropagatePmtuV4
}

// GetPropagatePmtuV6 retrieves the value of the leaf PropagatePmtuV6 from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PropagatePmtuV6 is set, it can
// safely use t.GetPropagatePmtuV6() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PropagatePmtuV6 == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetPropagatePmtuV6() bool {
	if t == nil || t.PropagatePmtuV6 == nil {
		return true
	}
	return *t.PropagatePmtuV6
}

// GetPublicTcpMssAdjust retrieves the value of the leaf PublicTcpMssAdjust from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PublicTcpMssAdjust is set, it can
// safely use t.GetPublicTcpMssAdjust() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PublicTcpMssAdjust == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetPublicTcpMssAdjust() NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_PublicTcpMssAdjust_Union {
	if t == nil || t.PublicTcpMssAdjust == nil {
		return nil
	}
	return t.PublicTcpMssAdjust
}

// GetReplayWindow retrieves the value of the leaf ReplayWindow from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReplayWindow is set, it can
// safely use t.GetReplayWindow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReplayWindow == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetReplayWindow() uint32 {
	if t == nil || t.ReplayWindow == nil {
		return 0
	}
	return *t.ReplayWindow
}

// GetSpReverseRoute retrieves the value of the leaf SpReverseRoute from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SpReverseRoute is set, it can
// safely use t.GetSpReverseRoute() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SpReverseRoute == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) GetSpReverseRoute() E_NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_SpReverseRoute {
	if t == nil || t.SpReverseRoute == 0 {
		return NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_SpReverseRoute_none
	}
	return t.SpReverseRoute
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ClearDfBit == nil {
		var v bool = false
		t.ClearDfBit = &v
	}
	if t.CopyTrafficClassUponDecapsulation == nil {
		var v bool = false
		t.CopyTrafficClassUponDecapsulation = &v
	}
	if t.IgnoreDefaultRoute == nil {
		var v bool = false
		t.IgnoreDefaultRoute = &v
	}
	if t.PmtuDiscoveryAging == nil {
		var v uint32 = 900
		t.PmtuDiscoveryAging = &v
	}
	if t.PropagatePmtuV4 == nil {
		var v bool = true
		t.PropagatePmtuV4 = &v
	}
	if t.PropagatePmtuV6 == nil {
		var v bool = true
		t.PropagatePmtuV6 = &v
	}
	if t.SpReverseRoute == 0 {
		t.SpReverseRoute = NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_SpReverseRoute_none
	}
	t.IcmpGeneration.PopulateDefaults()
	t.Icmp6Generation.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation represents the /nokia-conf/configure/groups/group/ipsec/tunnel-template/icmp6-generation YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation struct {
	PktTooBig *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig `path:"pkt-too-big" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation) IsYANGGoStruct() {}

// GetOrCreatePktTooBig retrieves the value of the PktTooBig field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation) GetOrCreatePktTooBig() *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig {
	if t.PktTooBig != nil {
		return t.PktTooBig
	}
	t.PktTooBig = &NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig{}
	return t.PktTooBig
}

// GetPktTooBig returns the value of the PktTooBig struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation. If the receiver or the field PktTooBig is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation) GetPktTooBig() *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig {
	if t != nil && t.PktTooBig != nil {
		return t.PktTooBig
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.PktTooBig.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig represents the /nokia-conf/configure/groups/group/ipsec/tunnel-template/icmp6-generation/pkt-too-big YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig struct {
	AdminState   E_NokiaTypesSros_AdminState `path:"admin-state" module:"nokia-conf"`
	Interval     *uint32                     `path:"interval" module:"nokia-conf"`
	MessageCount *uint32                     `path:"message-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig) IsYANGGoStruct() {
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetInterval retrieves the value of the leaf Interval from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 10
	}
	return *t.Interval
}

// GetMessageCount retrieves the value of the leaf MessageCount from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MessageCount is set, it can
// safely use t.GetMessageCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MessageCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig) GetMessageCount() uint32 {
	if t == nil || t.MessageCount == nil {
		return 100
	}
	return *t.MessageCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	if t.Interval == nil {
		var v uint32 = 10
		t.Interval = &v
	}
	if t.MessageCount == nil {
		var v uint32 = 100
		t.MessageCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_Icmp6Generation_PktTooBig) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration represents the /nokia-conf/configure/groups/group/ipsec/tunnel-template/icmp-generation YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration struct {
	FragRequired *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired `path:"frag-required" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration) IsYANGGoStruct() {}

// GetOrCreateFragRequired retrieves the value of the FragRequired field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration) GetOrCreateFragRequired() *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired {
	if t.FragRequired != nil {
		return t.FragRequired
	}
	t.FragRequired = &NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired{}
	return t.FragRequired
}

// GetFragRequired returns the value of the FragRequired struct pointer
// from NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration. If the receiver or the field FragRequired is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration) GetFragRequired() *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired {
	if t != nil && t.FragRequired != nil {
		return t.FragRequired
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.FragRequired.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired represents the /nokia-conf/configure/groups/group/ipsec/tunnel-template/icmp-generation/frag-required YANG schema element.
type NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired struct {
	AdminState   E_NokiaTypesSros_AdminState `path:"admin-state" module:"nokia-conf"`
	Interval     *uint32                     `path:"interval" module:"nokia-conf"`
	MessageCount *uint32                     `path:"message-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired) IsYANGGoStruct() {
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetInterval retrieves the value of the leaf Interval from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 10
	}
	return *t.Interval
}

// GetMessageCount retrieves the value of the leaf MessageCount from the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MessageCount is set, it can
// safely use t.GetMessageCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MessageCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired) GetMessageCount() uint32 {
	if t == nil || t.MessageCount == nil {
		return 100
	}
	return *t.MessageCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	if t.Interval == nil {
		var v uint32 = 10
		t.Interval = &v
	}
	if t.MessageCount == nil {
		var v uint32 = 100
		t.MessageCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired.
func (*NokiaConf_Configure_Groups_Group_Ipsec_TunnelTemplate_IcmpGeneration_FragRequired) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa represents the /nokia-conf/configure/groups/group/isa YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa struct {
	ApplicationAssuranceGroup map[NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_AaGroupId_Union]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup `path:"application-assurance-group" module:"nokia-conf"`
	LnsGroup                  map[NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Id_Union]*NokiaConf_Configure_Groups_Group_Isa_LnsGroup                                          `path:"lns-group" module:"nokia-conf"`
	NatGroup                  map[NokiaConf_Configure_Groups_Group_Isa_NatGroup_Id_Union]*NokiaConf_Configure_Groups_Group_Isa_NatGroup                                          `path:"nat-group" module:"nokia-conf"`
	TunnelGroup               map[NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Id_Union]*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup                                    `path:"tunnel-group" module:"nokia-conf"`
	VideoGroup                map[NokiaConf_Configure_Groups_Group_Isa_VideoGroup_VideoGroupId_Union]*NokiaConf_Configure_Groups_Group_Isa_VideoGroup                            `path:"video-group" module:"nokia-conf"`
	WlanGwGroup               map[NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Id_Union]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup                                    `path:"wlan-gw-group" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa) IsYANGGoStruct() {}

// NewApplicationAssuranceGroup creates a new entry in the ApplicationAssuranceGroup list of the
// NokiaConf_Configure_Groups_Group_Isa struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa) NewApplicationAssuranceGroup(AaGroupId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_AaGroupId_Union) (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ApplicationAssuranceGroup == nil {
		t.ApplicationAssuranceGroup = make(map[NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_AaGroupId_Union]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup)
	}

	key := AaGroupId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ApplicationAssuranceGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ApplicationAssuranceGroup", key)
	}

	t.ApplicationAssuranceGroup[key] = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup{
		AaGroupId: AaGroupId,
	}

	return t.ApplicationAssuranceGroup[key], nil
}

// RenameApplicationAssuranceGroup renames an entry in the list ApplicationAssuranceGroup within
// the NokiaConf_Configure_Groups_Group_Isa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa) RenameApplicationAssuranceGroup(oldK, newK NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_AaGroupId_Union) error {
	if _, ok := t.ApplicationAssuranceGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in ApplicationAssuranceGroup", newK)
	}

	e, ok := t.ApplicationAssuranceGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ApplicationAssuranceGroup", oldK)
	}
	e.AaGroupId = newK

	t.ApplicationAssuranceGroup[newK] = e
	delete(t.ApplicationAssuranceGroup, oldK)
	return nil
}

// GetOrCreateApplicationAssuranceGroup retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa) GetOrCreateApplicationAssuranceGroup(AaGroupId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_AaGroupId_Union) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup {

	key := AaGroupId

	if v, ok := t.ApplicationAssuranceGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewApplicationAssuranceGroup(AaGroupId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateApplicationAssuranceGroup got unexpected error: %v", err))
	}
	return v
}

// GetApplicationAssuranceGroup retrieves the value with the specified key from
// the ApplicationAssuranceGroup map field of NokiaConf_Configure_Groups_Group_Isa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa) GetApplicationAssuranceGroup(AaGroupId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_AaGroupId_Union) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup {

	if t == nil {
		return nil
	}

	key := AaGroupId

	if lm, ok := t.ApplicationAssuranceGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteApplicationAssuranceGroup deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa) DeleteApplicationAssuranceGroup(AaGroupId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_AaGroupId_Union) {
	key := AaGroupId

	delete(t.ApplicationAssuranceGroup, key)
}

// AppendApplicationAssuranceGroup appends the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup struct to the
// list ApplicationAssuranceGroup of NokiaConf_Configure_Groups_Group_Isa. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa) AppendApplicationAssuranceGroup(v *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) error {
	key := v.AaGroupId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ApplicationAssuranceGroup == nil {
		t.ApplicationAssuranceGroup = make(map[NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_AaGroupId_Union]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup)
	}

	if _, ok := t.ApplicationAssuranceGroup[key]; ok {
		return fmt.Errorf("duplicate key for list ApplicationAssuranceGroup %v", key)
	}

	t.ApplicationAssuranceGroup[key] = v
	return nil
}

// NewLnsGroup creates a new entry in the LnsGroup list of the
// NokiaConf_Configure_Groups_Group_Isa struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa) NewLnsGroup(Id NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Id_Union) (*NokiaConf_Configure_Groups_Group_Isa_LnsGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LnsGroup == nil {
		t.LnsGroup = make(map[NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Id_Union]*NokiaConf_Configure_Groups_Group_Isa_LnsGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LnsGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LnsGroup", key)
	}

	t.LnsGroup[key] = &NokiaConf_Configure_Groups_Group_Isa_LnsGroup{
		Id: Id,
	}

	return t.LnsGroup[key], nil
}

// RenameLnsGroup renames an entry in the list LnsGroup within
// the NokiaConf_Configure_Groups_Group_Isa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa) RenameLnsGroup(oldK, newK NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Id_Union) error {
	if _, ok := t.LnsGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in LnsGroup", newK)
	}

	e, ok := t.LnsGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LnsGroup", oldK)
	}
	e.Id = newK

	t.LnsGroup[newK] = e
	delete(t.LnsGroup, oldK)
	return nil
}

// GetOrCreateLnsGroup retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa) GetOrCreateLnsGroup(Id NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Id_Union) *NokiaConf_Configure_Groups_Group_Isa_LnsGroup {

	key := Id

	if v, ok := t.LnsGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLnsGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLnsGroup got unexpected error: %v", err))
	}
	return v
}

// GetLnsGroup retrieves the value with the specified key from
// the LnsGroup map field of NokiaConf_Configure_Groups_Group_Isa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa) GetLnsGroup(Id NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Id_Union) *NokiaConf_Configure_Groups_Group_Isa_LnsGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.LnsGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteLnsGroup deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa) DeleteLnsGroup(Id NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Id_Union) {
	key := Id

	delete(t.LnsGroup, key)
}

// AppendLnsGroup appends the supplied NokiaConf_Configure_Groups_Group_Isa_LnsGroup struct to the
// list LnsGroup of NokiaConf_Configure_Groups_Group_Isa. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_LnsGroup already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa) AppendLnsGroup(v *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LnsGroup == nil {
		t.LnsGroup = make(map[NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Id_Union]*NokiaConf_Configure_Groups_Group_Isa_LnsGroup)
	}

	if _, ok := t.LnsGroup[key]; ok {
		return fmt.Errorf("duplicate key for list LnsGroup %v", key)
	}

	t.LnsGroup[key] = v
	return nil
}

// NewNatGroup creates a new entry in the NatGroup list of the
// NokiaConf_Configure_Groups_Group_Isa struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa) NewNatGroup(Id NokiaConf_Configure_Groups_Group_Isa_NatGroup_Id_Union) (*NokiaConf_Configure_Groups_Group_Isa_NatGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NatGroup == nil {
		t.NatGroup = make(map[NokiaConf_Configure_Groups_Group_Isa_NatGroup_Id_Union]*NokiaConf_Configure_Groups_Group_Isa_NatGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.NatGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list NatGroup", key)
	}

	t.NatGroup[key] = &NokiaConf_Configure_Groups_Group_Isa_NatGroup{
		Id: Id,
	}

	return t.NatGroup[key], nil
}

// RenameNatGroup renames an entry in the list NatGroup within
// the NokiaConf_Configure_Groups_Group_Isa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa) RenameNatGroup(oldK, newK NokiaConf_Configure_Groups_Group_Isa_NatGroup_Id_Union) error {
	if _, ok := t.NatGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in NatGroup", newK)
	}

	e, ok := t.NatGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in NatGroup", oldK)
	}
	e.Id = newK

	t.NatGroup[newK] = e
	delete(t.NatGroup, oldK)
	return nil
}

// GetOrCreateNatGroup retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa) GetOrCreateNatGroup(Id NokiaConf_Configure_Groups_Group_Isa_NatGroup_Id_Union) *NokiaConf_Configure_Groups_Group_Isa_NatGroup {

	key := Id

	if v, ok := t.NatGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNatGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNatGroup got unexpected error: %v", err))
	}
	return v
}

// GetNatGroup retrieves the value with the specified key from
// the NatGroup map field of NokiaConf_Configure_Groups_Group_Isa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa) GetNatGroup(Id NokiaConf_Configure_Groups_Group_Isa_NatGroup_Id_Union) *NokiaConf_Configure_Groups_Group_Isa_NatGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.NatGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteNatGroup deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa) DeleteNatGroup(Id NokiaConf_Configure_Groups_Group_Isa_NatGroup_Id_Union) {
	key := Id

	delete(t.NatGroup, key)
}

// AppendNatGroup appends the supplied NokiaConf_Configure_Groups_Group_Isa_NatGroup struct to the
// list NatGroup of NokiaConf_Configure_Groups_Group_Isa. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_NatGroup already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa) AppendNatGroup(v *NokiaConf_Configure_Groups_Group_Isa_NatGroup) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.NatGroup == nil {
		t.NatGroup = make(map[NokiaConf_Configure_Groups_Group_Isa_NatGroup_Id_Union]*NokiaConf_Configure_Groups_Group_Isa_NatGroup)
	}

	if _, ok := t.NatGroup[key]; ok {
		return fmt.Errorf("duplicate key for list NatGroup %v", key)
	}

	t.NatGroup[key] = v
	return nil
}

// NewTunnelGroup creates a new entry in the TunnelGroup list of the
// NokiaConf_Configure_Groups_Group_Isa struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa) NewTunnelGroup(Id NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Id_Union) (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TunnelGroup == nil {
		t.TunnelGroup = make(map[NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Id_Union]*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TunnelGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TunnelGroup", key)
	}

	t.TunnelGroup[key] = &NokiaConf_Configure_Groups_Group_Isa_TunnelGroup{
		Id: Id,
	}

	return t.TunnelGroup[key], nil
}

// RenameTunnelGroup renames an entry in the list TunnelGroup within
// the NokiaConf_Configure_Groups_Group_Isa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa) RenameTunnelGroup(oldK, newK NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Id_Union) error {
	if _, ok := t.TunnelGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in TunnelGroup", newK)
	}

	e, ok := t.TunnelGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TunnelGroup", oldK)
	}
	e.Id = newK

	t.TunnelGroup[newK] = e
	delete(t.TunnelGroup, oldK)
	return nil
}

// GetOrCreateTunnelGroup retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa) GetOrCreateTunnelGroup(Id NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Id_Union) *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup {

	key := Id

	if v, ok := t.TunnelGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTunnelGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTunnelGroup got unexpected error: %v", err))
	}
	return v
}

// GetTunnelGroup retrieves the value with the specified key from
// the TunnelGroup map field of NokiaConf_Configure_Groups_Group_Isa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa) GetTunnelGroup(Id NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Id_Union) *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.TunnelGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteTunnelGroup deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa) DeleteTunnelGroup(Id NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Id_Union) {
	key := Id

	delete(t.TunnelGroup, key)
}

// AppendTunnelGroup appends the supplied NokiaConf_Configure_Groups_Group_Isa_TunnelGroup struct to the
// list TunnelGroup of NokiaConf_Configure_Groups_Group_Isa. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_TunnelGroup already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa) AppendTunnelGroup(v *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TunnelGroup == nil {
		t.TunnelGroup = make(map[NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Id_Union]*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup)
	}

	if _, ok := t.TunnelGroup[key]; ok {
		return fmt.Errorf("duplicate key for list TunnelGroup %v", key)
	}

	t.TunnelGroup[key] = v
	return nil
}

// NewVideoGroup creates a new entry in the VideoGroup list of the
// NokiaConf_Configure_Groups_Group_Isa struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa) NewVideoGroup(VideoGroupId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_VideoGroupId_Union) (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VideoGroup == nil {
		t.VideoGroup = make(map[NokiaConf_Configure_Groups_Group_Isa_VideoGroup_VideoGroupId_Union]*NokiaConf_Configure_Groups_Group_Isa_VideoGroup)
	}

	key := VideoGroupId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VideoGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VideoGroup", key)
	}

	t.VideoGroup[key] = &NokiaConf_Configure_Groups_Group_Isa_VideoGroup{
		VideoGroupId: VideoGroupId,
	}

	return t.VideoGroup[key], nil
}

// RenameVideoGroup renames an entry in the list VideoGroup within
// the NokiaConf_Configure_Groups_Group_Isa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa) RenameVideoGroup(oldK, newK NokiaConf_Configure_Groups_Group_Isa_VideoGroup_VideoGroupId_Union) error {
	if _, ok := t.VideoGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in VideoGroup", newK)
	}

	e, ok := t.VideoGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VideoGroup", oldK)
	}
	e.VideoGroupId = newK

	t.VideoGroup[newK] = e
	delete(t.VideoGroup, oldK)
	return nil
}

// GetOrCreateVideoGroup retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa) GetOrCreateVideoGroup(VideoGroupId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_VideoGroupId_Union) *NokiaConf_Configure_Groups_Group_Isa_VideoGroup {

	key := VideoGroupId

	if v, ok := t.VideoGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVideoGroup(VideoGroupId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVideoGroup got unexpected error: %v", err))
	}
	return v
}

// GetVideoGroup retrieves the value with the specified key from
// the VideoGroup map field of NokiaConf_Configure_Groups_Group_Isa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa) GetVideoGroup(VideoGroupId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_VideoGroupId_Union) *NokiaConf_Configure_Groups_Group_Isa_VideoGroup {

	if t == nil {
		return nil
	}

	key := VideoGroupId

	if lm, ok := t.VideoGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteVideoGroup deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa) DeleteVideoGroup(VideoGroupId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_VideoGroupId_Union) {
	key := VideoGroupId

	delete(t.VideoGroup, key)
}

// AppendVideoGroup appends the supplied NokiaConf_Configure_Groups_Group_Isa_VideoGroup struct to the
// list VideoGroup of NokiaConf_Configure_Groups_Group_Isa. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_VideoGroup already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa) AppendVideoGroup(v *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) error {
	key := v.VideoGroupId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VideoGroup == nil {
		t.VideoGroup = make(map[NokiaConf_Configure_Groups_Group_Isa_VideoGroup_VideoGroupId_Union]*NokiaConf_Configure_Groups_Group_Isa_VideoGroup)
	}

	if _, ok := t.VideoGroup[key]; ok {
		return fmt.Errorf("duplicate key for list VideoGroup %v", key)
	}

	t.VideoGroup[key] = v
	return nil
}

// NewWlanGwGroup creates a new entry in the WlanGwGroup list of the
// NokiaConf_Configure_Groups_Group_Isa struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa) NewWlanGwGroup(Id NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Id_Union) (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.WlanGwGroup == nil {
		t.WlanGwGroup = make(map[NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Id_Union]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.WlanGwGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list WlanGwGroup", key)
	}

	t.WlanGwGroup[key] = &NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup{
		Id: Id,
	}

	return t.WlanGwGroup[key], nil
}

// RenameWlanGwGroup renames an entry in the list WlanGwGroup within
// the NokiaConf_Configure_Groups_Group_Isa struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa) RenameWlanGwGroup(oldK, newK NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Id_Union) error {
	if _, ok := t.WlanGwGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in WlanGwGroup", newK)
	}

	e, ok := t.WlanGwGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in WlanGwGroup", oldK)
	}
	e.Id = newK

	t.WlanGwGroup[newK] = e
	delete(t.WlanGwGroup, oldK)
	return nil
}

// GetOrCreateWlanGwGroup retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa) GetOrCreateWlanGwGroup(Id NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Id_Union) *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup {

	key := Id

	if v, ok := t.WlanGwGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewWlanGwGroup(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateWlanGwGroup got unexpected error: %v", err))
	}
	return v
}

// GetWlanGwGroup retrieves the value with the specified key from
// the WlanGwGroup map field of NokiaConf_Configure_Groups_Group_Isa. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa) GetWlanGwGroup(Id NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Id_Union) *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.WlanGwGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteWlanGwGroup deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa) DeleteWlanGwGroup(Id NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Id_Union) {
	key := Id

	delete(t.WlanGwGroup, key)
}

// AppendWlanGwGroup appends the supplied NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup struct to the
// list WlanGwGroup of NokiaConf_Configure_Groups_Group_Isa. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa) AppendWlanGwGroup(v *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.WlanGwGroup == nil {
		t.WlanGwGroup = make(map[NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Id_Union]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup)
	}

	if _, ok := t.WlanGwGroup[key]; ok {
		return fmt.Errorf("duplicate key for list WlanGwGroup %v", key)
	}

	t.WlanGwGroup[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.ApplicationAssuranceGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.LnsGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.NatGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.TunnelGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.VideoGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.WlanGwGroup {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa.
func (*NokiaConf_Configure_Groups_Group_Isa) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup represents the /nokia-conf/configure/groups/group/isa/application-assurance-group YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup struct {
	AaGroupId                    NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_AaGroupId_Union           `path:"aa-group-id" module:"nokia-conf"`
	AaSubScale                   E_NokiaTypesApplicationAssurance_IsaAaGroupSubscale                                      `path:"aa-sub-scale" module:"nokia-conf"`
	AdminState                   E_NokiaTypesSros_AdminState                                                              `path:"admin-state" module:"nokia-conf"`
	Backup                       *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup                   `path:"backup" module:"nokia-conf"`
	Description                  *string                                                                                  `path:"description" module:"nokia-conf"`
	DivertFc                     []E_NokiaTypesSros_FcName                                                                `path:"divert-fc" module:"nokia-conf"`
	FailureMode                  E_NokiaTypesApplicationAssurance_IsaFailToMode                                           `path:"failure-mode" module:"nokia-conf"`
	FlowAttribute                map[string]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute `path:"flow-attribute" module:"nokia-conf"`
	HttpEnrichMaxPacketSize      *uint32                                                                                  `path:"http-enrich-max-packet-size" module:"nokia-conf"`
	IsaCapacityCostHighThreshold *uint32                                                                                  `path:"isa-capacity-cost-high-threshold" module:"nokia-conf"`
	IsaCapacityCostLowThreshold  *uint32                                                                                  `path:"isa-capacity-cost-low-threshold" module:"nokia-conf"`
	MinimumIsaGeneration         *uint32                                                                                  `path:"minimum-isa-generation" module:"nokia-conf"`
	OverloadCutThrough           *bool                                                                                    `path:"overload-cut-through" module:"nokia-conf"`
	OverloadSubQuarantine        *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine    `path:"overload-sub-quarantine" module:"nokia-conf"`
	Primary                      *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary                  `path:"primary" module:"nokia-conf"`
	Qos                          *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos                      `path:"qos" module:"nokia-conf"`
	SharedResources              *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources          `path:"shared-resources" module:"nokia-conf"`
	Statistics                   *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics               `path:"statistics" module:"nokia-conf"`
	TransitPrefixLimits          *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits      `path:"transit-prefix-limits" module:"nokia-conf"`
	VmTrafficDistributeByIp      *bool                                                                                    `path:"vm-traffic-distribute-by-ip" module:"nokia-conf"`
	VmTrafficDistributeByTeid    *bool                                                                                    `path:"vm-traffic-distribute-by-teid" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) IsYANGGoStruct() {}

// NewFlowAttribute creates a new entry in the FlowAttribute list of the
// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) NewFlowAttribute(FlowAttributeName string) (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.FlowAttribute == nil {
		t.FlowAttribute = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute)
	}

	key := FlowAttributeName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.FlowAttribute[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list FlowAttribute", key)
	}

	t.FlowAttribute[key] = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute{
		FlowAttributeName: &FlowAttributeName,
	}

	return t.FlowAttribute[key], nil
}

// RenameFlowAttribute renames an entry in the list FlowAttribute within
// the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) RenameFlowAttribute(oldK, newK string) error {
	if _, ok := t.FlowAttribute[newK]; ok {
		return fmt.Errorf("key %v already exists in FlowAttribute", newK)
	}

	e, ok := t.FlowAttribute[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in FlowAttribute", oldK)
	}
	e.FlowAttributeName = &newK

	t.FlowAttribute[newK] = e
	delete(t.FlowAttribute, oldK)
	return nil
}

// GetOrCreateFlowAttribute retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetOrCreateFlowAttribute(FlowAttributeName string) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute {

	key := FlowAttributeName

	if v, ok := t.FlowAttribute[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFlowAttribute(FlowAttributeName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFlowAttribute got unexpected error: %v", err))
	}
	return v
}

// GetFlowAttribute retrieves the value with the specified key from
// the FlowAttribute map field of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetFlowAttribute(FlowAttributeName string) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute {

	if t == nil {
		return nil
	}

	key := FlowAttributeName

	if lm, ok := t.FlowAttribute[key]; ok {
		return lm
	}
	return nil
}

// DeleteFlowAttribute deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) DeleteFlowAttribute(FlowAttributeName string) {
	key := FlowAttributeName

	delete(t.FlowAttribute, key)
}

// AppendFlowAttribute appends the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute struct to the
// list FlowAttribute of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) AppendFlowAttribute(v *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute) error {
	if v.FlowAttributeName == nil {
		return fmt.Errorf("invalid nil key received for FlowAttributeName")
	}

	key := *v.FlowAttributeName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.FlowAttribute == nil {
		t.FlowAttribute = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute)
	}

	if _, ok := t.FlowAttribute[key]; ok {
		return fmt.Errorf("duplicate key for list FlowAttribute %v", key)
	}

	t.FlowAttribute[key] = v
	return nil
}

// GetOrCreateBackup retrieves the value of the Backup field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetOrCreateBackup() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup {
	if t.Backup != nil {
		return t.Backup
	}
	t.Backup = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup{}
	return t.Backup
}

// GetOrCreateOverloadSubQuarantine retrieves the value of the OverloadSubQuarantine field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetOrCreateOverloadSubQuarantine() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine {
	if t.OverloadSubQuarantine != nil {
		return t.OverloadSubQuarantine
	}
	t.OverloadSubQuarantine = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine{}
	return t.OverloadSubQuarantine
}

// GetOrCreatePrimary retrieves the value of the Primary field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetOrCreatePrimary() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary {
	if t.Primary != nil {
		return t.Primary
	}
	t.Primary = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary{}
	return t.Primary
}

// GetOrCreateQos retrieves the value of the Qos field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetOrCreateQos() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos {
	if t.Qos != nil {
		return t.Qos
	}
	t.Qos = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos{}
	return t.Qos
}

// GetOrCreateSharedResources retrieves the value of the SharedResources field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetOrCreateSharedResources() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources {
	if t.SharedResources != nil {
		return t.SharedResources
	}
	t.SharedResources = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources{}
	return t.SharedResources
}

// GetOrCreateStatistics retrieves the value of the Statistics field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetOrCreateStatistics() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics {
	if t.Statistics != nil {
		return t.Statistics
	}
	t.Statistics = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics{}
	return t.Statistics
}

// GetOrCreateTransitPrefixLimits retrieves the value of the TransitPrefixLimits field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetOrCreateTransitPrefixLimits() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits {
	if t.TransitPrefixLimits != nil {
		return t.TransitPrefixLimits
	}
	t.TransitPrefixLimits = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits{}
	return t.TransitPrefixLimits
}

// GetBackup returns the value of the Backup struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup. If the receiver or the field Backup is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetBackup() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup {
	if t != nil && t.Backup != nil {
		return t.Backup
	}
	return nil
}

// GetOverloadSubQuarantine returns the value of the OverloadSubQuarantine struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup. If the receiver or the field OverloadSubQuarantine is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetOverloadSubQuarantine() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine {
	if t != nil && t.OverloadSubQuarantine != nil {
		return t.OverloadSubQuarantine
	}
	return nil
}

// GetPrimary returns the value of the Primary struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup. If the receiver or the field Primary is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetPrimary() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary {
	if t != nil && t.Primary != nil {
		return t.Primary
	}
	return nil
}

// GetQos returns the value of the Qos struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup. If the receiver or the field Qos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetQos() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos {
	if t != nil && t.Qos != nil {
		return t.Qos
	}
	return nil
}

// GetSharedResources returns the value of the SharedResources struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup. If the receiver or the field SharedResources is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetSharedResources() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources {
	if t != nil && t.SharedResources != nil {
		return t.SharedResources
	}
	return nil
}

// GetStatistics returns the value of the Statistics struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup. If the receiver or the field Statistics is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetStatistics() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics {
	if t != nil && t.Statistics != nil {
		return t.Statistics
	}
	return nil
}

// GetTransitPrefixLimits returns the value of the TransitPrefixLimits struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup. If the receiver or the field TransitPrefixLimits is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetTransitPrefixLimits() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits {
	if t != nil && t.TransitPrefixLimits != nil {
		return t.TransitPrefixLimits
	}
	return nil
}

// GetAaGroupId retrieves the value of the leaf AaGroupId from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AaGroupId is set, it can
// safely use t.GetAaGroupId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AaGroupId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetAaGroupId() NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_AaGroupId_Union {
	if t == nil || t.AaGroupId == nil {
		return nil
	}
	return t.AaGroupId
}

// GetAaSubScale retrieves the value of the leaf AaSubScale from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AaSubScale is set, it can
// safely use t.GetAaSubScale() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AaSubScale == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetAaSubScale() E_NokiaTypesApplicationAssurance_IsaAaGroupSubscale {
	if t == nil || t.AaSubScale == 0 {
		return NokiaTypesApplicationAssurance_IsaAaGroupSubscale_residential
	}
	return t.AaSubScale
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetDivertFc retrieves the value of the leaf DivertFc from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DivertFc is set, it can
// safely use t.GetDivertFc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DivertFc == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetDivertFc() []E_NokiaTypesSros_FcName {
	if t == nil || t.DivertFc == nil {
		return nil
	}
	return t.DivertFc
}

// GetFailureMode retrieves the value of the leaf FailureMode from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FailureMode is set, it can
// safely use t.GetFailureMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FailureMode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetFailureMode() E_NokiaTypesApplicationAssurance_IsaFailToMode {
	if t == nil || t.FailureMode == 0 {
		return 0
	}
	return t.FailureMode
}

// GetHttpEnrichMaxPacketSize retrieves the value of the leaf HttpEnrichMaxPacketSize from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HttpEnrichMaxPacketSize is set, it can
// safely use t.GetHttpEnrichMaxPacketSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HttpEnrichMaxPacketSize == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetHttpEnrichMaxPacketSize() uint32 {
	if t == nil || t.HttpEnrichMaxPacketSize == nil {
		return 1500
	}
	return *t.HttpEnrichMaxPacketSize
}

// GetIsaCapacityCostHighThreshold retrieves the value of the leaf IsaCapacityCostHighThreshold from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsaCapacityCostHighThreshold is set, it can
// safely use t.GetIsaCapacityCostHighThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsaCapacityCostHighThreshold == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetIsaCapacityCostHighThreshold() uint32 {
	if t == nil || t.IsaCapacityCostHighThreshold == nil {
		return 0
	}
	return *t.IsaCapacityCostHighThreshold
}

// GetIsaCapacityCostLowThreshold retrieves the value of the leaf IsaCapacityCostLowThreshold from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsaCapacityCostLowThreshold is set, it can
// safely use t.GetIsaCapacityCostLowThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsaCapacityCostLowThreshold == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetIsaCapacityCostLowThreshold() uint32 {
	if t == nil || t.IsaCapacityCostLowThreshold == nil {
		return 0
	}
	return *t.IsaCapacityCostLowThreshold
}

// GetMinimumIsaGeneration retrieves the value of the leaf MinimumIsaGeneration from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinimumIsaGeneration is set, it can
// safely use t.GetMinimumIsaGeneration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinimumIsaGeneration == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetMinimumIsaGeneration() uint32 {
	if t == nil || t.MinimumIsaGeneration == nil {
		return 0
	}
	return *t.MinimumIsaGeneration
}

// GetOverloadCutThrough retrieves the value of the leaf OverloadCutThrough from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OverloadCutThrough is set, it can
// safely use t.GetOverloadCutThrough() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OverloadCutThrough == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetOverloadCutThrough() bool {
	if t == nil || t.OverloadCutThrough == nil {
		return false
	}
	return *t.OverloadCutThrough
}

// GetVmTrafficDistributeByIp retrieves the value of the leaf VmTrafficDistributeByIp from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VmTrafficDistributeByIp is set, it can
// safely use t.GetVmTrafficDistributeByIp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VmTrafficDistributeByIp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetVmTrafficDistributeByIp() bool {
	if t == nil || t.VmTrafficDistributeByIp == nil {
		return false
	}
	return *t.VmTrafficDistributeByIp
}

// GetVmTrafficDistributeByTeid retrieves the value of the leaf VmTrafficDistributeByTeid from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VmTrafficDistributeByTeid is set, it can
// safely use t.GetVmTrafficDistributeByTeid() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VmTrafficDistributeByTeid == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) GetVmTrafficDistributeByTeid() bool {
	if t == nil || t.VmTrafficDistributeByTeid == nil {
		return false
	}
	return *t.VmTrafficDistributeByTeid
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AaSubScale == 0 {
		t.AaSubScale = NokiaTypesApplicationAssurance_IsaAaGroupSubscale_residential
	}
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.HttpEnrichMaxPacketSize == nil {
		var v uint32 = 1500
		t.HttpEnrichMaxPacketSize = &v
	}
	if t.OverloadCutThrough == nil {
		var v bool = false
		t.OverloadCutThrough = &v
	}
	if t.VmTrafficDistributeByIp == nil {
		var v bool = false
		t.VmTrafficDistributeByIp = &v
	}
	if t.VmTrafficDistributeByTeid == nil {
		var v bool = false
		t.VmTrafficDistributeByTeid = &v
	}
	t.Backup.PopulateDefaults()
	t.OverloadSubQuarantine.PopulateDefaults()
	t.Primary.PopulateDefaults()
	t.Qos.PopulateDefaults()
	t.SharedResources.PopulateDefaults()
	t.Statistics.PopulateDefaults()
	t.TransitPrefixLimits.PopulateDefaults()
	for _, e := range t.FlowAttribute {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"aa-group-id": t.AaGroupId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/backup YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup struct {
	Esa map[NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa `path:"esa" module:"nokia-conf"`
	Isa map[string]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa                                                                        `path:"isa" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) IsYANGGoStruct() {}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Key represents the key for list Esa of element /nokia-conf/configure/groups/group/isa/application-assurance-group/backup.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Key struct {
	EsaId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_EsaId_Union `path:"esa-id"`
	Vm    NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Vm_Union    `path:"vm"`
}

// NewEsa creates a new entry in the Esa list of the
// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) NewEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Vm_Union) (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Esa == nil {
		t.Esa = make(map[NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa)
	}

	key := NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Esa[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Esa", key)
	}

	t.Esa[key] = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa{
		EsaId: EsaId,
		Vm:    Vm,
	}

	return t.Esa[key], nil
}

// RenameEsa renames an entry in the list Esa within
// the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) RenameEsa(oldK, newK NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Key) error {
	if _, ok := t.Esa[newK]; ok {
		return fmt.Errorf("key %v already exists in Esa", newK)
	}

	e, ok := t.Esa[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Esa", oldK)
	}
	e.EsaId = newK.EsaId
	e.Vm = newK.Vm

	t.Esa[newK] = e
	delete(t.Esa, oldK)
	return nil
}

// GetOrCreateEsa retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) GetOrCreateEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Vm_Union) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa {

	key := NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	if v, ok := t.Esa[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEsa(EsaId, Vm)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEsa got unexpected error: %v", err))
	}
	return v
}

// GetEsa retrieves the value with the specified key from
// the Esa map field of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) GetEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Vm_Union) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa {

	if t == nil {
		return nil
	}

	key := NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	if lm, ok := t.Esa[key]; ok {
		return lm
	}
	return nil
}

// DeleteEsa deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) DeleteEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Vm_Union) {
	key := NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	delete(t.Esa, key)
}

// AppendEsa appends the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa struct to the
// list Esa of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) AppendEsa(v *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa) error {
	key := NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Key{
		EsaId: v.EsaId,
		Vm:    v.Vm,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Esa == nil {
		t.Esa = make(map[NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa)
	}

	if _, ok := t.Esa[key]; ok {
		return fmt.Errorf("duplicate key for list Esa %v", key)
	}

	t.Esa[key] = v
	return nil
}

// NewIsa creates a new entry in the Isa list of the
// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) NewIsa(MdaId string) (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Isa == nil {
		t.Isa = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa)
	}

	key := MdaId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Isa[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Isa", key)
	}

	t.Isa[key] = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa{
		MdaId: &MdaId,
	}

	return t.Isa[key], nil
}

// RenameIsa renames an entry in the list Isa within
// the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) RenameIsa(oldK, newK string) error {
	if _, ok := t.Isa[newK]; ok {
		return fmt.Errorf("key %v already exists in Isa", newK)
	}

	e, ok := t.Isa[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Isa", oldK)
	}
	e.MdaId = &newK

	t.Isa[newK] = e
	delete(t.Isa, oldK)
	return nil
}

// GetOrCreateIsa retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) GetOrCreateIsa(MdaId string) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa {

	key := MdaId

	if v, ok := t.Isa[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIsa(MdaId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIsa got unexpected error: %v", err))
	}
	return v
}

// GetIsa retrieves the value with the specified key from
// the Isa map field of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) GetIsa(MdaId string) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa {

	if t == nil {
		return nil
	}

	key := MdaId

	if lm, ok := t.Isa[key]; ok {
		return lm
	}
	return nil
}

// DeleteIsa deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) DeleteIsa(MdaId string) {
	key := MdaId

	delete(t.Isa, key)
}

// AppendIsa appends the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa struct to the
// list Isa of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) AppendIsa(v *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa) error {
	if v.MdaId == nil {
		return fmt.Errorf("invalid nil key received for MdaId")
	}

	key := *v.MdaId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Isa == nil {
		t.Isa = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa)
	}

	if _, ok := t.Isa[key]; ok {
		return fmt.Errorf("duplicate key for list Isa %v", key)
	}

	t.Isa[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Esa {
		e.PopulateDefaults()
	}
	for _, e := range t.Isa {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/backup/esa YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa struct {
	EsaId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_EsaId_Union `path:"esa-id" module:"nokia-conf"`
	Vm    NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Vm_Union    `path:"vm" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa) IsYANGGoStruct() {}

// GetEsaId retrieves the value of the leaf EsaId from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EsaId is set, it can
// safely use t.GetEsaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EsaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa) GetEsaId() NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_EsaId_Union {
	if t == nil || t.EsaId == nil {
		return nil
	}
	return t.EsaId
}

// GetVm retrieves the value of the leaf Vm from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vm is set, it can
// safely use t.GetVm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa) GetVm() NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa_Vm_Union {
	if t == nil || t.Vm == nil {
		return nil
	}
	return t.Vm
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"esa-id": t.EsaId,
		"vm":     t.Vm,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Esa) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/backup/isa YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa struct {
	MdaId *string `path:"mda-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa) IsYANGGoStruct() {}

// GetMdaId retrieves the value of the leaf MdaId from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MdaId is set, it can
// safely use t.GetMdaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MdaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa) GetMdaId() string {
	if t == nil || t.MdaId == nil {
		return ""
	}
	return *t.MdaId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MdaId == nil {
		return nil, fmt.Errorf("nil value for key MdaId")
	}

	return map[string]interface{}{
		"mda-id": *t.MdaId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Backup_Isa) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/flow-attribute YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute struct {
	FlowAttributeName *string `path:"flow-attribute-name" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute) IsYANGGoStruct() {
}

// GetFlowAttributeName retrieves the value of the leaf FlowAttributeName from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlowAttributeName is set, it can
// safely use t.GetFlowAttributeName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlowAttributeName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute) GetFlowAttributeName() string {
	if t == nil || t.FlowAttributeName == nil {
		return ""
	}
	return *t.FlowAttributeName
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute) ΛListKeyMap() (map[string]interface{}, error) {
	if t.FlowAttributeName == nil {
		return nil, fmt.Errorf("nil value for key FlowAttributeName")
	}

	return map[string]interface{}{
		"flow-attribute-name": *t.FlowAttributeName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_FlowAttribute) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/overload-sub-quarantine YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine struct {
	AdminState E_NokiaTypesSros_AdminState `path:"admin-state" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine) IsYANGGoStruct() {
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_OverloadSubQuarantine) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/primary YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary struct {
	Esa map[NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa `path:"esa" module:"nokia-conf"`
	Isa map[string]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa                                                                         `path:"isa" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) IsYANGGoStruct() {}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Key represents the key for list Esa of element /nokia-conf/configure/groups/group/isa/application-assurance-group/primary.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Key struct {
	EsaId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_EsaId_Union `path:"esa-id"`
	Vm    NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Vm_Union    `path:"vm"`
}

// NewEsa creates a new entry in the Esa list of the
// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) NewEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Vm_Union) (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Esa == nil {
		t.Esa = make(map[NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa)
	}

	key := NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Esa[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Esa", key)
	}

	t.Esa[key] = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa{
		EsaId: EsaId,
		Vm:    Vm,
	}

	return t.Esa[key], nil
}

// RenameEsa renames an entry in the list Esa within
// the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) RenameEsa(oldK, newK NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Key) error {
	if _, ok := t.Esa[newK]; ok {
		return fmt.Errorf("key %v already exists in Esa", newK)
	}

	e, ok := t.Esa[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Esa", oldK)
	}
	e.EsaId = newK.EsaId
	e.Vm = newK.Vm

	t.Esa[newK] = e
	delete(t.Esa, oldK)
	return nil
}

// GetOrCreateEsa retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) GetOrCreateEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Vm_Union) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa {

	key := NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	if v, ok := t.Esa[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEsa(EsaId, Vm)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEsa got unexpected error: %v", err))
	}
	return v
}

// GetEsa retrieves the value with the specified key from
// the Esa map field of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) GetEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Vm_Union) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa {

	if t == nil {
		return nil
	}

	key := NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	if lm, ok := t.Esa[key]; ok {
		return lm
	}
	return nil
}

// DeleteEsa deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) DeleteEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Vm_Union) {
	key := NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	delete(t.Esa, key)
}

// AppendEsa appends the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa struct to the
// list Esa of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) AppendEsa(v *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa) error {
	key := NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Key{
		EsaId: v.EsaId,
		Vm:    v.Vm,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Esa == nil {
		t.Esa = make(map[NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa)
	}

	if _, ok := t.Esa[key]; ok {
		return fmt.Errorf("duplicate key for list Esa %v", key)
	}

	t.Esa[key] = v
	return nil
}

// NewIsa creates a new entry in the Isa list of the
// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) NewIsa(MdaId string) (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Isa == nil {
		t.Isa = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa)
	}

	key := MdaId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Isa[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Isa", key)
	}

	t.Isa[key] = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa{
		MdaId: &MdaId,
	}

	return t.Isa[key], nil
}

// RenameIsa renames an entry in the list Isa within
// the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) RenameIsa(oldK, newK string) error {
	if _, ok := t.Isa[newK]; ok {
		return fmt.Errorf("key %v already exists in Isa", newK)
	}

	e, ok := t.Isa[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Isa", oldK)
	}
	e.MdaId = &newK

	t.Isa[newK] = e
	delete(t.Isa, oldK)
	return nil
}

// GetOrCreateIsa retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) GetOrCreateIsa(MdaId string) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa {

	key := MdaId

	if v, ok := t.Isa[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIsa(MdaId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIsa got unexpected error: %v", err))
	}
	return v
}

// GetIsa retrieves the value with the specified key from
// the Isa map field of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) GetIsa(MdaId string) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa {

	if t == nil {
		return nil
	}

	key := MdaId

	if lm, ok := t.Isa[key]; ok {
		return lm
	}
	return nil
}

// DeleteIsa deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) DeleteIsa(MdaId string) {
	key := MdaId

	delete(t.Isa, key)
}

// AppendIsa appends the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa struct to the
// list Isa of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) AppendIsa(v *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa) error {
	if v.MdaId == nil {
		return fmt.Errorf("invalid nil key received for MdaId")
	}

	key := *v.MdaId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Isa == nil {
		t.Isa = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa)
	}

	if _, ok := t.Isa[key]; ok {
		return fmt.Errorf("duplicate key for list Isa %v", key)
	}

	t.Isa[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Esa {
		e.PopulateDefaults()
	}
	for _, e := range t.Isa {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/primary/esa YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa struct {
	EsaId NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_EsaId_Union `path:"esa-id" module:"nokia-conf"`
	Vm    NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Vm_Union    `path:"vm" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa) IsYANGGoStruct() {}

// GetEsaId retrieves the value of the leaf EsaId from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EsaId is set, it can
// safely use t.GetEsaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EsaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa) GetEsaId() NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_EsaId_Union {
	if t == nil || t.EsaId == nil {
		return nil
	}
	return t.EsaId
}

// GetVm retrieves the value of the leaf Vm from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vm is set, it can
// safely use t.GetVm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa) GetVm() NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa_Vm_Union {
	if t == nil || t.Vm == nil {
		return nil
	}
	return t.Vm
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"esa-id": t.EsaId,
		"vm":     t.Vm,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Esa) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/primary/isa YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa struct {
	MdaId *string `path:"mda-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa) IsYANGGoStruct() {}

// GetMdaId retrieves the value of the leaf MdaId from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MdaId is set, it can
// safely use t.GetMdaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MdaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa) GetMdaId() string {
	if t == nil || t.MdaId == nil {
		return ""
	}
	return *t.MdaId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MdaId == nil {
		return nil, fmt.Errorf("nil value for key MdaId")
	}

	return map[string]interface{}{
		"mda-id": *t.MdaId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Primary_Isa) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/qos YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos struct {
	Egress *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress `path:"egress" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos) IsYANGGoStruct() {}

// GetOrCreateEgress retrieves the value of the Egress field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos) GetOrCreateEgress() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress {
	if t.Egress != nil {
		return t.Egress
	}
	t.Egress = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress{}
	return t.Egress
}

// GetEgress returns the value of the Egress struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos. If the receiver or the field Egress is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos) GetEgress() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress {
	if t != nil && t.Egress != nil {
		return t.Egress
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Egress.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/qos/egress YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress struct {
	FromSubscriber *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber `path:"from-subscriber" module:"nokia-conf"`
	ToSubscriber   *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber   `path:"to-subscriber" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress) IsYANGGoStruct() {}

// GetOrCreateFromSubscriber retrieves the value of the FromSubscriber field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress) GetOrCreateFromSubscriber() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber {
	if t.FromSubscriber != nil {
		return t.FromSubscriber
	}
	t.FromSubscriber = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber{}
	return t.FromSubscriber
}

// GetOrCreateToSubscriber retrieves the value of the ToSubscriber field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress) GetOrCreateToSubscriber() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber {
	if t.ToSubscriber != nil {
		return t.ToSubscriber
	}
	t.ToSubscriber = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber{}
	return t.ToSubscriber
}

// GetFromSubscriber returns the value of the FromSubscriber struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress. If the receiver or the field FromSubscriber is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress) GetFromSubscriber() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber {
	if t != nil && t.FromSubscriber != nil {
		return t.FromSubscriber
	}
	return nil
}

// GetToSubscriber returns the value of the ToSubscriber struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress. If the receiver or the field ToSubscriber is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress) GetToSubscriber() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber {
	if t != nil && t.ToSubscriber != nil {
		return t.ToSubscriber
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.FromSubscriber.PopulateDefaults()
	t.ToSubscriber.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/qos/egress/from-subscriber YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber struct {
	BufferPool          *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool             `path:"buffer-pool" module:"nokia-conf"`
	PortSchedulerPolicy *string                                                                                                          `path:"port-scheduler-policy" module:"nokia-conf"`
	QueuePolicy         *string                                                                                                          `path:"queue-policy" module:"nokia-conf"`
	WaSharedHighWmark   NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_WaSharedHighWmark_Union `path:"wa-shared-high-wmark" module:"nokia-conf"`
	WaSharedLowWmark    *int32                                                                                                           `path:"wa-shared-low-wmark" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber) IsYANGGoStruct() {
}

// GetOrCreateBufferPool retrieves the value of the BufferPool field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber) GetOrCreateBufferPool() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool {
	if t.BufferPool != nil {
		return t.BufferPool
	}
	t.BufferPool = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool{}
	return t.BufferPool
}

// GetBufferPool returns the value of the BufferPool struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber. If the receiver or the field BufferPool is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber) GetBufferPool() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool {
	if t != nil && t.BufferPool != nil {
		return t.BufferPool
	}
	return nil
}

// GetPortSchedulerPolicy retrieves the value of the leaf PortSchedulerPolicy from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortSchedulerPolicy is set, it can
// safely use t.GetPortSchedulerPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortSchedulerPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber) GetPortSchedulerPolicy() string {
	if t == nil || t.PortSchedulerPolicy == nil {
		return ""
	}
	return *t.PortSchedulerPolicy
}

// GetQueuePolicy retrieves the value of the leaf QueuePolicy from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QueuePolicy is set, it can
// safely use t.GetQueuePolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QueuePolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber) GetQueuePolicy() string {
	if t == nil || t.QueuePolicy == nil {
		return ""
	}
	return *t.QueuePolicy
}

// GetWaSharedHighWmark retrieves the value of the leaf WaSharedHighWmark from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WaSharedHighWmark is set, it can
// safely use t.GetWaSharedHighWmark() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WaSharedHighWmark == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber) GetWaSharedHighWmark() NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_WaSharedHighWmark_Union {
	if t == nil || t.WaSharedHighWmark == nil {
		return NokiaTypesApplicationAssurance_WaSharedBufferUtilizationHigh_Enum_max
	}
	return t.WaSharedHighWmark
}

// GetWaSharedLowWmark retrieves the value of the leaf WaSharedLowWmark from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WaSharedLowWmark is set, it can
// safely use t.GetWaSharedLowWmark() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WaSharedLowWmark == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber) GetWaSharedLowWmark() int32 {
	if t == nil || t.WaSharedLowWmark == nil {
		return 0
	}
	return *t.WaSharedLowWmark
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.WaSharedHighWmark == nil {
		t.WaSharedHighWmark = NokiaTypesApplicationAssurance_WaSharedBufferUtilizationHigh_Enum_max
	}
	if t.WaSharedLowWmark == nil {
		var v int32 = 0
		t.WaSharedLowWmark = &v
	}
	t.BufferPool.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/qos/egress/from-subscriber/buffer-pool YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool struct {
	Name        *string `path:"name" module:"nokia-conf"`
	ResvCbs     *int32  `path:"resv-cbs" module:"nokia-conf"`
	SlopePolicy *string `path:"slope-policy" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool) IsYANGGoStruct() {
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool) GetName() string {
	if t == nil || t.Name == nil {
		return "default"
	}
	return *t.Name
}

// GetResvCbs retrieves the value of the leaf ResvCbs from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ResvCbs is set, it can
// safely use t.GetResvCbs() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ResvCbs == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool) GetResvCbs() int32 {
	if t == nil || t.ResvCbs == nil {
		return 0
	}
	return *t.ResvCbs
}

// GetSlopePolicy retrieves the value of the leaf SlopePolicy from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SlopePolicy is set, it can
// safely use t.GetSlopePolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SlopePolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool) GetSlopePolicy() string {
	if t == nil || t.SlopePolicy == nil {
		return ""
	}
	return *t.SlopePolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Name == nil {
		var v string = "default"
		t.Name = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_FromSubscriber_BufferPool) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/qos/egress/to-subscriber YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber struct {
	BufferPool          *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool             `path:"buffer-pool" module:"nokia-conf"`
	PortSchedulerPolicy *string                                                                                                        `path:"port-scheduler-policy" module:"nokia-conf"`
	QueuePolicy         *string                                                                                                        `path:"queue-policy" module:"nokia-conf"`
	WaSharedHighWmark   NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_WaSharedHighWmark_Union `path:"wa-shared-high-wmark" module:"nokia-conf"`
	WaSharedLowWmark    *int32                                                                                                         `path:"wa-shared-low-wmark" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber) IsYANGGoStruct() {
}

// GetOrCreateBufferPool retrieves the value of the BufferPool field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber) GetOrCreateBufferPool() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool {
	if t.BufferPool != nil {
		return t.BufferPool
	}
	t.BufferPool = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool{}
	return t.BufferPool
}

// GetBufferPool returns the value of the BufferPool struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber. If the receiver or the field BufferPool is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber) GetBufferPool() *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool {
	if t != nil && t.BufferPool != nil {
		return t.BufferPool
	}
	return nil
}

// GetPortSchedulerPolicy retrieves the value of the leaf PortSchedulerPolicy from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortSchedulerPolicy is set, it can
// safely use t.GetPortSchedulerPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortSchedulerPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber) GetPortSchedulerPolicy() string {
	if t == nil || t.PortSchedulerPolicy == nil {
		return ""
	}
	return *t.PortSchedulerPolicy
}

// GetQueuePolicy retrieves the value of the leaf QueuePolicy from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if QueuePolicy is set, it can
// safely use t.GetQueuePolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.QueuePolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber) GetQueuePolicy() string {
	if t == nil || t.QueuePolicy == nil {
		return ""
	}
	return *t.QueuePolicy
}

// GetWaSharedHighWmark retrieves the value of the leaf WaSharedHighWmark from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WaSharedHighWmark is set, it can
// safely use t.GetWaSharedHighWmark() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WaSharedHighWmark == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber) GetWaSharedHighWmark() NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_WaSharedHighWmark_Union {
	if t == nil || t.WaSharedHighWmark == nil {
		return NokiaTypesApplicationAssurance_WaSharedBufferUtilizationHigh_Enum_max
	}
	return t.WaSharedHighWmark
}

// GetWaSharedLowWmark retrieves the value of the leaf WaSharedLowWmark from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if WaSharedLowWmark is set, it can
// safely use t.GetWaSharedLowWmark() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.WaSharedLowWmark == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber) GetWaSharedLowWmark() int32 {
	if t == nil || t.WaSharedLowWmark == nil {
		return 0
	}
	return *t.WaSharedLowWmark
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.WaSharedHighWmark == nil {
		t.WaSharedHighWmark = NokiaTypesApplicationAssurance_WaSharedBufferUtilizationHigh_Enum_max
	}
	if t.WaSharedLowWmark == nil {
		var v int32 = 0
		t.WaSharedLowWmark = &v
	}
	t.BufferPool.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/qos/egress/to-subscriber/buffer-pool YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool struct {
	Name        *string `path:"name" module:"nokia-conf"`
	ResvCbs     *int32  `path:"resv-cbs" module:"nokia-conf"`
	SlopePolicy *string `path:"slope-policy" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool) IsYANGGoStruct() {
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool) GetName() string {
	if t == nil || t.Name == nil {
		return "default"
	}
	return *t.Name
}

// GetResvCbs retrieves the value of the leaf ResvCbs from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ResvCbs is set, it can
// safely use t.GetResvCbs() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ResvCbs == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool) GetResvCbs() int32 {
	if t == nil || t.ResvCbs == nil {
		return 0
	}
	return *t.ResvCbs
}

// GetSlopePolicy retrieves the value of the leaf SlopePolicy from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SlopePolicy is set, it can
// safely use t.GetSlopePolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SlopePolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool) GetSlopePolicy() string {
	if t == nil || t.SlopePolicy == nil {
		return ""
	}
	return *t.SlopePolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Name == nil {
		var v string = "default"
		t.Name = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Qos_Egress_ToSubscriber_BufferPool) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/shared-resources YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources struct {
	GtpTunnelDatabase        *uint32 `path:"gtp-tunnel-database" module:"nokia-conf"`
	TcpAdvancedFunctions     *uint32 `path:"tcp-advanced-functions" module:"nokia-conf"`
	UrlFilterWebServiceCache *uint32 `path:"url-filter-web-service-cache" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources) IsYANGGoStruct() {
}

// GetGtpTunnelDatabase retrieves the value of the leaf GtpTunnelDatabase from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if GtpTunnelDatabase is set, it can
// safely use t.GetGtpTunnelDatabase() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.GtpTunnelDatabase == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources) GetGtpTunnelDatabase() uint32 {
	if t == nil || t.GtpTunnelDatabase == nil {
		return 0
	}
	return *t.GtpTunnelDatabase
}

// GetTcpAdvancedFunctions retrieves the value of the leaf TcpAdvancedFunctions from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TcpAdvancedFunctions is set, it can
// safely use t.GetTcpAdvancedFunctions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TcpAdvancedFunctions == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources) GetTcpAdvancedFunctions() uint32 {
	if t == nil || t.TcpAdvancedFunctions == nil {
		return 0
	}
	return *t.TcpAdvancedFunctions
}

// GetUrlFilterWebServiceCache retrieves the value of the leaf UrlFilterWebServiceCache from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UrlFilterWebServiceCache is set, it can
// safely use t.GetUrlFilterWebServiceCache() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UrlFilterWebServiceCache == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources) GetUrlFilterWebServiceCache() uint32 {
	if t == nil || t.UrlFilterWebServiceCache == nil {
		return 0
	}
	return *t.UrlFilterWebServiceCache
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_SharedResources) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/statistics YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics struct {
	StatsType map[NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType_IsaAaGroupStatsType_Union]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType `path:"stats-type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics) IsYANGGoStruct() {}

// NewStatsType creates a new entry in the StatsType list of the
// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics) NewStatsType(IsaAaGroupStatsType NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType_IsaAaGroupStatsType_Union) (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StatsType == nil {
		t.StatsType = make(map[NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType_IsaAaGroupStatsType_Union]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType)
	}

	key := IsaAaGroupStatsType

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.StatsType[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list StatsType", key)
	}

	t.StatsType[key] = &NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType{
		IsaAaGroupStatsType: IsaAaGroupStatsType,
	}

	return t.StatsType[key], nil
}

// RenameStatsType renames an entry in the list StatsType within
// the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics) RenameStatsType(oldK, newK NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType_IsaAaGroupStatsType_Union) error {
	if _, ok := t.StatsType[newK]; ok {
		return fmt.Errorf("key %v already exists in StatsType", newK)
	}

	e, ok := t.StatsType[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in StatsType", oldK)
	}
	e.IsaAaGroupStatsType = newK

	t.StatsType[newK] = e
	delete(t.StatsType, oldK)
	return nil
}

// GetOrCreateStatsType retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics) GetOrCreateStatsType(IsaAaGroupStatsType NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType_IsaAaGroupStatsType_Union) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType {

	key := IsaAaGroupStatsType

	if v, ok := t.StatsType[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStatsType(IsaAaGroupStatsType)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStatsType got unexpected error: %v", err))
	}
	return v
}

// GetStatsType retrieves the value with the specified key from
// the StatsType map field of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics) GetStatsType(IsaAaGroupStatsType NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType_IsaAaGroupStatsType_Union) *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType {

	if t == nil {
		return nil
	}

	key := IsaAaGroupStatsType

	if lm, ok := t.StatsType[key]; ok {
		return lm
	}
	return nil
}

// DeleteStatsType deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics) DeleteStatsType(IsaAaGroupStatsType NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType_IsaAaGroupStatsType_Union) {
	key := IsaAaGroupStatsType

	delete(t.StatsType, key)
}

// AppendStatsType appends the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType struct to the
// list StatsType of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics) AppendStatsType(v *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType) error {
	key := v.IsaAaGroupStatsType

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.StatsType == nil {
		t.StatsType = make(map[NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType_IsaAaGroupStatsType_Union]*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType)
	}

	if _, ok := t.StatsType[key]; ok {
		return fmt.Errorf("duplicate key for list StatsType %v", key)
	}

	t.StatsType[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.StatsType {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/statistics/stats-type YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType struct {
	AccountingPolicy    *uint32                                                                                                       `path:"accounting-policy" module:"nokia-conf"`
	CollectStats        *bool                                                                                                         `path:"collect-stats" module:"nokia-conf"`
	IsaAaGroupStatsType NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType_IsaAaGroupStatsType_Union `path:"isa-aa-group-stats-type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType) IsYANGGoStruct() {
}

// GetAccountingPolicy retrieves the value of the leaf AccountingPolicy from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AccountingPolicy is set, it can
// safely use t.GetAccountingPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AccountingPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType) GetAccountingPolicy() uint32 {
	if t == nil || t.AccountingPolicy == nil {
		return 0
	}
	return *t.AccountingPolicy
}

// GetCollectStats retrieves the value of the leaf CollectStats from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CollectStats is set, it can
// safely use t.GetCollectStats() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CollectStats == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType) GetCollectStats() bool {
	if t == nil || t.CollectStats == nil {
		return false
	}
	return *t.CollectStats
}

// GetIsaAaGroupStatsType retrieves the value of the leaf IsaAaGroupStatsType from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsaAaGroupStatsType is set, it can
// safely use t.GetIsaAaGroupStatsType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsaAaGroupStatsType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType) GetIsaAaGroupStatsType() NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType_IsaAaGroupStatsType_Union {
	if t == nil || t.IsaAaGroupStatsType == nil {
		return nil
	}
	return t.IsaAaGroupStatsType
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CollectStats == nil {
		var v bool = false
		t.CollectStats = &v
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"isa-aa-group-stats-type": t.IsaAaGroupStatsType,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_Statistics_StatsType) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits represents the /nokia-conf/configure/groups/group/isa/application-assurance-group/transit-prefix-limits YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits struct {
	Ipv4Entries       *uint32 `path:"ipv4-entries" module:"nokia-conf"`
	Ipv4RemoteEntries *uint32 `path:"ipv4-remote-entries" module:"nokia-conf"`
	Ipv6Entries       *uint32 `path:"ipv6-entries" module:"nokia-conf"`
	Ipv6RemoteEntries *uint32 `path:"ipv6-remote-entries" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits) IsYANGGoStruct() {
}

// GetIpv4Entries retrieves the value of the leaf Ipv4Entries from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4Entries is set, it can
// safely use t.GetIpv4Entries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4Entries == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits) GetIpv4Entries() uint32 {
	if t == nil || t.Ipv4Entries == nil {
		return 0
	}
	return *t.Ipv4Entries
}

// GetIpv4RemoteEntries retrieves the value of the leaf Ipv4RemoteEntries from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv4RemoteEntries is set, it can
// safely use t.GetIpv4RemoteEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv4RemoteEntries == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits) GetIpv4RemoteEntries() uint32 {
	if t == nil || t.Ipv4RemoteEntries == nil {
		return 0
	}
	return *t.Ipv4RemoteEntries
}

// GetIpv6Entries retrieves the value of the leaf Ipv6Entries from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6Entries is set, it can
// safely use t.GetIpv6Entries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6Entries == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits) GetIpv6Entries() uint32 {
	if t == nil || t.Ipv6Entries == nil {
		return 0
	}
	return *t.Ipv6Entries
}

// GetIpv6RemoteEntries retrieves the value of the leaf Ipv6RemoteEntries from the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ipv6RemoteEntries is set, it can
// safely use t.GetIpv6RemoteEntries() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ipv6RemoteEntries == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits) GetIpv6RemoteEntries() uint32 {
	if t == nil || t.Ipv6RemoteEntries == nil {
		return 0
	}
	return *t.Ipv6RemoteEntries
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits.
func (*NokiaConf_Configure_Groups_Group_Isa_ApplicationAssuranceGroup_TransitPrefixLimits) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_LnsGroup represents the /nokia-conf/configure/groups/group/isa/lns-group YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_LnsGroup struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                  `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                      `path:"description" module:"nokia-conf"`
	Esa         map[NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa `path:"esa" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Id_Union                                                       `path:"id" module:"nokia-conf"`
	Mda         map[string]*NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda                                                `path:"mda" module:"nokia-conf"`
	PortPolicy  *string                                                                                                      `path:"port-policy" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_LnsGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_LnsGroup) IsYANGGoStruct() {}

// NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Key represents the key for list Esa of element /nokia-conf/configure/groups/group/isa/lns-group.
type NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Key struct {
	EsaId NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_EsaId_Union `path:"esa-id"`
	Vm    NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Vm_Union    `path:"vm"`
}

// NewEsa creates a new entry in the Esa list of the
// NokiaConf_Configure_Groups_Group_Isa_LnsGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) NewEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Vm_Union) (*NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Esa == nil {
		t.Esa = make(map[NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa)
	}

	key := NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Esa[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Esa", key)
	}

	t.Esa[key] = &NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa{
		EsaId: EsaId,
		Vm:    Vm,
	}

	return t.Esa[key], nil
}

// RenameEsa renames an entry in the list Esa within
// the NokiaConf_Configure_Groups_Group_Isa_LnsGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) RenameEsa(oldK, newK NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Key) error {
	if _, ok := t.Esa[newK]; ok {
		return fmt.Errorf("key %v already exists in Esa", newK)
	}

	e, ok := t.Esa[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Esa", oldK)
	}
	e.EsaId = newK.EsaId
	e.Vm = newK.Vm

	t.Esa[newK] = e
	delete(t.Esa, oldK)
	return nil
}

// GetOrCreateEsa retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_LnsGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) GetOrCreateEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Vm_Union) *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa {

	key := NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	if v, ok := t.Esa[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEsa(EsaId, Vm)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEsa got unexpected error: %v", err))
	}
	return v
}

// GetEsa retrieves the value with the specified key from
// the Esa map field of NokiaConf_Configure_Groups_Group_Isa_LnsGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) GetEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Vm_Union) *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa {

	if t == nil {
		return nil
	}

	key := NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	if lm, ok := t.Esa[key]; ok {
		return lm
	}
	return nil
}

// DeleteEsa deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_LnsGroup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) DeleteEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Vm_Union) {
	key := NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	delete(t.Esa, key)
}

// AppendEsa appends the supplied NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa struct to the
// list Esa of NokiaConf_Configure_Groups_Group_Isa_LnsGroup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) AppendEsa(v *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa) error {
	key := NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Key{
		EsaId: v.EsaId,
		Vm:    v.Vm,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Esa == nil {
		t.Esa = make(map[NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa)
	}

	if _, ok := t.Esa[key]; ok {
		return fmt.Errorf("duplicate key for list Esa %v", key)
	}

	t.Esa[key] = v
	return nil
}

// NewMda creates a new entry in the Mda list of the
// NokiaConf_Configure_Groups_Group_Isa_LnsGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) NewMda(MdaId string) (*NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mda == nil {
		t.Mda = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda)
	}

	key := MdaId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mda[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mda", key)
	}

	t.Mda[key] = &NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda{
		MdaId: &MdaId,
	}

	return t.Mda[key], nil
}

// RenameMda renames an entry in the list Mda within
// the NokiaConf_Configure_Groups_Group_Isa_LnsGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) RenameMda(oldK, newK string) error {
	if _, ok := t.Mda[newK]; ok {
		return fmt.Errorf("key %v already exists in Mda", newK)
	}

	e, ok := t.Mda[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mda", oldK)
	}
	e.MdaId = &newK

	t.Mda[newK] = e
	delete(t.Mda, oldK)
	return nil
}

// GetOrCreateMda retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_LnsGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) GetOrCreateMda(MdaId string) *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda {

	key := MdaId

	if v, ok := t.Mda[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMda(MdaId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMda got unexpected error: %v", err))
	}
	return v
}

// GetMda retrieves the value with the specified key from
// the Mda map field of NokiaConf_Configure_Groups_Group_Isa_LnsGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) GetMda(MdaId string) *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda {

	if t == nil {
		return nil
	}

	key := MdaId

	if lm, ok := t.Mda[key]; ok {
		return lm
	}
	return nil
}

// DeleteMda deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_LnsGroup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) DeleteMda(MdaId string) {
	key := MdaId

	delete(t.Mda, key)
}

// AppendMda appends the supplied NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda struct to the
// list Mda of NokiaConf_Configure_Groups_Group_Isa_LnsGroup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) AppendMda(v *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda) error {
	if v.MdaId == nil {
		return fmt.Errorf("invalid nil key received for MdaId")
	}

	key := *v.MdaId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mda == nil {
		t.Mda = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda)
	}

	if _, ok := t.Mda[key]; ok {
		return fmt.Errorf("duplicate key for list Mda %v", key)
	}

	t.Mda[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Isa_LnsGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Isa_LnsGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Isa_LnsGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) GetId() NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// GetPortPolicy retrieves the value of the leaf PortPolicy from the NokiaConf_Configure_Groups_Group_Isa_LnsGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortPolicy is set, it can
// safely use t.GetPortPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) GetPortPolicy() string {
	if t == nil || t.PortPolicy == nil {
		return ""
	}
	return *t.PortPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_LnsGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Esa {
		e.PopulateDefaults()
	}
	for _, e := range t.Mda {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_LnsGroup struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_LnsGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_LnsGroup.
func (*NokiaConf_Configure_Groups_Group_Isa_LnsGroup) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa represents the /nokia-conf/configure/groups/group/isa/lns-group/esa YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa struct {
	Drain *bool                                                         `path:"drain" module:"nokia-conf"`
	EsaId NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_EsaId_Union `path:"esa-id" module:"nokia-conf"`
	Vm    NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Vm_Union    `path:"vm" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa) IsYANGGoStruct() {}

// GetDrain retrieves the value of the leaf Drain from the NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Drain is set, it can
// safely use t.GetDrain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Drain == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa) GetDrain() bool {
	if t == nil || t.Drain == nil {
		return false
	}
	return *t.Drain
}

// GetEsaId retrieves the value of the leaf EsaId from the NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EsaId is set, it can
// safely use t.GetEsaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EsaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa) GetEsaId() NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_EsaId_Union {
	if t == nil || t.EsaId == nil {
		return nil
	}
	return t.EsaId
}

// GetVm retrieves the value of the leaf Vm from the NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vm is set, it can
// safely use t.GetVm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa) GetVm() NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa_Vm_Union {
	if t == nil || t.Vm == nil {
		return nil
	}
	return t.Vm
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Drain == nil {
		var v bool = false
		t.Drain = &v
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"esa-id": t.EsaId,
		"vm":     t.Vm,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa.
func (*NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Esa) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda represents the /nokia-conf/configure/groups/group/isa/lns-group/mda YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda struct {
	Drain *bool   `path:"drain" module:"nokia-conf"`
	MdaId *string `path:"mda-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda) IsYANGGoStruct() {}

// GetDrain retrieves the value of the leaf Drain from the NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Drain is set, it can
// safely use t.GetDrain() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Drain == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda) GetDrain() bool {
	if t == nil || t.Drain == nil {
		return false
	}
	return *t.Drain
}

// GetMdaId retrieves the value of the leaf MdaId from the NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MdaId is set, it can
// safely use t.GetMdaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MdaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda) GetMdaId() string {
	if t == nil || t.MdaId == nil {
		return ""
	}
	return *t.MdaId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Drain == nil {
		var v bool = false
		t.Drain = &v
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MdaId == nil {
		return nil, fmt.Errorf("nil value for key MdaId")
	}

	return map[string]interface{}{
		"mda-id": *t.MdaId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda.
func (*NokiaConf_Configure_Groups_Group_Isa_LnsGroup_Mda) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup represents the /nokia-conf/configure/groups/group/isa/nat-group YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup struct {
	AdminState             E_NokiaTypesSros_AdminState                                                                                  `path:"admin-state" module:"nokia-conf"`
	Description            *string                                                                                                      `path:"description" module:"nokia-conf"`
	Esa                    map[NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa `path:"esa" module:"nokia-conf"`
	Id                     NokiaConf_Configure_Groups_Group_Isa_NatGroup_Id_Union                                                       `path:"id" module:"nokia-conf"`
	Log                    *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log                                                           `path:"log" module:"nokia-conf"`
	Mda                    map[string]*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda                                                `path:"mda" module:"nokia-conf"`
	RadiusAccountingPolicy *string                                                                                                      `path:"radius-accounting-policy" module:"nokia-conf"`
	Redundancy             *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy                                                    `path:"redundancy" module:"nokia-conf"`
	ScalingProfile         E_NokiaTypesSros_IsaScalingProfile                                                                           `path:"scaling-profile" module:"nokia-conf"`
	SessionLimits          *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits                                                 `path:"session-limits" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup) IsYANGGoStruct() {}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Key represents the key for list Esa of element /nokia-conf/configure/groups/group/isa/nat-group.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Key struct {
	EsaId NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_EsaId_Union `path:"esa-id"`
	Vm    NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Vm_Union    `path:"vm"`
}

// NewEsa creates a new entry in the Esa list of the
// NokiaConf_Configure_Groups_Group_Isa_NatGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) NewEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Vm_Union) (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Esa == nil {
		t.Esa = make(map[NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa)
	}

	key := NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Esa[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Esa", key)
	}

	t.Esa[key] = &NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa{
		EsaId: EsaId,
		Vm:    Vm,
	}

	return t.Esa[key], nil
}

// RenameEsa renames an entry in the list Esa within
// the NokiaConf_Configure_Groups_Group_Isa_NatGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) RenameEsa(oldK, newK NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Key) error {
	if _, ok := t.Esa[newK]; ok {
		return fmt.Errorf("key %v already exists in Esa", newK)
	}

	e, ok := t.Esa[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Esa", oldK)
	}
	e.EsaId = newK.EsaId
	e.Vm = newK.Vm

	t.Esa[newK] = e
	delete(t.Esa, oldK)
	return nil
}

// GetOrCreateEsa retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_NatGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetOrCreateEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Vm_Union) *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa {

	key := NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	if v, ok := t.Esa[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEsa(EsaId, Vm)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEsa got unexpected error: %v", err))
	}
	return v
}

// GetEsa retrieves the value with the specified key from
// the Esa map field of NokiaConf_Configure_Groups_Group_Isa_NatGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Vm_Union) *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa {

	if t == nil {
		return nil
	}

	key := NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	if lm, ok := t.Esa[key]; ok {
		return lm
	}
	return nil
}

// DeleteEsa deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_NatGroup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) DeleteEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Vm_Union) {
	key := NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	delete(t.Esa, key)
}

// AppendEsa appends the supplied NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa struct to the
// list Esa of NokiaConf_Configure_Groups_Group_Isa_NatGroup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) AppendEsa(v *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa) error {
	key := NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Key{
		EsaId: v.EsaId,
		Vm:    v.Vm,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Esa == nil {
		t.Esa = make(map[NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa)
	}

	if _, ok := t.Esa[key]; ok {
		return fmt.Errorf("duplicate key for list Esa %v", key)
	}

	t.Esa[key] = v
	return nil
}

// NewMda creates a new entry in the Mda list of the
// NokiaConf_Configure_Groups_Group_Isa_NatGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) NewMda(MdaId string) (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mda == nil {
		t.Mda = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda)
	}

	key := MdaId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mda[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mda", key)
	}

	t.Mda[key] = &NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda{
		MdaId: &MdaId,
	}

	return t.Mda[key], nil
}

// RenameMda renames an entry in the list Mda within
// the NokiaConf_Configure_Groups_Group_Isa_NatGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) RenameMda(oldK, newK string) error {
	if _, ok := t.Mda[newK]; ok {
		return fmt.Errorf("key %v already exists in Mda", newK)
	}

	e, ok := t.Mda[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mda", oldK)
	}
	e.MdaId = &newK

	t.Mda[newK] = e
	delete(t.Mda, oldK)
	return nil
}

// GetOrCreateMda retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_NatGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetOrCreateMda(MdaId string) *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda {

	key := MdaId

	if v, ok := t.Mda[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMda(MdaId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMda got unexpected error: %v", err))
	}
	return v
}

// GetMda retrieves the value with the specified key from
// the Mda map field of NokiaConf_Configure_Groups_Group_Isa_NatGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetMda(MdaId string) *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda {

	if t == nil {
		return nil
	}

	key := MdaId

	if lm, ok := t.Mda[key]; ok {
		return lm
	}
	return nil
}

// DeleteMda deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_NatGroup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) DeleteMda(MdaId string) {
	key := MdaId

	delete(t.Mda, key)
}

// AppendMda appends the supplied NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda struct to the
// list Mda of NokiaConf_Configure_Groups_Group_Isa_NatGroup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) AppendMda(v *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda) error {
	if v.MdaId == nil {
		return fmt.Errorf("invalid nil key received for MdaId")
	}

	key := *v.MdaId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mda == nil {
		t.Mda = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda)
	}

	if _, ok := t.Mda[key]; ok {
		return fmt.Errorf("duplicate key for list Mda %v", key)
	}

	t.Mda[key] = v
	return nil
}

// GetOrCreateLog retrieves the value of the Log field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetOrCreateLog() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log {
	if t.Log != nil {
		return t.Log
	}
	t.Log = &NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log{}
	return t.Log
}

// GetOrCreateRedundancy retrieves the value of the Redundancy field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetOrCreateRedundancy() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy {
	if t.Redundancy != nil {
		return t.Redundancy
	}
	t.Redundancy = &NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy{}
	return t.Redundancy
}

// GetOrCreateSessionLimits retrieves the value of the SessionLimits field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetOrCreateSessionLimits() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits {
	if t.SessionLimits != nil {
		return t.SessionLimits
	}
	t.SessionLimits = &NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits{}
	return t.SessionLimits
}

// GetLog returns the value of the Log struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_NatGroup. If the receiver or the field Log is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetLog() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log {
	if t != nil && t.Log != nil {
		return t.Log
	}
	return nil
}

// GetRedundancy returns the value of the Redundancy struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_NatGroup. If the receiver or the field Redundancy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetRedundancy() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy {
	if t != nil && t.Redundancy != nil {
		return t.Redundancy
	}
	return nil
}

// GetSessionLimits returns the value of the SessionLimits struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_NatGroup. If the receiver or the field SessionLimits is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetSessionLimits() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits {
	if t != nil && t.SessionLimits != nil {
		return t.SessionLimits
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Isa_NatGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Isa_NatGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Isa_NatGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetId() NokiaConf_Configure_Groups_Group_Isa_NatGroup_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// GetRadiusAccountingPolicy retrieves the value of the leaf RadiusAccountingPolicy from the NokiaConf_Configure_Groups_Group_Isa_NatGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RadiusAccountingPolicy is set, it can
// safely use t.GetRadiusAccountingPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RadiusAccountingPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetRadiusAccountingPolicy() string {
	if t == nil || t.RadiusAccountingPolicy == nil {
		return ""
	}
	return *t.RadiusAccountingPolicy
}

// GetScalingProfile retrieves the value of the leaf ScalingProfile from the NokiaConf_Configure_Groups_Group_Isa_NatGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ScalingProfile is set, it can
// safely use t.GetScalingProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ScalingProfile == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) GetScalingProfile() E_NokiaTypesSros_IsaScalingProfile {
	if t == nil || t.ScalingProfile == 0 {
		return NokiaTypesSros_IsaScalingProfile_profile1
	}
	return t.ScalingProfile
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.ScalingProfile == 0 {
		t.ScalingProfile = NokiaTypesSros_IsaScalingProfile_profile1
	}
	t.Log.PopulateDefaults()
	t.Redundancy.PopulateDefaults()
	t.SessionLimits.PopulateDefaults()
	for _, e := range t.Esa {
		e.PopulateDefaults()
	}
	for _, e := range t.Mda {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_NatGroup struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa represents the /nokia-conf/configure/groups/group/isa/nat-group/esa YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa struct {
	EsaId NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_EsaId_Union `path:"esa-id" module:"nokia-conf"`
	Vm    NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Vm_Union    `path:"vm" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa) IsYANGGoStruct() {}

// GetEsaId retrieves the value of the leaf EsaId from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EsaId is set, it can
// safely use t.GetEsaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EsaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa) GetEsaId() NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_EsaId_Union {
	if t == nil || t.EsaId == nil {
		return nil
	}
	return t.EsaId
}

// GetVm retrieves the value of the leaf Vm from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vm is set, it can
// safely use t.GetVm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa) GetVm() NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa_Vm_Union {
	if t == nil || t.Vm == nil {
		return nil
	}
	return t.Vm
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"esa-id": t.EsaId,
		"vm":     t.Vm,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Esa) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log represents the /nokia-conf/configure/groups/group/isa/nat-group/log YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log struct {
	SuppressLsnEvents        *bool `path:"suppress-lsn-events" module:"nokia-conf"`
	SuppressLsnSubBlocksFree *bool `path:"suppress-lsn-sub-blocks-free" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log) IsYANGGoStruct() {}

// GetSuppressLsnEvents retrieves the value of the leaf SuppressLsnEvents from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SuppressLsnEvents is set, it can
// safely use t.GetSuppressLsnEvents() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SuppressLsnEvents == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log) GetSuppressLsnEvents() bool {
	if t == nil || t.SuppressLsnEvents == nil {
		return true
	}
	return *t.SuppressLsnEvents
}

// GetSuppressLsnSubBlocksFree retrieves the value of the leaf SuppressLsnSubBlocksFree from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SuppressLsnSubBlocksFree is set, it can
// safely use t.GetSuppressLsnSubBlocksFree() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SuppressLsnSubBlocksFree == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log) GetSuppressLsnSubBlocksFree() bool {
	if t == nil || t.SuppressLsnSubBlocksFree == nil {
		return false
	}
	return *t.SuppressLsnSubBlocksFree
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SuppressLsnEvents == nil {
		var v bool = true
		t.SuppressLsnEvents = &v
	}
	if t.SuppressLsnSubBlocksFree == nil {
		var v bool = false
		t.SuppressLsnSubBlocksFree = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Log) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda represents the /nokia-conf/configure/groups/group/isa/nat-group/mda YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda struct {
	MdaId *string `path:"mda-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda) IsYANGGoStruct() {}

// GetMdaId retrieves the value of the leaf MdaId from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MdaId is set, it can
// safely use t.GetMdaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MdaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda) GetMdaId() string {
	if t == nil || t.MdaId == nil {
		return ""
	}
	return *t.MdaId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MdaId == nil {
		return nil, fmt.Errorf("nil value for key MdaId")
	}

	return map[string]interface{}{
		"mda-id": *t.MdaId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Mda) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy represents the /nokia-conf/configure/groups/group/isa/nat-group/redundancy YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy struct {
	ActiveMdaLimit *uint32                                                                `path:"active-mda-limit" module:"nokia-conf"`
	InterChassis   *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis `path:"inter-chassis" module:"nokia-conf" yangPresence:"true"`
	IntraChassis   *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis `path:"intra-chassis" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy) IsYANGGoStruct() {}

// GetOrCreateInterChassis retrieves the value of the InterChassis field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy) GetOrCreateInterChassis() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis {
	if t.InterChassis != nil {
		return t.InterChassis
	}
	t.InterChassis = &NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis{}
	return t.InterChassis
}

// GetOrCreateIntraChassis retrieves the value of the IntraChassis field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy) GetOrCreateIntraChassis() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis {
	if t.IntraChassis != nil {
		return t.IntraChassis
	}
	t.IntraChassis = &NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis{}
	return t.IntraChassis
}

// GetInterChassis returns the value of the InterChassis struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy. If the receiver or the field InterChassis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy) GetInterChassis() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis {
	if t != nil && t.InterChassis != nil {
		return t.InterChassis
	}
	return nil
}

// GetIntraChassis returns the value of the IntraChassis struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy. If the receiver or the field IntraChassis is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy) GetIntraChassis() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis {
	if t != nil && t.IntraChassis != nil {
		return t.IntraChassis
	}
	return nil
}

// GetActiveMdaLimit retrieves the value of the leaf ActiveMdaLimit from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ActiveMdaLimit is set, it can
// safely use t.GetActiveMdaLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ActiveMdaLimit == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy) GetActiveMdaLimit() uint32 {
	if t == nil || t.ActiveMdaLimit == nil {
		return 0
	}
	return *t.ActiveMdaLimit
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.InterChassis.PopulateDefaults()
	t.IntraChassis.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis represents the /nokia-conf/configure/groups/group/isa/nat-group/redundancy/inter-chassis YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis struct {
	FlowTimeoutOnSwitchover *uint32                                                                                            `path:"flow-timeout-on-switchover" module:"nokia-conf"`
	IpMtu                   *uint32                                                                                            `path:"ip-mtu" module:"nokia-conf"`
	Keepalive               *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive                   `path:"keepalive" module:"nokia-conf"`
	LocalIpRangeStart       *string                                                                                            `path:"local-ip-range-start" module:"nokia-conf"`
	MonitorOperGroup        map[string]*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup `path:"monitor-oper-group" module:"nokia-conf"`
	MonitorPort             map[string]*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort      `path:"monitor-port" module:"nokia-conf"`
	Preferred               *bool                                                                                              `path:"preferred" module:"nokia-conf"`
	RemoteIpRangeStart      *string                                                                                            `path:"remote-ip-range-start" module:"nokia-conf"`
	ReplicationThreshold    *uint32                                                                                            `path:"replication-threshold" module:"nokia-conf"`
	RouterInstance          *string                                                                                            `path:"router-instance" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) IsYANGGoStruct() {}

// NewMonitorOperGroup creates a new entry in the MonitorOperGroup list of the
// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) NewMonitorOperGroup(OperGroup string) (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MonitorOperGroup == nil {
		t.MonitorOperGroup = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup)
	}

	key := OperGroup

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MonitorOperGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MonitorOperGroup", key)
	}

	t.MonitorOperGroup[key] = &NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup{
		OperGroup: &OperGroup,
	}

	return t.MonitorOperGroup[key], nil
}

// RenameMonitorOperGroup renames an entry in the list MonitorOperGroup within
// the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) RenameMonitorOperGroup(oldK, newK string) error {
	if _, ok := t.MonitorOperGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in MonitorOperGroup", newK)
	}

	e, ok := t.MonitorOperGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MonitorOperGroup", oldK)
	}
	e.OperGroup = &newK

	t.MonitorOperGroup[newK] = e
	delete(t.MonitorOperGroup, oldK)
	return nil
}

// GetOrCreateMonitorOperGroup retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetOrCreateMonitorOperGroup(OperGroup string) *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup {

	key := OperGroup

	if v, ok := t.MonitorOperGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMonitorOperGroup(OperGroup)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMonitorOperGroup got unexpected error: %v", err))
	}
	return v
}

// GetMonitorOperGroup retrieves the value with the specified key from
// the MonitorOperGroup map field of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetMonitorOperGroup(OperGroup string) *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup {

	if t == nil {
		return nil
	}

	key := OperGroup

	if lm, ok := t.MonitorOperGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteMonitorOperGroup deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) DeleteMonitorOperGroup(OperGroup string) {
	key := OperGroup

	delete(t.MonitorOperGroup, key)
}

// AppendMonitorOperGroup appends the supplied NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup struct to the
// list MonitorOperGroup of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) AppendMonitorOperGroup(v *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup) error {
	if v.OperGroup == nil {
		return fmt.Errorf("invalid nil key received for OperGroup")
	}

	key := *v.OperGroup

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MonitorOperGroup == nil {
		t.MonitorOperGroup = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup)
	}

	if _, ok := t.MonitorOperGroup[key]; ok {
		return fmt.Errorf("duplicate key for list MonitorOperGroup %v", key)
	}

	t.MonitorOperGroup[key] = v
	return nil
}

// NewMonitorPort creates a new entry in the MonitorPort list of the
// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) NewMonitorPort(PortId string) (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MonitorPort == nil {
		t.MonitorPort = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort)
	}

	key := PortId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MonitorPort[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MonitorPort", key)
	}

	t.MonitorPort[key] = &NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort{
		PortId: &PortId,
	}

	return t.MonitorPort[key], nil
}

// RenameMonitorPort renames an entry in the list MonitorPort within
// the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) RenameMonitorPort(oldK, newK string) error {
	if _, ok := t.MonitorPort[newK]; ok {
		return fmt.Errorf("key %v already exists in MonitorPort", newK)
	}

	e, ok := t.MonitorPort[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MonitorPort", oldK)
	}
	e.PortId = &newK

	t.MonitorPort[newK] = e
	delete(t.MonitorPort, oldK)
	return nil
}

// GetOrCreateMonitorPort retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetOrCreateMonitorPort(PortId string) *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort {

	key := PortId

	if v, ok := t.MonitorPort[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMonitorPort(PortId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMonitorPort got unexpected error: %v", err))
	}
	return v
}

// GetMonitorPort retrieves the value with the specified key from
// the MonitorPort map field of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetMonitorPort(PortId string) *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort {

	if t == nil {
		return nil
	}

	key := PortId

	if lm, ok := t.MonitorPort[key]; ok {
		return lm
	}
	return nil
}

// DeleteMonitorPort deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) DeleteMonitorPort(PortId string) {
	key := PortId

	delete(t.MonitorPort, key)
}

// AppendMonitorPort appends the supplied NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort struct to the
// list MonitorPort of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) AppendMonitorPort(v *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort) error {
	if v.PortId == nil {
		return fmt.Errorf("invalid nil key received for PortId")
	}

	key := *v.PortId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MonitorPort == nil {
		t.MonitorPort = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort)
	}

	if _, ok := t.MonitorPort[key]; ok {
		return fmt.Errorf("duplicate key for list MonitorPort %v", key)
	}

	t.MonitorPort[key] = v
	return nil
}

// GetOrCreateKeepalive retrieves the value of the Keepalive field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetOrCreateKeepalive() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive {
	if t.Keepalive != nil {
		return t.Keepalive
	}
	t.Keepalive = &NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive{}
	return t.Keepalive
}

// GetKeepalive returns the value of the Keepalive struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis. If the receiver or the field Keepalive is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetKeepalive() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive {
	if t != nil && t.Keepalive != nil {
		return t.Keepalive
	}
	return nil
}

// GetFlowTimeoutOnSwitchover retrieves the value of the leaf FlowTimeoutOnSwitchover from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlowTimeoutOnSwitchover is set, it can
// safely use t.GetFlowTimeoutOnSwitchover() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlowTimeoutOnSwitchover == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetFlowTimeoutOnSwitchover() uint32 {
	if t == nil || t.FlowTimeoutOnSwitchover == nil {
		return 50
	}
	return *t.FlowTimeoutOnSwitchover
}

// GetIpMtu retrieves the value of the leaf IpMtu from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpMtu is set, it can
// safely use t.GetIpMtu() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpMtu == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetIpMtu() uint32 {
	if t == nil || t.IpMtu == nil {
		return 1500
	}
	return *t.IpMtu
}

// GetLocalIpRangeStart retrieves the value of the leaf LocalIpRangeStart from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalIpRangeStart is set, it can
// safely use t.GetLocalIpRangeStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalIpRangeStart == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetLocalIpRangeStart() string {
	if t == nil || t.LocalIpRangeStart == nil {
		return ""
	}
	return *t.LocalIpRangeStart
}

// GetPreferred retrieves the value of the leaf Preferred from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Preferred is set, it can
// safely use t.GetPreferred() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Preferred == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetPreferred() bool {
	if t == nil || t.Preferred == nil {
		return false
	}
	return *t.Preferred
}

// GetRemoteIpRangeStart retrieves the value of the leaf RemoteIpRangeStart from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteIpRangeStart is set, it can
// safely use t.GetRemoteIpRangeStart() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteIpRangeStart == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetRemoteIpRangeStart() string {
	if t == nil || t.RemoteIpRangeStart == nil {
		return ""
	}
	return *t.RemoteIpRangeStart
}

// GetReplicationThreshold retrieves the value of the leaf ReplicationThreshold from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReplicationThreshold is set, it can
// safely use t.GetReplicationThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReplicationThreshold == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetReplicationThreshold() uint32 {
	if t == nil || t.ReplicationThreshold == nil {
		return 20
	}
	return *t.ReplicationThreshold
}

// GetRouterInstance retrieves the value of the leaf RouterInstance from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouterInstance is set, it can
// safely use t.GetRouterInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouterInstance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) GetRouterInstance() string {
	if t == nil || t.RouterInstance == nil {
		return ""
	}
	return *t.RouterInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FlowTimeoutOnSwitchover == nil {
		var v uint32 = 50
		t.FlowTimeoutOnSwitchover = &v
	}
	if t.IpMtu == nil {
		var v uint32 = 1500
		t.IpMtu = &v
	}
	if t.Preferred == nil {
		var v bool = false
		t.Preferred = &v
	}
	if t.ReplicationThreshold == nil {
		var v uint32 = 20
		t.ReplicationThreshold = &v
	}
	t.Keepalive.PopulateDefaults()
	for _, e := range t.MonitorOperGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.MonitorPort {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive represents the /nokia-conf/configure/groups/group/isa/nat-group/redundancy/inter-chassis/keepalive YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive struct {
	Dropcount *uint32 `path:"dropcount" module:"nokia-conf"`
	Interval  *uint32 `path:"interval" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive) IsYANGGoStruct() {
}

// GetDropcount retrieves the value of the leaf Dropcount from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Dropcount is set, it can
// safely use t.GetDropcount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Dropcount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive) GetDropcount() uint32 {
	if t == nil || t.Dropcount == nil {
		return 2
	}
	return *t.Dropcount
}

// GetInterval retrieves the value of the leaf Interval from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 30
	}
	return *t.Interval
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Dropcount == nil {
		var v uint32 = 2
		t.Dropcount = &v
	}
	if t.Interval == nil {
		var v uint32 = 30
		t.Interval = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_Keepalive) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup represents the /nokia-conf/configure/groups/group/isa/nat-group/redundancy/inter-chassis/monitor-oper-group YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup struct {
	HealthDrop *uint32 `path:"health-drop" module:"nokia-conf"`
	OperGroup  *string `path:"oper-group" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup) IsYANGGoStruct() {
}

// GetHealthDrop retrieves the value of the leaf HealthDrop from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HealthDrop is set, it can
// safely use t.GetHealthDrop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HealthDrop == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup) GetHealthDrop() uint32 {
	if t == nil || t.HealthDrop == nil {
		return 1
	}
	return *t.HealthDrop
}

// GetOperGroup retrieves the value of the leaf OperGroup from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OperGroup is set, it can
// safely use t.GetOperGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OperGroup == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup) GetOperGroup() string {
	if t == nil || t.OperGroup == nil {
		return ""
	}
	return *t.OperGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.HealthDrop == nil {
		var v uint32 = 1
		t.HealthDrop = &v
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup) ΛListKeyMap() (map[string]interface{}, error) {
	if t.OperGroup == nil {
		return nil, fmt.Errorf("nil value for key OperGroup")
	}

	return map[string]interface{}{
		"oper-group": *t.OperGroup,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorOperGroup) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort represents the /nokia-conf/configure/groups/group/isa/nat-group/redundancy/inter-chassis/monitor-port YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort struct {
	HealthDrop *uint32 `path:"health-drop" module:"nokia-conf"`
	PortId     *string `path:"port-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort) IsYANGGoStruct() {
}

// GetHealthDrop retrieves the value of the leaf HealthDrop from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HealthDrop is set, it can
// safely use t.GetHealthDrop() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HealthDrop == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort) GetHealthDrop() uint32 {
	if t == nil || t.HealthDrop == nil {
		return 1
	}
	return *t.HealthDrop
}

// GetPortId retrieves the value of the leaf PortId from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortId is set, it can
// safely use t.GetPortId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort) GetPortId() string {
	if t == nil || t.PortId == nil {
		return ""
	}
	return *t.PortId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.HealthDrop == nil {
		var v uint32 = 1
		t.HealthDrop = &v
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PortId == nil {
		return nil, fmt.Errorf("nil value for key PortId")
	}

	return map[string]interface{}{
		"port-id": *t.PortId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_InterChassis_MonitorPort) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis represents the /nokia-conf/configure/groups/group/isa/nat-group/redundancy/intra-chassis YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis struct {
	ActiveActive  *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive `path:"active-active" module:"nokia-conf"`
	ActiveStandby YANGEmpty                                                                           `path:"active-standby" module:"nokia-conf"`
	L2AwareBypass YANGEmpty                                                                           `path:"l2aware-bypass" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis) IsYANGGoStruct() {}

// GetOrCreateActiveActive retrieves the value of the ActiveActive field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis) GetOrCreateActiveActive() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive {
	if t.ActiveActive != nil {
		return t.ActiveActive
	}
	t.ActiveActive = &NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive{}
	return t.ActiveActive
}

// GetActiveActive returns the value of the ActiveActive struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis. If the receiver or the field ActiveActive is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis) GetActiveActive() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive {
	if t != nil && t.ActiveActive != nil {
		return t.ActiveActive
	}
	return nil
}

// GetActiveStandby retrieves the value of the leaf ActiveStandby from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ActiveStandby is set, it can
// safely use t.GetActiveStandby() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ActiveStandby == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis) GetActiveStandby() YANGEmpty {
	if t == nil || t.ActiveStandby == false {
		return false
	}
	return t.ActiveStandby
}

// GetL2AwareBypass retrieves the value of the leaf L2AwareBypass from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if L2AwareBypass is set, it can
// safely use t.GetL2AwareBypass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.L2AwareBypass == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis) GetL2AwareBypass() YANGEmpty {
	if t == nil || t.L2AwareBypass == false {
		return false
	}
	return t.L2AwareBypass
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ActiveActive.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive represents the /nokia-conf/configure/groups/group/isa/nat-group/redundancy/intra-chassis/active-active YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive struct {
	FailedMdaLimit *uint32 `path:"failed-mda-limit" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive) IsYANGGoStruct() {
}

// GetFailedMdaLimit retrieves the value of the leaf FailedMdaLimit from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FailedMdaLimit is set, it can
// safely use t.GetFailedMdaLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FailedMdaLimit == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive) GetFailedMdaLimit() uint32 {
	if t == nil || t.FailedMdaLimit == nil {
		return 0
	}
	return *t.FailedMdaLimit
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_Redundancy_IntraChassis_ActiveActive) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits represents the /nokia-conf/configure/groups/group/isa/nat-group/session-limits YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits struct {
	Reserved     *uint32                                                                 `path:"reserved" module:"nokia-conf"`
	UpnpMappings *uint32                                                                 `path:"upnp-mappings" module:"nokia-conf"`
	Watermarks   *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks `path:"watermarks" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits) IsYANGGoStruct() {}

// GetOrCreateWatermarks retrieves the value of the Watermarks field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits) GetOrCreateWatermarks() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks {
	if t.Watermarks != nil {
		return t.Watermarks
	}
	t.Watermarks = &NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks{}
	return t.Watermarks
}

// GetWatermarks returns the value of the Watermarks struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits. If the receiver or the field Watermarks is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits) GetWatermarks() *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks {
	if t != nil && t.Watermarks != nil {
		return t.Watermarks
	}
	return nil
}

// GetReserved retrieves the value of the leaf Reserved from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Reserved is set, it can
// safely use t.GetReserved() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Reserved == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits) GetReserved() uint32 {
	if t == nil || t.Reserved == nil {
		return 0
	}
	return *t.Reserved
}

// GetUpnpMappings retrieves the value of the leaf UpnpMappings from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpnpMappings is set, it can
// safely use t.GetUpnpMappings() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpnpMappings == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits) GetUpnpMappings() uint32 {
	if t == nil || t.UpnpMappings == nil {
		return 524288
	}
	return *t.UpnpMappings
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.UpnpMappings == nil {
		var v uint32 = 524288
		t.UpnpMappings = &v
	}
	t.Watermarks.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks represents the /nokia-conf/configure/groups/group/isa/nat-group/session-limits/watermarks YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks struct {
	High *uint32 `path:"high" module:"nokia-conf"`
	Low  *uint32 `path:"low" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks) IsYANGGoStruct() {}

// GetHigh retrieves the value of the leaf High from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if High is set, it can
// safely use t.GetHigh() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.High == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks) GetHigh() uint32 {
	if t == nil || t.High == nil {
		return 0
	}
	return *t.High
}

// GetLow retrieves the value of the leaf Low from the NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Low is set, it can
// safely use t.GetLow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Low == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks) GetLow() uint32 {
	if t == nil || t.Low == nil {
		return 0
	}
	return *t.Low
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks.
func (*NokiaConf_Configure_Groups_Group_Isa_NatGroup_SessionLimits_Watermarks) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_TunnelGroup represents the /nokia-conf/configure/groups/group/isa/tunnel-group YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_TunnelGroup struct {
	AdminState         E_NokiaTypesSros_AdminState                                       `path:"admin-state" module:"nokia-conf"`
	Backup             *string                                                           `path:"backup" module:"nokia-conf"`
	Description        *string                                                           `path:"description" module:"nokia-conf"`
	Id                 NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Id_Union         `path:"id" module:"nokia-conf"`
	IpsecResponderOnly *bool                                                             `path:"ipsec-responder-only" module:"nokia-conf"`
	IsaScaleMode       E_NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_IsaScaleMode   `path:"isa-scale-mode" module:"nokia-conf"`
	MultiActive        *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive     `path:"multi-active" module:"nokia-conf" yangPresence:"true"`
	Primary            *string                                                           `path:"primary" module:"nokia-conf"`
	Reassembly         *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly      `path:"reassembly" module:"nokia-conf"`
	StatsCollection    *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection `path:"stats-collection" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_TunnelGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) IsYANGGoStruct() {}

// GetOrCreateMultiActive retrieves the value of the MultiActive field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetOrCreateMultiActive() *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive {
	if t.MultiActive != nil {
		return t.MultiActive
	}
	t.MultiActive = &NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive{}
	return t.MultiActive
}

// GetOrCreateReassembly retrieves the value of the Reassembly field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetOrCreateReassembly() *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly {
	if t.Reassembly != nil {
		return t.Reassembly
	}
	t.Reassembly = &NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly{}
	return t.Reassembly
}

// GetOrCreateStatsCollection retrieves the value of the StatsCollection field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetOrCreateStatsCollection() *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection {
	if t.StatsCollection != nil {
		return t.StatsCollection
	}
	t.StatsCollection = &NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection{}
	return t.StatsCollection
}

// GetMultiActive returns the value of the MultiActive struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_TunnelGroup. If the receiver or the field MultiActive is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetMultiActive() *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive {
	if t != nil && t.MultiActive != nil {
		return t.MultiActive
	}
	return nil
}

// GetReassembly returns the value of the Reassembly struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_TunnelGroup. If the receiver or the field Reassembly is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetReassembly() *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly {
	if t != nil && t.Reassembly != nil {
		return t.Reassembly
	}
	return nil
}

// GetStatsCollection returns the value of the StatsCollection struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_TunnelGroup. If the receiver or the field StatsCollection is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetStatsCollection() *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection {
	if t != nil && t.StatsCollection != nil {
		return t.StatsCollection
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetBackup retrieves the value of the leaf Backup from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Backup is set, it can
// safely use t.GetBackup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Backup == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetBackup() string {
	if t == nil || t.Backup == nil {
		return ""
	}
	return *t.Backup
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetId() NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// GetIpsecResponderOnly retrieves the value of the leaf IpsecResponderOnly from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IpsecResponderOnly is set, it can
// safely use t.GetIpsecResponderOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IpsecResponderOnly == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetIpsecResponderOnly() bool {
	if t == nil || t.IpsecResponderOnly == nil {
		return false
	}
	return *t.IpsecResponderOnly
}

// GetIsaScaleMode retrieves the value of the leaf IsaScaleMode from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsaScaleMode is set, it can
// safely use t.GetIsaScaleMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsaScaleMode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetIsaScaleMode() E_NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_IsaScaleMode {
	if t == nil || t.IsaScaleMode == 0 {
		return 0
	}
	return t.IsaScaleMode
}

// GetPrimary retrieves the value of the leaf Primary from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Primary is set, it can
// safely use t.GetPrimary() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Primary == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) GetPrimary() string {
	if t == nil || t.Primary == nil {
		return ""
	}
	return *t.Primary
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.IpsecResponderOnly == nil {
		var v bool = false
		t.IpsecResponderOnly = &v
	}
	t.MultiActive.PopulateDefaults()
	t.Reassembly.PopulateDefaults()
	t.StatsCollection.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_TunnelGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_TunnelGroup.
func (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive represents the /nokia-conf/configure/groups/group/isa/tunnel-group/multi-active YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive struct {
	ActiveIsaNumber *uint32                                                                                                                                    `path:"active-isa-number" module:"nokia-conf"`
	Esa             map[NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa `path:"esa" module:"nokia-conf"`
	Isa             map[string]*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa                                                               `path:"isa" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) IsYANGGoStruct() {}

// NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Key represents the key for list Esa of element /nokia-conf/configure/groups/group/isa/tunnel-group/multi-active.
type NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Key struct {
	EsaId NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_EsaId_Union `path:"esa-id"`
	Vm    NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Vm_Union    `path:"vm"`
}

// NewEsa creates a new entry in the Esa list of the
// NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) NewEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Vm_Union) (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Esa == nil {
		t.Esa = make(map[NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa)
	}

	key := NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Esa[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Esa", key)
	}

	t.Esa[key] = &NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa{
		EsaId: EsaId,
		Vm:    Vm,
	}

	return t.Esa[key], nil
}

// RenameEsa renames an entry in the list Esa within
// the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) RenameEsa(oldK, newK NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Key) error {
	if _, ok := t.Esa[newK]; ok {
		return fmt.Errorf("key %v already exists in Esa", newK)
	}

	e, ok := t.Esa[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Esa", oldK)
	}
	e.EsaId = newK.EsaId
	e.Vm = newK.Vm

	t.Esa[newK] = e
	delete(t.Esa, oldK)
	return nil
}

// GetOrCreateEsa retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) GetOrCreateEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Vm_Union) *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa {

	key := NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	if v, ok := t.Esa[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEsa(EsaId, Vm)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEsa got unexpected error: %v", err))
	}
	return v
}

// GetEsa retrieves the value with the specified key from
// the Esa map field of NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) GetEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Vm_Union) *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa {

	if t == nil {
		return nil
	}

	key := NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	if lm, ok := t.Esa[key]; ok {
		return lm
	}
	return nil
}

// DeleteEsa deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) DeleteEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Vm_Union) {
	key := NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	delete(t.Esa, key)
}

// AppendEsa appends the supplied NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa struct to the
// list Esa of NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) AppendEsa(v *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa) error {
	key := NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Key{
		EsaId: v.EsaId,
		Vm:    v.Vm,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Esa == nil {
		t.Esa = make(map[NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa)
	}

	if _, ok := t.Esa[key]; ok {
		return fmt.Errorf("duplicate key for list Esa %v", key)
	}

	t.Esa[key] = v
	return nil
}

// NewIsa creates a new entry in the Isa list of the
// NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) NewIsa(IsaId string) (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Isa == nil {
		t.Isa = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa)
	}

	key := IsaId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Isa[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Isa", key)
	}

	t.Isa[key] = &NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa{
		IsaId: &IsaId,
	}

	return t.Isa[key], nil
}

// RenameIsa renames an entry in the list Isa within
// the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) RenameIsa(oldK, newK string) error {
	if _, ok := t.Isa[newK]; ok {
		return fmt.Errorf("key %v already exists in Isa", newK)
	}

	e, ok := t.Isa[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Isa", oldK)
	}
	e.IsaId = &newK

	t.Isa[newK] = e
	delete(t.Isa, oldK)
	return nil
}

// GetOrCreateIsa retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) GetOrCreateIsa(IsaId string) *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa {

	key := IsaId

	if v, ok := t.Isa[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIsa(IsaId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIsa got unexpected error: %v", err))
	}
	return v
}

// GetIsa retrieves the value with the specified key from
// the Isa map field of NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) GetIsa(IsaId string) *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa {

	if t == nil {
		return nil
	}

	key := IsaId

	if lm, ok := t.Isa[key]; ok {
		return lm
	}
	return nil
}

// DeleteIsa deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) DeleteIsa(IsaId string) {
	key := IsaId

	delete(t.Isa, key)
}

// AppendIsa appends the supplied NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa struct to the
// list Isa of NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) AppendIsa(v *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa) error {
	if v.IsaId == nil {
		return fmt.Errorf("invalid nil key received for IsaId")
	}

	key := *v.IsaId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Isa == nil {
		t.Isa = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa)
	}

	if _, ok := t.Isa[key]; ok {
		return fmt.Errorf("duplicate key for list Isa %v", key)
	}

	t.Isa[key] = v
	return nil
}

// GetActiveIsaNumber retrieves the value of the leaf ActiveIsaNumber from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ActiveIsaNumber is set, it can
// safely use t.GetActiveIsaNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ActiveIsaNumber == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) GetActiveIsaNumber() uint32 {
	if t == nil || t.ActiveIsaNumber == nil {
		return 1
	}
	return *t.ActiveIsaNumber
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ActiveIsaNumber == nil {
		var v uint32 = 1
		t.ActiveIsaNumber = &v
	}
	for _, e := range t.Esa {
		e.PopulateDefaults()
	}
	for _, e := range t.Isa {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive.
func (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa represents the /nokia-conf/configure/groups/group/isa/tunnel-group/multi-active/esa YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa struct {
	EsaId NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_EsaId_Union `path:"esa-id" module:"nokia-conf"`
	Vm    NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Vm_Union    `path:"vm" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa) IsYANGGoStruct() {}

// GetEsaId retrieves the value of the leaf EsaId from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EsaId is set, it can
// safely use t.GetEsaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EsaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa) GetEsaId() NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_EsaId_Union {
	if t == nil || t.EsaId == nil {
		return nil
	}
	return t.EsaId
}

// GetVm retrieves the value of the leaf Vm from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vm is set, it can
// safely use t.GetVm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa) GetVm() NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa_Vm_Union {
	if t == nil || t.Vm == nil {
		return nil
	}
	return t.Vm
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"esa-id": t.EsaId,
		"vm":     t.Vm,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa.
func (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Esa) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa represents the /nokia-conf/configure/groups/group/isa/tunnel-group/multi-active/isa YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa struct {
	IsaId *string `path:"isa-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa) IsYANGGoStruct() {}

// GetIsaId retrieves the value of the leaf IsaId from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsaId is set, it can
// safely use t.GetIsaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa) GetIsaId() string {
	if t == nil || t.IsaId == nil {
		return ""
	}
	return *t.IsaId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa) ΛListKeyMap() (map[string]interface{}, error) {
	if t.IsaId == nil {
		return nil, fmt.Errorf("nil value for key IsaId")
	}

	return map[string]interface{}{
		"isa-id": *t.IsaId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa.
func (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_MultiActive_Isa) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly represents the /nokia-conf/configure/groups/group/isa/tunnel-group/reassembly YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly struct {
	MaxWaitTime *int32 `path:"max-wait-time" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly) IsYANGGoStruct() {}

// GetMaxWaitTime retrieves the value of the leaf MaxWaitTime from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxWaitTime is set, it can
// safely use t.GetMaxWaitTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxWaitTime == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly) GetMaxWaitTime() int32 {
	if t == nil || t.MaxWaitTime == nil {
		return 0
	}
	return *t.MaxWaitTime
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly.
func (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_Reassembly) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection represents the /nokia-conf/configure/groups/group/isa/tunnel-group/stats-collection YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection struct {
	IsaDpCpuUsage *bool `path:"isa-dp-cpu-usage" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection) IsYANGGoStruct() {}

// GetIsaDpCpuUsage retrieves the value of the leaf IsaDpCpuUsage from the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsaDpCpuUsage is set, it can
// safely use t.GetIsaDpCpuUsage() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsaDpCpuUsage == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection) GetIsaDpCpuUsage() bool {
	if t == nil || t.IsaDpCpuUsage == nil {
		return false
	}
	return *t.IsaDpCpuUsage
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.IsaDpCpuUsage == nil {
		var v bool = false
		t.IsaDpCpuUsage = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection.
func (*NokiaConf_Configure_Groups_Group_Isa_TunnelGroup_StatsCollection) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_VideoGroup represents the /nokia-conf/configure/groups/group/isa/video-group YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_VideoGroup struct {
	AdInsert        *bool                                                                                                              `path:"ad-insert" module:"nokia-conf"`
	AdminState      E_NokiaTypesSros_AdminState                                                                                        `path:"admin-state" module:"nokia-conf"`
	Analyzer        *bool                                                                                                              `path:"analyzer" module:"nokia-conf"`
	Description     *string                                                                                                            `path:"description" module:"nokia-conf"`
	FccServer       *bool                                                                                                              `path:"fcc-server" module:"nokia-conf"`
	LocalRtServer   *bool                                                                                                              `path:"local-rt-server" module:"nokia-conf"`
	Mda             map[string]*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda                                                    `path:"mda" module:"nokia-conf"`
	ResvRet         *uint32                                                                                                            `path:"resv-ret" module:"nokia-conf"`
	RtClient        *bool                                                                                                              `path:"rt-client" module:"nokia-conf"`
	StreamSelection *bool                                                                                                              `path:"stream-selection" module:"nokia-conf"`
	Vapp            map[NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_Key]*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp `path:"vapp" module:"nokia-conf"`
	VideoGroupId    NokiaConf_Configure_Groups_Group_Isa_VideoGroup_VideoGroupId_Union                                                 `path:"video-group-id" module:"nokia-conf"`
	Watermark       *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark                                                         `path:"watermark" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_VideoGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup) IsYANGGoStruct() {}

// NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_Key represents the key for list Vapp of element /nokia-conf/configure/groups/group/isa/video-group.
type NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_Key struct {
	EsaId  NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_EsaId_Union  `path:"esa-id"`
	VappId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_VappId_Union `path:"vapp-id"`
}

// NewMda creates a new entry in the Mda list of the
// NokiaConf_Configure_Groups_Group_Isa_VideoGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) NewMda(MdaId string) (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mda == nil {
		t.Mda = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda)
	}

	key := MdaId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mda[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mda", key)
	}

	t.Mda[key] = &NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda{
		MdaId: &MdaId,
	}

	return t.Mda[key], nil
}

// RenameMda renames an entry in the list Mda within
// the NokiaConf_Configure_Groups_Group_Isa_VideoGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) RenameMda(oldK, newK string) error {
	if _, ok := t.Mda[newK]; ok {
		return fmt.Errorf("key %v already exists in Mda", newK)
	}

	e, ok := t.Mda[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mda", oldK)
	}
	e.MdaId = &newK

	t.Mda[newK] = e
	delete(t.Mda, oldK)
	return nil
}

// GetOrCreateMda retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_VideoGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetOrCreateMda(MdaId string) *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda {

	key := MdaId

	if v, ok := t.Mda[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMda(MdaId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMda got unexpected error: %v", err))
	}
	return v
}

// GetMda retrieves the value with the specified key from
// the Mda map field of NokiaConf_Configure_Groups_Group_Isa_VideoGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetMda(MdaId string) *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda {

	if t == nil {
		return nil
	}

	key := MdaId

	if lm, ok := t.Mda[key]; ok {
		return lm
	}
	return nil
}

// DeleteMda deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_VideoGroup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) DeleteMda(MdaId string) {
	key := MdaId

	delete(t.Mda, key)
}

// AppendMda appends the supplied NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda struct to the
// list Mda of NokiaConf_Configure_Groups_Group_Isa_VideoGroup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) AppendMda(v *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda) error {
	if v.MdaId == nil {
		return fmt.Errorf("invalid nil key received for MdaId")
	}

	key := *v.MdaId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mda == nil {
		t.Mda = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda)
	}

	if _, ok := t.Mda[key]; ok {
		return fmt.Errorf("duplicate key for list Mda %v", key)
	}

	t.Mda[key] = v
	return nil
}

// NewVapp creates a new entry in the Vapp list of the
// NokiaConf_Configure_Groups_Group_Isa_VideoGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) NewVapp(EsaId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_EsaId_Union, VappId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_VappId_Union) (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vapp == nil {
		t.Vapp = make(map[NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_Key]*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp)
	}

	key := NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_Key{
		EsaId:  EsaId,
		VappId: VappId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vapp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vapp", key)
	}

	t.Vapp[key] = &NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp{
		EsaId:  EsaId,
		VappId: VappId,
	}

	return t.Vapp[key], nil
}

// RenameVapp renames an entry in the list Vapp within
// the NokiaConf_Configure_Groups_Group_Isa_VideoGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) RenameVapp(oldK, newK NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_Key) error {
	if _, ok := t.Vapp[newK]; ok {
		return fmt.Errorf("key %v already exists in Vapp", newK)
	}

	e, ok := t.Vapp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vapp", oldK)
	}
	e.EsaId = newK.EsaId
	e.VappId = newK.VappId

	t.Vapp[newK] = e
	delete(t.Vapp, oldK)
	return nil
}

// GetOrCreateVapp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_VideoGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetOrCreateVapp(EsaId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_EsaId_Union, VappId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_VappId_Union) *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp {

	key := NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_Key{
		EsaId:  EsaId,
		VappId: VappId,
	}

	if v, ok := t.Vapp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVapp(EsaId, VappId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVapp got unexpected error: %v", err))
	}
	return v
}

// GetVapp retrieves the value with the specified key from
// the Vapp map field of NokiaConf_Configure_Groups_Group_Isa_VideoGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetVapp(EsaId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_EsaId_Union, VappId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_VappId_Union) *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp {

	if t == nil {
		return nil
	}

	key := NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_Key{
		EsaId:  EsaId,
		VappId: VappId,
	}

	if lm, ok := t.Vapp[key]; ok {
		return lm
	}
	return nil
}

// DeleteVapp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_VideoGroup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) DeleteVapp(EsaId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_EsaId_Union, VappId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_VappId_Union) {
	key := NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_Key{
		EsaId:  EsaId,
		VappId: VappId,
	}

	delete(t.Vapp, key)
}

// AppendVapp appends the supplied NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp struct to the
// list Vapp of NokiaConf_Configure_Groups_Group_Isa_VideoGroup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) AppendVapp(v *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp) error {
	key := NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_Key{
		EsaId:  v.EsaId,
		VappId: v.VappId,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vapp == nil {
		t.Vapp = make(map[NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_Key]*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp)
	}

	if _, ok := t.Vapp[key]; ok {
		return fmt.Errorf("duplicate key for list Vapp %v", key)
	}

	t.Vapp[key] = v
	return nil
}

// GetOrCreateWatermark retrieves the value of the Watermark field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetOrCreateWatermark() *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark {
	if t.Watermark != nil {
		return t.Watermark
	}
	t.Watermark = &NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark{}
	return t.Watermark
}

// GetWatermark returns the value of the Watermark struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_VideoGroup. If the receiver or the field Watermark is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetWatermark() *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark {
	if t != nil && t.Watermark != nil {
		return t.Watermark
	}
	return nil
}

// GetAdInsert retrieves the value of the leaf AdInsert from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdInsert is set, it can
// safely use t.GetAdInsert() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdInsert == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetAdInsert() bool {
	if t == nil || t.AdInsert == nil {
		return false
	}
	return *t.AdInsert
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetAnalyzer retrieves the value of the leaf Analyzer from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Analyzer is set, it can
// safely use t.GetAnalyzer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Analyzer == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetAnalyzer() bool {
	if t == nil || t.Analyzer == nil {
		return false
	}
	return *t.Analyzer
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFccServer retrieves the value of the leaf FccServer from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FccServer is set, it can
// safely use t.GetFccServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FccServer == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetFccServer() bool {
	if t == nil || t.FccServer == nil {
		return false
	}
	return *t.FccServer
}

// GetLocalRtServer retrieves the value of the leaf LocalRtServer from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalRtServer is set, it can
// safely use t.GetLocalRtServer() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalRtServer == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetLocalRtServer() bool {
	if t == nil || t.LocalRtServer == nil {
		return false
	}
	return *t.LocalRtServer
}

// GetResvRet retrieves the value of the leaf ResvRet from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ResvRet is set, it can
// safely use t.GetResvRet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ResvRet == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetResvRet() uint32 {
	if t == nil || t.ResvRet == nil {
		return 0
	}
	return *t.ResvRet
}

// GetRtClient retrieves the value of the leaf RtClient from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RtClient is set, it can
// safely use t.GetRtClient() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RtClient == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetRtClient() bool {
	if t == nil || t.RtClient == nil {
		return true
	}
	return *t.RtClient
}

// GetStreamSelection retrieves the value of the leaf StreamSelection from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StreamSelection is set, it can
// safely use t.GetStreamSelection() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StreamSelection == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetStreamSelection() bool {
	if t == nil || t.StreamSelection == nil {
		return false
	}
	return *t.StreamSelection
}

// GetVideoGroupId retrieves the value of the leaf VideoGroupId from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VideoGroupId is set, it can
// safely use t.GetVideoGroupId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VideoGroupId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) GetVideoGroupId() NokiaConf_Configure_Groups_Group_Isa_VideoGroup_VideoGroupId_Union {
	if t == nil || t.VideoGroupId == nil {
		return nil
	}
	return t.VideoGroupId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_VideoGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdInsert == nil {
		var v bool = false
		t.AdInsert = &v
	}
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.Analyzer == nil {
		var v bool = false
		t.Analyzer = &v
	}
	if t.FccServer == nil {
		var v bool = false
		t.FccServer = &v
	}
	if t.LocalRtServer == nil {
		var v bool = false
		t.LocalRtServer = &v
	}
	if t.RtClient == nil {
		var v bool = true
		t.RtClient = &v
	}
	if t.StreamSelection == nil {
		var v bool = false
		t.StreamSelection = &v
	}
	t.Watermark.PopulateDefaults()
	for _, e := range t.Mda {
		e.PopulateDefaults()
	}
	for _, e := range t.Vapp {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_VideoGroup struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"video-group-id": t.VideoGroupId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_VideoGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_VideoGroup.
func (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda represents the /nokia-conf/configure/groups/group/isa/video-group/mda YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda struct {
	MdaId *string `path:"mda-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda) IsYANGGoStruct() {}

// GetMdaId retrieves the value of the leaf MdaId from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MdaId is set, it can
// safely use t.GetMdaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MdaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda) GetMdaId() string {
	if t == nil || t.MdaId == nil {
		return ""
	}
	return *t.MdaId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MdaId == nil {
		return nil, fmt.Errorf("nil value for key MdaId")
	}

	return map[string]interface{}{
		"mda-id": *t.MdaId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda.
func (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Mda) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp represents the /nokia-conf/configure/groups/group/isa/video-group/vapp YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp struct {
	EsaId  NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_EsaId_Union  `path:"esa-id" module:"nokia-conf"`
	VappId NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_VappId_Union `path:"vapp-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp) IsYANGGoStruct() {}

// GetEsaId retrieves the value of the leaf EsaId from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EsaId is set, it can
// safely use t.GetEsaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EsaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp) GetEsaId() NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_EsaId_Union {
	if t == nil || t.EsaId == nil {
		return nil
	}
	return t.EsaId
}

// GetVappId retrieves the value of the leaf VappId from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if VappId is set, it can
// safely use t.GetVappId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.VappId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp) GetVappId() NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp_VappId_Union {
	if t == nil || t.VappId == nil {
		return nil
	}
	return t.VappId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"esa-id":  t.EsaId,
		"vapp-id": t.VappId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp.
func (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Vapp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark represents the /nokia-conf/configure/groups/group/isa/video-group/watermark YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark struct {
	Bandwidth *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth `path:"bandwidth" module:"nokia-conf"`
	Session   *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session   `path:"session" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark) IsYANGGoStruct() {}

// GetOrCreateBandwidth retrieves the value of the Bandwidth field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark) GetOrCreateBandwidth() *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth {
	if t.Bandwidth != nil {
		return t.Bandwidth
	}
	t.Bandwidth = &NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth{}
	return t.Bandwidth
}

// GetOrCreateSession retrieves the value of the Session field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark) GetOrCreateSession() *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session {
	if t.Session != nil {
		return t.Session
	}
	t.Session = &NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session{}
	return t.Session
}

// GetBandwidth returns the value of the Bandwidth struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark. If the receiver or the field Bandwidth is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark) GetBandwidth() *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth {
	if t != nil && t.Bandwidth != nil {
		return t.Bandwidth
	}
	return nil
}

// GetSession returns the value of the Session struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark. If the receiver or the field Session is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark) GetSession() *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session {
	if t != nil && t.Session != nil {
		return t.Session
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Bandwidth.PopulateDefaults()
	t.Session.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark.
func (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth represents the /nokia-conf/configure/groups/group/isa/video-group/watermark/bandwidth YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth struct {
	Fcc   *uint32 `path:"fcc" module:"nokia-conf"`
	Ret   *uint32 `path:"ret" module:"nokia-conf"`
	Total *uint32 `path:"total" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth) IsYANGGoStruct() {}

// GetFcc retrieves the value of the leaf Fcc from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fcc is set, it can
// safely use t.GetFcc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fcc == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth) GetFcc() uint32 {
	if t == nil || t.Fcc == nil {
		return 90
	}
	return *t.Fcc
}

// GetRet retrieves the value of the leaf Ret from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ret is set, it can
// safely use t.GetRet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ret == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth) GetRet() uint32 {
	if t == nil || t.Ret == nil {
		return 90
	}
	return *t.Ret
}

// GetTotal retrieves the value of the leaf Total from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Total is set, it can
// safely use t.GetTotal() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Total == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth) GetTotal() uint32 {
	if t == nil || t.Total == nil {
		return 90
	}
	return *t.Total
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Fcc == nil {
		var v uint32 = 90
		t.Fcc = &v
	}
	if t.Ret == nil {
		var v uint32 = 90
		t.Ret = &v
	}
	if t.Total == nil {
		var v uint32 = 90
		t.Total = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth.
func (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Bandwidth) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session represents the /nokia-conf/configure/groups/group/isa/video-group/watermark/session YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session struct {
	Fcc   *uint32 `path:"fcc" module:"nokia-conf"`
	Ret   *uint32 `path:"ret" module:"nokia-conf"`
	Total *uint32 `path:"total" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session) IsYANGGoStruct() {}

// GetFcc retrieves the value of the leaf Fcc from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Fcc is set, it can
// safely use t.GetFcc() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Fcc == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session) GetFcc() uint32 {
	if t == nil || t.Fcc == nil {
		return 90
	}
	return *t.Fcc
}

// GetRet retrieves the value of the leaf Ret from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ret is set, it can
// safely use t.GetRet() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ret == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session) GetRet() uint32 {
	if t == nil || t.Ret == nil {
		return 90
	}
	return *t.Ret
}

// GetTotal retrieves the value of the leaf Total from the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Total is set, it can
// safely use t.GetTotal() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Total == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session) GetTotal() uint32 {
	if t == nil || t.Total == nil {
		return 90
	}
	return *t.Total
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Fcc == nil {
		var v uint32 = 90
		t.Fcc = &v
	}
	if t.Ret == nil {
		var v uint32 = 90
		t.Ret = &v
	}
	if t.Total == nil {
		var v uint32 = 90
		t.Total = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session.
func (*NokiaConf_Configure_Groups_Group_Isa_VideoGroup_Watermark_Session) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup represents the /nokia-conf/configure/groups/group/isa/wlan-gw-group YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup struct {
	ActiveIomLimit     *uint32                                                                                                                         `path:"active-iom-limit" module:"nokia-conf"`
	ActiveMdaLimit     *uint32                                                                                                                         `path:"active-mda-limit" module:"nokia-conf"`
	AdminState         E_NokiaTypesSros_AdminState                                                                                                     `path:"admin-state" module:"nokia-conf"`
	Description        *string                                                                                                                         `path:"description" module:"nokia-conf"`
	DistributedSubMgmt *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt                                                            `path:"distributed-sub-mgmt" module:"nokia-conf"`
	Esa                map[NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa              `path:"esa" module:"nokia-conf"`
	Id                 NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Id_Union                                                                       `path:"id" module:"nokia-conf"`
	Iom                map[NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom_SlotNumber_Union]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom `path:"iom" module:"nokia-conf"`
	Mda                map[string]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda                                                                `path:"mda" module:"nokia-conf"`
	Nat                *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat                                                                           `path:"nat" module:"nokia-conf"`
	PortPolicy         *string                                                                                                                         `path:"port-policy" module:"nokia-conf"`
	Redundancy         E_NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Redundancy                                                                   `path:"redundancy" module:"nokia-conf"`
	ScalingProfile     E_NokiaTypesSros_IsaScalingProfile                                                                                              `path:"scaling-profile" module:"nokia-conf"`
	TunnelPortPolicy   *string                                                                                                                         `path:"tunnel-port-policy" module:"nokia-conf"`
	Watermarks         *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks                                                                    `path:"watermarks" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) IsYANGGoStruct() {}

// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Key represents the key for list Esa of element /nokia-conf/configure/groups/group/isa/wlan-gw-group.
type NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Key struct {
	EsaId NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_EsaId_Union `path:"esa-id"`
	Vm    NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Vm_Union    `path:"vm"`
}

// NewEsa creates a new entry in the Esa list of the
// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) NewEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Vm_Union) (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Esa == nil {
		t.Esa = make(map[NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa)
	}

	key := NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Esa[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Esa", key)
	}

	t.Esa[key] = &NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa{
		EsaId: EsaId,
		Vm:    Vm,
	}

	return t.Esa[key], nil
}

// RenameEsa renames an entry in the list Esa within
// the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) RenameEsa(oldK, newK NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Key) error {
	if _, ok := t.Esa[newK]; ok {
		return fmt.Errorf("key %v already exists in Esa", newK)
	}

	e, ok := t.Esa[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Esa", oldK)
	}
	e.EsaId = newK.EsaId
	e.Vm = newK.Vm

	t.Esa[newK] = e
	delete(t.Esa, oldK)
	return nil
}

// GetOrCreateEsa retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetOrCreateEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Vm_Union) *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa {

	key := NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	if v, ok := t.Esa[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEsa(EsaId, Vm)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEsa got unexpected error: %v", err))
	}
	return v
}

// GetEsa retrieves the value with the specified key from
// the Esa map field of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Vm_Union) *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa {

	if t == nil {
		return nil
	}

	key := NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	if lm, ok := t.Esa[key]; ok {
		return lm
	}
	return nil
}

// DeleteEsa deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) DeleteEsa(EsaId NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_EsaId_Union, Vm NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Vm_Union) {
	key := NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Key{
		EsaId: EsaId,
		Vm:    Vm,
	}

	delete(t.Esa, key)
}

// AppendEsa appends the supplied NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa struct to the
// list Esa of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) AppendEsa(v *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa) error {
	key := NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Key{
		EsaId: v.EsaId,
		Vm:    v.Vm,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Esa == nil {
		t.Esa = make(map[NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Key]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa)
	}

	if _, ok := t.Esa[key]; ok {
		return fmt.Errorf("duplicate key for list Esa %v", key)
	}

	t.Esa[key] = v
	return nil
}

// NewIom creates a new entry in the Iom list of the
// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) NewIom(SlotNumber NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom_SlotNumber_Union) (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Iom == nil {
		t.Iom = make(map[NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom_SlotNumber_Union]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom)
	}

	key := SlotNumber

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Iom[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Iom", key)
	}

	t.Iom[key] = &NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom{
		SlotNumber: SlotNumber,
	}

	return t.Iom[key], nil
}

// RenameIom renames an entry in the list Iom within
// the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) RenameIom(oldK, newK NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom_SlotNumber_Union) error {
	if _, ok := t.Iom[newK]; ok {
		return fmt.Errorf("key %v already exists in Iom", newK)
	}

	e, ok := t.Iom[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Iom", oldK)
	}
	e.SlotNumber = newK

	t.Iom[newK] = e
	delete(t.Iom, oldK)
	return nil
}

// GetOrCreateIom retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetOrCreateIom(SlotNumber NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom_SlotNumber_Union) *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom {

	key := SlotNumber

	if v, ok := t.Iom[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIom(SlotNumber)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIom got unexpected error: %v", err))
	}
	return v
}

// GetIom retrieves the value with the specified key from
// the Iom map field of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetIom(SlotNumber NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom_SlotNumber_Union) *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom {

	if t == nil {
		return nil
	}

	key := SlotNumber

	if lm, ok := t.Iom[key]; ok {
		return lm
	}
	return nil
}

// DeleteIom deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) DeleteIom(SlotNumber NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom_SlotNumber_Union) {
	key := SlotNumber

	delete(t.Iom, key)
}

// AppendIom appends the supplied NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom struct to the
// list Iom of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) AppendIom(v *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom) error {
	key := v.SlotNumber

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Iom == nil {
		t.Iom = make(map[NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom_SlotNumber_Union]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom)
	}

	if _, ok := t.Iom[key]; ok {
		return fmt.Errorf("duplicate key for list Iom %v", key)
	}

	t.Iom[key] = v
	return nil
}

// NewMda creates a new entry in the Mda list of the
// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) NewMda(MdaId string) (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mda == nil {
		t.Mda = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda)
	}

	key := MdaId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mda[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mda", key)
	}

	t.Mda[key] = &NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda{
		MdaId: &MdaId,
	}

	return t.Mda[key], nil
}

// RenameMda renames an entry in the list Mda within
// the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) RenameMda(oldK, newK string) error {
	if _, ok := t.Mda[newK]; ok {
		return fmt.Errorf("key %v already exists in Mda", newK)
	}

	e, ok := t.Mda[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mda", oldK)
	}
	e.MdaId = &newK

	t.Mda[newK] = e
	delete(t.Mda, oldK)
	return nil
}

// GetOrCreateMda retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetOrCreateMda(MdaId string) *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda {

	key := MdaId

	if v, ok := t.Mda[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMda(MdaId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMda got unexpected error: %v", err))
	}
	return v
}

// GetMda retrieves the value with the specified key from
// the Mda map field of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetMda(MdaId string) *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda {

	if t == nil {
		return nil
	}

	key := MdaId

	if lm, ok := t.Mda[key]; ok {
		return lm
	}
	return nil
}

// DeleteMda deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) DeleteMda(MdaId string) {
	key := MdaId

	delete(t.Mda, key)
}

// AppendMda appends the supplied NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda struct to the
// list Mda of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) AppendMda(v *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda) error {
	if v.MdaId == nil {
		return fmt.Errorf("invalid nil key received for MdaId")
	}

	key := *v.MdaId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mda == nil {
		t.Mda = make(map[string]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda)
	}

	if _, ok := t.Mda[key]; ok {
		return fmt.Errorf("duplicate key for list Mda %v", key)
	}

	t.Mda[key] = v
	return nil
}

// GetOrCreateDistributedSubMgmt retrieves the value of the DistributedSubMgmt field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetOrCreateDistributedSubMgmt() *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt {
	if t.DistributedSubMgmt != nil {
		return t.DistributedSubMgmt
	}
	t.DistributedSubMgmt = &NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt{}
	return t.DistributedSubMgmt
}

// GetOrCreateNat retrieves the value of the Nat field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetOrCreateNat() *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat {
	if t.Nat != nil {
		return t.Nat
	}
	t.Nat = &NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat{}
	return t.Nat
}

// GetOrCreateWatermarks retrieves the value of the Watermarks field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetOrCreateWatermarks() *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks {
	if t.Watermarks != nil {
		return t.Watermarks
	}
	t.Watermarks = &NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks{}
	return t.Watermarks
}

// GetDistributedSubMgmt returns the value of the DistributedSubMgmt struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If the receiver or the field DistributedSubMgmt is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetDistributedSubMgmt() *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt {
	if t != nil && t.DistributedSubMgmt != nil {
		return t.DistributedSubMgmt
	}
	return nil
}

// GetNat returns the value of the Nat struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If the receiver or the field Nat is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetNat() *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat {
	if t != nil && t.Nat != nil {
		return t.Nat
	}
	return nil
}

// GetWatermarks returns the value of the Watermarks struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup. If the receiver or the field Watermarks is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetWatermarks() *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks {
	if t != nil && t.Watermarks != nil {
		return t.Watermarks
	}
	return nil
}

// GetActiveIomLimit retrieves the value of the leaf ActiveIomLimit from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ActiveIomLimit is set, it can
// safely use t.GetActiveIomLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ActiveIomLimit == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetActiveIomLimit() uint32 {
	if t == nil || t.ActiveIomLimit == nil {
		return 0
	}
	return *t.ActiveIomLimit
}

// GetActiveMdaLimit retrieves the value of the leaf ActiveMdaLimit from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ActiveMdaLimit is set, it can
// safely use t.GetActiveMdaLimit() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ActiveMdaLimit == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetActiveMdaLimit() uint32 {
	if t == nil || t.ActiveMdaLimit == nil {
		return 0
	}
	return *t.ActiveMdaLimit
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetId() NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// GetPortPolicy retrieves the value of the leaf PortPolicy from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortPolicy is set, it can
// safely use t.GetPortPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetPortPolicy() string {
	if t == nil || t.PortPolicy == nil {
		return ""
	}
	return *t.PortPolicy
}

// GetRedundancy retrieves the value of the leaf Redundancy from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Redundancy is set, it can
// safely use t.GetRedundancy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Redundancy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetRedundancy() E_NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Redundancy {
	if t == nil || t.Redundancy == 0 {
		return NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Redundancy_iom
	}
	return t.Redundancy
}

// GetScalingProfile retrieves the value of the leaf ScalingProfile from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ScalingProfile is set, it can
// safely use t.GetScalingProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ScalingProfile == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetScalingProfile() E_NokiaTypesSros_IsaScalingProfile {
	if t == nil || t.ScalingProfile == 0 {
		return NokiaTypesSros_IsaScalingProfile_profile1
	}
	return t.ScalingProfile
}

// GetTunnelPortPolicy retrieves the value of the leaf TunnelPortPolicy from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TunnelPortPolicy is set, it can
// safely use t.GetTunnelPortPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TunnelPortPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) GetTunnelPortPolicy() string {
	if t == nil || t.TunnelPortPolicy == nil {
		return ""
	}
	return *t.TunnelPortPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.Redundancy == 0 {
		t.Redundancy = NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Redundancy_iom
	}
	if t.ScalingProfile == 0 {
		t.ScalingProfile = NokiaTypesSros_IsaScalingProfile_profile1
	}
	t.DistributedSubMgmt.PopulateDefaults()
	t.Nat.PopulateDefaults()
	t.Watermarks.PopulateDefaults()
	for _, e := range t.Esa {
		e.PopulateDefaults()
	}
	for _, e := range t.Iom {
		e.PopulateDefaults()
	}
	for _, e := range t.Mda {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt represents the /nokia-conf/configure/groups/group/isa/wlan-gw-group/distributed-sub-mgmt YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt struct {
	IsaAaGroup                  *uint32 `path:"isa-aa-group" module:"nokia-conf"`
	IsaAaOversubscriptionFactor *uint32 `path:"isa-aa-oversubscription-factor" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt) IsYANGGoStruct() {}

// GetIsaAaGroup retrieves the value of the leaf IsaAaGroup from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsaAaGroup is set, it can
// safely use t.GetIsaAaGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsaAaGroup == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt) GetIsaAaGroup() uint32 {
	if t == nil || t.IsaAaGroup == nil {
		return 0
	}
	return *t.IsaAaGroup
}

// GetIsaAaOversubscriptionFactor retrieves the value of the leaf IsaAaOversubscriptionFactor from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IsaAaOversubscriptionFactor is set, it can
// safely use t.GetIsaAaOversubscriptionFactor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IsaAaOversubscriptionFactor == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt) GetIsaAaOversubscriptionFactor() uint32 {
	if t == nil || t.IsaAaOversubscriptionFactor == nil {
		return 1
	}
	return *t.IsaAaOversubscriptionFactor
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.IsaAaOversubscriptionFactor == nil {
		var v uint32 = 1
		t.IsaAaOversubscriptionFactor = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_DistributedSubMgmt) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa represents the /nokia-conf/configure/groups/group/isa/wlan-gw-group/esa YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa struct {
	EsaId NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_EsaId_Union `path:"esa-id" module:"nokia-conf"`
	Vm    NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Vm_Union    `path:"vm" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa) IsYANGGoStruct() {}

// GetEsaId retrieves the value of the leaf EsaId from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EsaId is set, it can
// safely use t.GetEsaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EsaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa) GetEsaId() NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_EsaId_Union {
	if t == nil || t.EsaId == nil {
		return nil
	}
	return t.EsaId
}

// GetVm retrieves the value of the leaf Vm from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vm is set, it can
// safely use t.GetVm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa) GetVm() NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa_Vm_Union {
	if t == nil || t.Vm == nil {
		return nil
	}
	return t.Vm
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"esa-id": t.EsaId,
		"vm":     t.Vm,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Esa) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom represents the /nokia-conf/configure/groups/group/isa/wlan-gw-group/iom YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom struct {
	SlotNumber NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom_SlotNumber_Union `path:"slot-number" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom) IsYANGGoStruct() {}

// GetSlotNumber retrieves the value of the leaf SlotNumber from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SlotNumber is set, it can
// safely use t.GetSlotNumber() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SlotNumber == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom) GetSlotNumber() NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom_SlotNumber_Union {
	if t == nil || t.SlotNumber == nil {
		return nil
	}
	return t.SlotNumber
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"slot-number": t.SlotNumber,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Iom) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda represents the /nokia-conf/configure/groups/group/isa/wlan-gw-group/mda YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda struct {
	MdaId *string `path:"mda-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda) IsYANGGoStruct() {}

// GetMdaId retrieves the value of the leaf MdaId from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MdaId is set, it can
// safely use t.GetMdaId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MdaId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda) GetMdaId() string {
	if t == nil || t.MdaId == nil {
		return ""
	}
	return *t.MdaId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MdaId == nil {
		return nil, fmt.Errorf("nil value for key MdaId")
	}

	return map[string]interface{}{
		"mda-id": *t.MdaId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Mda) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat represents the /nokia-conf/configure/groups/group/isa/wlan-gw-group/nat YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat struct {
	Log                    *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log           `path:"log" module:"nokia-conf"`
	Lsn                    *bool                                                               `path:"lsn" module:"nokia-conf"`
	RadiusAccountingPolicy *string                                                             `path:"radius-accounting-policy" module:"nokia-conf"`
	SessionLimits          *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits `path:"session-limits" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat) IsYANGGoStruct() {}

// GetOrCreateLog retrieves the value of the Log field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat) GetOrCreateLog() *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log {
	if t.Log != nil {
		return t.Log
	}
	t.Log = &NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log{}
	return t.Log
}

// GetOrCreateSessionLimits retrieves the value of the SessionLimits field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat) GetOrCreateSessionLimits() *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits {
	if t.SessionLimits != nil {
		return t.SessionLimits
	}
	t.SessionLimits = &NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits{}
	return t.SessionLimits
}

// GetLog returns the value of the Log struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat. If the receiver or the field Log is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat) GetLog() *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log {
	if t != nil && t.Log != nil {
		return t.Log
	}
	return nil
}

// GetSessionLimits returns the value of the SessionLimits struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat. If the receiver or the field SessionLimits is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat) GetSessionLimits() *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits {
	if t != nil && t.SessionLimits != nil {
		return t.SessionLimits
	}
	return nil
}

// GetLsn retrieves the value of the leaf Lsn from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Lsn is set, it can
// safely use t.GetLsn() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Lsn == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat) GetLsn() bool {
	if t == nil || t.Lsn == nil {
		return true
	}
	return *t.Lsn
}

// GetRadiusAccountingPolicy retrieves the value of the leaf RadiusAccountingPolicy from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RadiusAccountingPolicy is set, it can
// safely use t.GetRadiusAccountingPolicy() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RadiusAccountingPolicy == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat) GetRadiusAccountingPolicy() string {
	if t == nil || t.RadiusAccountingPolicy == nil {
		return ""
	}
	return *t.RadiusAccountingPolicy
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Lsn == nil {
		var v bool = true
		t.Lsn = &v
	}
	t.Log.PopulateDefaults()
	t.SessionLimits.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log represents the /nokia-conf/configure/groups/group/isa/wlan-gw-group/nat/log YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log struct {
	SuppressLsnEvents        *bool `path:"suppress-lsn-events" module:"nokia-conf"`
	SuppressLsnSubBlocksFree *bool `path:"suppress-lsn-sub-blocks-free" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log) IsYANGGoStruct() {}

// GetSuppressLsnEvents retrieves the value of the leaf SuppressLsnEvents from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SuppressLsnEvents is set, it can
// safely use t.GetSuppressLsnEvents() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SuppressLsnEvents == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log) GetSuppressLsnEvents() bool {
	if t == nil || t.SuppressLsnEvents == nil {
		return true
	}
	return *t.SuppressLsnEvents
}

// GetSuppressLsnSubBlocksFree retrieves the value of the leaf SuppressLsnSubBlocksFree from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SuppressLsnSubBlocksFree is set, it can
// safely use t.GetSuppressLsnSubBlocksFree() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SuppressLsnSubBlocksFree == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log) GetSuppressLsnSubBlocksFree() bool {
	if t == nil || t.SuppressLsnSubBlocksFree == nil {
		return false
	}
	return *t.SuppressLsnSubBlocksFree
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SuppressLsnEvents == nil {
		var v bool = true
		t.SuppressLsnEvents = &v
	}
	if t.SuppressLsnSubBlocksFree == nil {
		var v bool = false
		t.SuppressLsnSubBlocksFree = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_Log) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits represents the /nokia-conf/configure/groups/group/isa/wlan-gw-group/nat/session-limits YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits struct {
	Reserved     *uint32                                                                        `path:"reserved" module:"nokia-conf"`
	UpnpMappings *uint32                                                                        `path:"upnp-mappings" module:"nokia-conf"`
	Watermarks   *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks `path:"watermarks" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits) IsYANGGoStruct() {}

// GetOrCreateWatermarks retrieves the value of the Watermarks field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits) GetOrCreateWatermarks() *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks {
	if t.Watermarks != nil {
		return t.Watermarks
	}
	t.Watermarks = &NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks{}
	return t.Watermarks
}

// GetWatermarks returns the value of the Watermarks struct pointer
// from NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits. If the receiver or the field Watermarks is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits) GetWatermarks() *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks {
	if t != nil && t.Watermarks != nil {
		return t.Watermarks
	}
	return nil
}

// GetReserved retrieves the value of the leaf Reserved from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Reserved is set, it can
// safely use t.GetReserved() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Reserved == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits) GetReserved() uint32 {
	if t == nil || t.Reserved == nil {
		return 0
	}
	return *t.Reserved
}

// GetUpnpMappings retrieves the value of the leaf UpnpMappings from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UpnpMappings is set, it can
// safely use t.GetUpnpMappings() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UpnpMappings == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits) GetUpnpMappings() uint32 {
	if t == nil || t.UpnpMappings == nil {
		return 524288
	}
	return *t.UpnpMappings
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.UpnpMappings == nil {
		var v uint32 = 524288
		t.UpnpMappings = &v
	}
	t.Watermarks.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks represents the /nokia-conf/configure/groups/group/isa/wlan-gw-group/nat/session-limits/watermarks YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks struct {
	High *uint32 `path:"high" module:"nokia-conf"`
	Low  *uint32 `path:"low" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks) IsYANGGoStruct() {
}

// GetHigh retrieves the value of the leaf High from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if High is set, it can
// safely use t.GetHigh() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.High == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks) GetHigh() uint32 {
	if t == nil || t.High == nil {
		return 0
	}
	return *t.High
}

// GetLow retrieves the value of the leaf Low from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Low is set, it can
// safely use t.GetLow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Low == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks) GetLow() uint32 {
	if t == nil || t.Low == nil {
		return 0
	}
	return *t.Low
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Nat_SessionLimits_Watermarks) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks represents the /nokia-conf/configure/groups/group/isa/wlan-gw-group/watermarks YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks struct {
	Mark map[NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark_Entity_Union]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark `path:"mark" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks) IsYANGGoStruct() {}

// NewMark creates a new entry in the Mark list of the
// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks) NewMark(Entity NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark_Entity_Union) (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mark == nil {
		t.Mark = make(map[NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark_Entity_Union]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark)
	}

	key := Entity

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mark[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mark", key)
	}

	t.Mark[key] = &NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark{
		Entity: Entity,
	}

	return t.Mark[key], nil
}

// RenameMark renames an entry in the list Mark within
// the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks) RenameMark(oldK, newK NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark_Entity_Union) error {
	if _, ok := t.Mark[newK]; ok {
		return fmt.Errorf("key %v already exists in Mark", newK)
	}

	e, ok := t.Mark[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mark", oldK)
	}
	e.Entity = newK

	t.Mark[newK] = e
	delete(t.Mark, oldK)
	return nil
}

// GetOrCreateMark retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks) GetOrCreateMark(Entity NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark_Entity_Union) *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark {

	key := Entity

	if v, ok := t.Mark[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMark(Entity)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMark got unexpected error: %v", err))
	}
	return v
}

// GetMark retrieves the value with the specified key from
// the Mark map field of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks) GetMark(Entity NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark_Entity_Union) *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark {

	if t == nil {
		return nil
	}

	key := Entity

	if lm, ok := t.Mark[key]; ok {
		return lm
	}
	return nil
}

// DeleteMark deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks) DeleteMark(Entity NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark_Entity_Union) {
	key := Entity

	delete(t.Mark, key)
}

// AppendMark appends the supplied NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark struct to the
// list Mark of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks) AppendMark(v *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark) error {
	key := v.Entity

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mark == nil {
		t.Mark = make(map[NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark_Entity_Union]*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark)
	}

	if _, ok := t.Mark[key]; ok {
		return fmt.Errorf("duplicate key for list Mark %v", key)
	}

	t.Mark[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Mark {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark represents the /nokia-conf/configure/groups/group/isa/wlan-gw-group/watermarks/mark YANG schema element.
type NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark struct {
	Entity NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark_Entity_Union `path:"entity" module:"nokia-conf"`
	High   *uint32                                                                       `path:"high" module:"nokia-conf"`
	Low    *uint32                                                                       `path:"low" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark) IsYANGGoStruct() {}

// GetEntity retrieves the value of the leaf Entity from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Entity is set, it can
// safely use t.GetEntity() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Entity == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark) GetEntity() NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark_Entity_Union {
	if t == nil || t.Entity == nil {
		return nil
	}
	return t.Entity
}

// GetHigh retrieves the value of the leaf High from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if High is set, it can
// safely use t.GetHigh() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.High == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark) GetHigh() uint32 {
	if t == nil || t.High == nil {
		return 0
	}
	return *t.High
}

// GetLow retrieves the value of the leaf Low from the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Low is set, it can
// safely use t.GetLow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Low == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark) GetLow() uint32 {
	if t == nil || t.Low == nil {
		return 0
	}
	return *t.Low
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"entity": t.Entity,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark.
func (*NokiaConf_Configure_Groups_Group_Isa_WlanGwGroup_Watermarks_Mark) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag represents the /nokia-conf/configure/groups/group/lag YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag struct {
	Access                *NokiaConf_Configure_Groups_Group_Lag_Access                                                                                        `path:"access" module:"nokia-conf"`
	AdaptiveLoadBalancing *NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing                                                                         `path:"adaptive-load-balancing" module:"nokia-conf" yangPresence:"true"`
	AdminState            E_NokiaTypesSros_AdminState                                                                                                         `path:"admin-state" module:"nokia-conf"`
	BfdLiveness           *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness                                                                                   `path:"bfd-liveness" module:"nokia-conf"`
	Description           *string                                                                                                                             `path:"description" module:"nokia-conf"`
	DynamicCost           *bool                                                                                                                               `path:"dynamic-cost" module:"nokia-conf"`
	EncapType             E_NokiaConf_Configure_Groups_Group_Lag_EncapType                                                                                    `path:"encap-type" module:"nokia-conf"`
	EthCfm                *NokiaConf_Configure_Groups_Group_Lag_EthCfm                                                                                        `path:"eth-cfm" module:"nokia-conf"`
	HashWeightThreshold   *NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold                                                                           `path:"hash-weight-threshold" module:"nokia-conf"`
	HoldTimeDown          *uint32                                                                                                                             `path:"hold-time-down" module:"nokia-conf"`
	Lacp                  *NokiaConf_Configure_Groups_Group_Lag_Lacp                                                                                          `path:"lacp" module:"nokia-conf" yangPresence:"true"`
	LacpMuxControl        E_NokiaConf_Configure_Groups_Group_Lag_LacpMuxControl                                                                               `path:"lacp-mux-control" module:"nokia-conf"`
	LacpXmitInterval      E_NokiaConf_Configure_Groups_Group_Lag_LacpXmitInterval                                                                             `path:"lacp-xmit-interval" module:"nokia-conf"`
	LacpXmitStdby         *bool                                                                                                                               `path:"lacp-xmit-stdby" module:"nokia-conf"`
	LagBundlePool         *uint32                                                                                                                             `path:"lag-bundle-pool" module:"nokia-conf"`
	LagName               *string                                                                                                                             `path:"lag-name" module:"nokia-conf"`
	LinkMapProfile        map[NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_LinkMapProfileId_Union]*NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile `path:"link-map-profile" module:"nokia-conf"`
	MacAddress            *string                                                                                                                             `path:"mac-address" module:"nokia-conf"`
	MaxPorts              *uint32                                                                                                                             `path:"max-ports" module:"nokia-conf"`
	Mode                  E_NokiaTypesPort_Mode                                                                                                               `path:"mode" module:"nokia-conf"`
	MonitorOperGroup      *string                                                                                                                             `path:"monitor-oper-group" module:"nokia-conf"`
	PerLinkHash           *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash                                                                                   `path:"per-link-hash" module:"nokia-conf" yangPresence:"true"`
	Port                  map[string]*NokiaConf_Configure_Groups_Group_Lag_Port                                                                               `path:"port" module:"nokia-conf"`
	PortThreshold         *NokiaConf_Configure_Groups_Group_Lag_PortThreshold                                                                                 `path:"port-threshold" module:"nokia-conf"`
	PortType              E_NokiaConf_Configure_Groups_Group_Lag_PortType                                                                                     `path:"port-type" module:"nokia-conf"`
	PortWeightSpeed       *uint32                                                                                                                             `path:"port-weight-speed" module:"nokia-conf"`
	Scheduler             *NokiaConf_Configure_Groups_Group_Lag_Scheduler                                                                                     `path:"scheduler" module:"nokia-conf" yangPresence:"true"`
	SelectionCriteria     *NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria                                                                             `path:"selection-criteria" module:"nokia-conf"`
	StandbySignaling      E_NokiaConf_Configure_Groups_Group_Lag_StandbySignaling                                                                             `path:"standby-signaling" module:"nokia-conf"`
	WeightThreshold       *NokiaConf_Configure_Groups_Group_Lag_WeightThreshold                                                                               `path:"weight-threshold" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag) IsYANGGoStruct() {}

// NewLinkMapProfile creates a new entry in the LinkMapProfile list of the
// NokiaConf_Configure_Groups_Group_Lag struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Lag) NewLinkMapProfile(LinkMapProfileId NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_LinkMapProfileId_Union) (*NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LinkMapProfile == nil {
		t.LinkMapProfile = make(map[NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_LinkMapProfileId_Union]*NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile)
	}

	key := LinkMapProfileId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LinkMapProfile[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LinkMapProfile", key)
	}

	t.LinkMapProfile[key] = &NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile{
		LinkMapProfileId: LinkMapProfileId,
	}

	return t.LinkMapProfile[key], nil
}

// RenameLinkMapProfile renames an entry in the list LinkMapProfile within
// the NokiaConf_Configure_Groups_Group_Lag struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Lag) RenameLinkMapProfile(oldK, newK NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_LinkMapProfileId_Union) error {
	if _, ok := t.LinkMapProfile[newK]; ok {
		return fmt.Errorf("key %v already exists in LinkMapProfile", newK)
	}

	e, ok := t.LinkMapProfile[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LinkMapProfile", oldK)
	}
	e.LinkMapProfileId = newK

	t.LinkMapProfile[newK] = e
	delete(t.LinkMapProfile, oldK)
	return nil
}

// GetOrCreateLinkMapProfile retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Lag. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreateLinkMapProfile(LinkMapProfileId NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_LinkMapProfileId_Union) *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile {

	key := LinkMapProfileId

	if v, ok := t.LinkMapProfile[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLinkMapProfile(LinkMapProfileId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLinkMapProfile got unexpected error: %v", err))
	}
	return v
}

// GetLinkMapProfile retrieves the value with the specified key from
// the LinkMapProfile map field of NokiaConf_Configure_Groups_Group_Lag. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetLinkMapProfile(LinkMapProfileId NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_LinkMapProfileId_Union) *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile {

	if t == nil {
		return nil
	}

	key := LinkMapProfileId

	if lm, ok := t.LinkMapProfile[key]; ok {
		return lm
	}
	return nil
}

// DeleteLinkMapProfile deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Lag. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Lag) DeleteLinkMapProfile(LinkMapProfileId NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_LinkMapProfileId_Union) {
	key := LinkMapProfileId

	delete(t.LinkMapProfile, key)
}

// AppendLinkMapProfile appends the supplied NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile struct to the
// list LinkMapProfile of NokiaConf_Configure_Groups_Group_Lag. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Lag) AppendLinkMapProfile(v *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) error {
	key := v.LinkMapProfileId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LinkMapProfile == nil {
		t.LinkMapProfile = make(map[NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_LinkMapProfileId_Union]*NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile)
	}

	if _, ok := t.LinkMapProfile[key]; ok {
		return fmt.Errorf("duplicate key for list LinkMapProfile %v", key)
	}

	t.LinkMapProfile[key] = v
	return nil
}

// NewPort creates a new entry in the Port list of the
// NokiaConf_Configure_Groups_Group_Lag struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Lag) NewPort(PortId string) (*NokiaConf_Configure_Groups_Group_Lag_Port, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Port == nil {
		t.Port = make(map[string]*NokiaConf_Configure_Groups_Group_Lag_Port)
	}

	key := PortId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Port[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Port", key)
	}

	t.Port[key] = &NokiaConf_Configure_Groups_Group_Lag_Port{
		PortId: &PortId,
	}

	return t.Port[key], nil
}

// RenamePort renames an entry in the list Port within
// the NokiaConf_Configure_Groups_Group_Lag struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Lag) RenamePort(oldK, newK string) error {
	if _, ok := t.Port[newK]; ok {
		return fmt.Errorf("key %v already exists in Port", newK)
	}

	e, ok := t.Port[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Port", oldK)
	}
	e.PortId = &newK

	t.Port[newK] = e
	delete(t.Port, oldK)
	return nil
}

// GetOrCreatePort retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Lag. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreatePort(PortId string) *NokiaConf_Configure_Groups_Group_Lag_Port {

	key := PortId

	if v, ok := t.Port[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPort(PortId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePort got unexpected error: %v", err))
	}
	return v
}

// GetPort retrieves the value with the specified key from
// the Port map field of NokiaConf_Configure_Groups_Group_Lag. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetPort(PortId string) *NokiaConf_Configure_Groups_Group_Lag_Port {

	if t == nil {
		return nil
	}

	key := PortId

	if lm, ok := t.Port[key]; ok {
		return lm
	}
	return nil
}

// DeletePort deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Lag. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Lag) DeletePort(PortId string) {
	key := PortId

	delete(t.Port, key)
}

// AppendPort appends the supplied NokiaConf_Configure_Groups_Group_Lag_Port struct to the
// list Port of NokiaConf_Configure_Groups_Group_Lag. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Lag_Port already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Lag) AppendPort(v *NokiaConf_Configure_Groups_Group_Lag_Port) error {
	if v.PortId == nil {
		return fmt.Errorf("invalid nil key received for PortId")
	}

	key := *v.PortId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Port == nil {
		t.Port = make(map[string]*NokiaConf_Configure_Groups_Group_Lag_Port)
	}

	if _, ok := t.Port[key]; ok {
		return fmt.Errorf("duplicate key for list Port %v", key)
	}

	t.Port[key] = v
	return nil
}

// GetOrCreateAccess retrieves the value of the Access field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreateAccess() *NokiaConf_Configure_Groups_Group_Lag_Access {
	if t.Access != nil {
		return t.Access
	}
	t.Access = &NokiaConf_Configure_Groups_Group_Lag_Access{}
	return t.Access
}

// GetOrCreateAdaptiveLoadBalancing retrieves the value of the AdaptiveLoadBalancing field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreateAdaptiveLoadBalancing() *NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing {
	if t.AdaptiveLoadBalancing != nil {
		return t.AdaptiveLoadBalancing
	}
	t.AdaptiveLoadBalancing = &NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing{}
	return t.AdaptiveLoadBalancing
}

// GetOrCreateBfdLiveness retrieves the value of the BfdLiveness field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreateBfdLiveness() *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness {
	if t.BfdLiveness != nil {
		return t.BfdLiveness
	}
	t.BfdLiveness = &NokiaConf_Configure_Groups_Group_Lag_BfdLiveness{}
	return t.BfdLiveness
}

// GetOrCreateEthCfm retrieves the value of the EthCfm field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreateEthCfm() *NokiaConf_Configure_Groups_Group_Lag_EthCfm {
	if t.EthCfm != nil {
		return t.EthCfm
	}
	t.EthCfm = &NokiaConf_Configure_Groups_Group_Lag_EthCfm{}
	return t.EthCfm
}

// GetOrCreateHashWeightThreshold retrieves the value of the HashWeightThreshold field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreateHashWeightThreshold() *NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold {
	if t.HashWeightThreshold != nil {
		return t.HashWeightThreshold
	}
	t.HashWeightThreshold = &NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold{}
	return t.HashWeightThreshold
}

// GetOrCreateLacp retrieves the value of the Lacp field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreateLacp() *NokiaConf_Configure_Groups_Group_Lag_Lacp {
	if t.Lacp != nil {
		return t.Lacp
	}
	t.Lacp = &NokiaConf_Configure_Groups_Group_Lag_Lacp{}
	return t.Lacp
}

// GetOrCreatePerLinkHash retrieves the value of the PerLinkHash field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreatePerLinkHash() *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash {
	if t.PerLinkHash != nil {
		return t.PerLinkHash
	}
	t.PerLinkHash = &NokiaConf_Configure_Groups_Group_Lag_PerLinkHash{}
	return t.PerLinkHash
}

// GetOrCreatePortThreshold retrieves the value of the PortThreshold field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreatePortThreshold() *NokiaConf_Configure_Groups_Group_Lag_PortThreshold {
	if t.PortThreshold != nil {
		return t.PortThreshold
	}
	t.PortThreshold = &NokiaConf_Configure_Groups_Group_Lag_PortThreshold{}
	return t.PortThreshold
}

// GetOrCreateScheduler retrieves the value of the Scheduler field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreateScheduler() *NokiaConf_Configure_Groups_Group_Lag_Scheduler {
	if t.Scheduler != nil {
		return t.Scheduler
	}
	t.Scheduler = &NokiaConf_Configure_Groups_Group_Lag_Scheduler{}
	return t.Scheduler
}

// GetOrCreateSelectionCriteria retrieves the value of the SelectionCriteria field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreateSelectionCriteria() *NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria {
	if t.SelectionCriteria != nil {
		return t.SelectionCriteria
	}
	t.SelectionCriteria = &NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria{}
	return t.SelectionCriteria
}

// GetOrCreateWeightThreshold retrieves the value of the WeightThreshold field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetOrCreateWeightThreshold() *NokiaConf_Configure_Groups_Group_Lag_WeightThreshold {
	if t.WeightThreshold != nil {
		return t.WeightThreshold
	}
	t.WeightThreshold = &NokiaConf_Configure_Groups_Group_Lag_WeightThreshold{}
	return t.WeightThreshold
}

// GetAccess returns the value of the Access struct pointer
// from NokiaConf_Configure_Groups_Group_Lag. If the receiver or the field Access is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetAccess() *NokiaConf_Configure_Groups_Group_Lag_Access {
	if t != nil && t.Access != nil {
		return t.Access
	}
	return nil
}

// GetAdaptiveLoadBalancing returns the value of the AdaptiveLoadBalancing struct pointer
// from NokiaConf_Configure_Groups_Group_Lag. If the receiver or the field AdaptiveLoadBalancing is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetAdaptiveLoadBalancing() *NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing {
	if t != nil && t.AdaptiveLoadBalancing != nil {
		return t.AdaptiveLoadBalancing
	}
	return nil
}

// GetBfdLiveness returns the value of the BfdLiveness struct pointer
// from NokiaConf_Configure_Groups_Group_Lag. If the receiver or the field BfdLiveness is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetBfdLiveness() *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness {
	if t != nil && t.BfdLiveness != nil {
		return t.BfdLiveness
	}
	return nil
}

// GetEthCfm returns the value of the EthCfm struct pointer
// from NokiaConf_Configure_Groups_Group_Lag. If the receiver or the field EthCfm is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetEthCfm() *NokiaConf_Configure_Groups_Group_Lag_EthCfm {
	if t != nil && t.EthCfm != nil {
		return t.EthCfm
	}
	return nil
}

// GetHashWeightThreshold returns the value of the HashWeightThreshold struct pointer
// from NokiaConf_Configure_Groups_Group_Lag. If the receiver or the field HashWeightThreshold is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetHashWeightThreshold() *NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold {
	if t != nil && t.HashWeightThreshold != nil {
		return t.HashWeightThreshold
	}
	return nil
}

// GetLacp returns the value of the Lacp struct pointer
// from NokiaConf_Configure_Groups_Group_Lag. If the receiver or the field Lacp is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetLacp() *NokiaConf_Configure_Groups_Group_Lag_Lacp {
	if t != nil && t.Lacp != nil {
		return t.Lacp
	}
	return nil
}

// GetPerLinkHash returns the value of the PerLinkHash struct pointer
// from NokiaConf_Configure_Groups_Group_Lag. If the receiver or the field PerLinkHash is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetPerLinkHash() *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash {
	if t != nil && t.PerLinkHash != nil {
		return t.PerLinkHash
	}
	return nil
}

// GetPortThreshold returns the value of the PortThreshold struct pointer
// from NokiaConf_Configure_Groups_Group_Lag. If the receiver or the field PortThreshold is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetPortThreshold() *NokiaConf_Configure_Groups_Group_Lag_PortThreshold {
	if t != nil && t.PortThreshold != nil {
		return t.PortThreshold
	}
	return nil
}

// GetScheduler returns the value of the Scheduler struct pointer
// from NokiaConf_Configure_Groups_Group_Lag. If the receiver or the field Scheduler is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetScheduler() *NokiaConf_Configure_Groups_Group_Lag_Scheduler {
	if t != nil && t.Scheduler != nil {
		return t.Scheduler
	}
	return nil
}

// GetSelectionCriteria returns the value of the SelectionCriteria struct pointer
// from NokiaConf_Configure_Groups_Group_Lag. If the receiver or the field SelectionCriteria is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetSelectionCriteria() *NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria {
	if t != nil && t.SelectionCriteria != nil {
		return t.SelectionCriteria
	}
	return nil
}

// GetWeightThreshold returns the value of the WeightThreshold struct pointer
// from NokiaConf_Configure_Groups_Group_Lag. If the receiver or the field WeightThreshold is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetWeightThreshold() *NokiaConf_Configure_Groups_Group_Lag_WeightThreshold {
	if t != nil && t.WeightThreshold != nil {
		return t.WeightThreshold
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetDynamicCost retrieves the value of the leaf DynamicCost from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if DynamicCost is set, it can
// safely use t.GetDynamicCost() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.DynamicCost == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetDynamicCost() bool {
	if t == nil || t.DynamicCost == nil {
		return false
	}
	return *t.DynamicCost
}

// GetEncapType retrieves the value of the leaf EncapType from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EncapType is set, it can
// safely use t.GetEncapType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EncapType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetEncapType() E_NokiaConf_Configure_Groups_Group_Lag_EncapType {
	if t == nil || t.EncapType == 0 {
		return 0
	}
	return t.EncapType
}

// GetHoldTimeDown retrieves the value of the leaf HoldTimeDown from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HoldTimeDown is set, it can
// safely use t.GetHoldTimeDown() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HoldTimeDown == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetHoldTimeDown() uint32 {
	if t == nil || t.HoldTimeDown == nil {
		return 0
	}
	return *t.HoldTimeDown
}

// GetLacpMuxControl retrieves the value of the leaf LacpMuxControl from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpMuxControl is set, it can
// safely use t.GetLacpMuxControl() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpMuxControl == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetLacpMuxControl() E_NokiaConf_Configure_Groups_Group_Lag_LacpMuxControl {
	if t == nil || t.LacpMuxControl == 0 {
		return NokiaConf_Configure_Groups_Group_Lag_LacpMuxControl_coupled
	}
	return t.LacpMuxControl
}

// GetLacpXmitInterval retrieves the value of the leaf LacpXmitInterval from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpXmitInterval is set, it can
// safely use t.GetLacpXmitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpXmitInterval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetLacpXmitInterval() E_NokiaConf_Configure_Groups_Group_Lag_LacpXmitInterval {
	if t == nil || t.LacpXmitInterval == 0 {
		return NokiaConf_Configure_Groups_Group_Lag_LacpXmitInterval_fast
	}
	return t.LacpXmitInterval
}

// GetLacpXmitStdby retrieves the value of the leaf LacpXmitStdby from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LacpXmitStdby is set, it can
// safely use t.GetLacpXmitStdby() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LacpXmitStdby == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetLacpXmitStdby() bool {
	if t == nil || t.LacpXmitStdby == nil {
		return true
	}
	return *t.LacpXmitStdby
}

// GetLagBundlePool retrieves the value of the leaf LagBundlePool from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LagBundlePool is set, it can
// safely use t.GetLagBundlePool() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LagBundlePool == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetLagBundlePool() uint32 {
	if t == nil || t.LagBundlePool == nil {
		return 1
	}
	return *t.LagBundlePool
}

// GetLagName retrieves the value of the leaf LagName from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LagName is set, it can
// safely use t.GetLagName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LagName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetLagName() string {
	if t == nil || t.LagName == nil {
		return ""
	}
	return *t.LagName
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return "00:00:00:00:00:00"
	}
	return *t.MacAddress
}

// GetMaxPorts retrieves the value of the leaf MaxPorts from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxPorts is set, it can
// safely use t.GetMaxPorts() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxPorts == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetMaxPorts() uint32 {
	if t == nil || t.MaxPorts == nil {
		return 32
	}
	return *t.MaxPorts
}

// GetMode retrieves the value of the leaf Mode from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetMode() E_NokiaTypesPort_Mode {
	if t == nil || t.Mode == 0 {
		return NokiaTypesPort_Mode_network
	}
	return t.Mode
}

// GetMonitorOperGroup retrieves the value of the leaf MonitorOperGroup from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MonitorOperGroup is set, it can
// safely use t.GetMonitorOperGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MonitorOperGroup == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetMonitorOperGroup() string {
	if t == nil || t.MonitorOperGroup == nil {
		return ""
	}
	return *t.MonitorOperGroup
}

// GetPortType retrieves the value of the leaf PortType from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortType is set, it can
// safely use t.GetPortType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetPortType() E_NokiaConf_Configure_Groups_Group_Lag_PortType {
	if t == nil || t.PortType == 0 {
		return NokiaConf_Configure_Groups_Group_Lag_PortType_standard
	}
	return t.PortType
}

// GetPortWeightSpeed retrieves the value of the leaf PortWeightSpeed from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortWeightSpeed is set, it can
// safely use t.GetPortWeightSpeed() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortWeightSpeed == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetPortWeightSpeed() uint32 {
	if t == nil || t.PortWeightSpeed == nil {
		return 0
	}
	return *t.PortWeightSpeed
}

// GetStandbySignaling retrieves the value of the leaf StandbySignaling from the NokiaConf_Configure_Groups_Group_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if StandbySignaling is set, it can
// safely use t.GetStandbySignaling() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.StandbySignaling == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag) GetStandbySignaling() E_NokiaConf_Configure_Groups_Group_Lag_StandbySignaling {
	if t == nil || t.StandbySignaling == 0 {
		return NokiaConf_Configure_Groups_Group_Lag_StandbySignaling_lacp
	}
	return t.StandbySignaling
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.DynamicCost == nil {
		var v bool = false
		t.DynamicCost = &v
	}
	if t.LacpMuxControl == 0 {
		t.LacpMuxControl = NokiaConf_Configure_Groups_Group_Lag_LacpMuxControl_coupled
	}
	if t.LacpXmitInterval == 0 {
		t.LacpXmitInterval = NokiaConf_Configure_Groups_Group_Lag_LacpXmitInterval_fast
	}
	if t.LacpXmitStdby == nil {
		var v bool = true
		t.LacpXmitStdby = &v
	}
	if t.LagBundlePool == nil {
		var v uint32 = 1
		t.LagBundlePool = &v
	}
	if t.MacAddress == nil {
		var v string = "00:00:00:00:00:00"
		t.MacAddress = &v
	}
	if t.MaxPorts == nil {
		var v uint32 = 32
		t.MaxPorts = &v
	}
	if t.Mode == 0 {
		t.Mode = NokiaTypesPort_Mode_network
	}
	if t.PortType == 0 {
		t.PortType = NokiaConf_Configure_Groups_Group_Lag_PortType_standard
	}
	if t.StandbySignaling == 0 {
		t.StandbySignaling = NokiaConf_Configure_Groups_Group_Lag_StandbySignaling_lacp
	}
	t.Access.PopulateDefaults()
	t.AdaptiveLoadBalancing.PopulateDefaults()
	t.BfdLiveness.PopulateDefaults()
	t.EthCfm.PopulateDefaults()
	t.HashWeightThreshold.PopulateDefaults()
	t.Lacp.PopulateDefaults()
	t.PerLinkHash.PopulateDefaults()
	t.PortThreshold.PopulateDefaults()
	t.Scheduler.PopulateDefaults()
	t.SelectionCriteria.PopulateDefaults()
	t.WeightThreshold.PopulateDefaults()
	for _, e := range t.LinkMapProfile {
		e.PopulateDefaults()
	}
	for _, e := range t.Port {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Lag struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Lag) ΛListKeyMap() (map[string]interface{}, error) {
	if t.LagName == nil {
		return nil, fmt.Errorf("nil value for key LagName")
	}

	return map[string]interface{}{
		"lag-name": *t.LagName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag.
func (*NokiaConf_Configure_Groups_Group_Lag) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_Access represents the /nokia-conf/configure/groups/group/lag/access YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_Access struct {
	AdaptQos         *NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos `path:"adapt-qos" module:"nokia-conf"`
	Bandwidth        *uint64                                               `path:"bandwidth" module:"nokia-conf"`
	BookingFactor    *uint32                                               `path:"booking-factor" module:"nokia-conf"`
	PerFpEgrQueuing  *bool                                                 `path:"per-fp-egr-queuing" module:"nokia-conf"`
	PerFpIngQueuing  *bool                                                 `path:"per-fp-ing-queuing" module:"nokia-conf"`
	PerFpSapInstance *bool                                                 `path:"per-fp-sap-instance" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_Access implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_Access) IsYANGGoStruct() {}

// GetOrCreateAdaptQos retrieves the value of the AdaptQos field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access) GetOrCreateAdaptQos() *NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos {
	if t.AdaptQos != nil {
		return t.AdaptQos
	}
	t.AdaptQos = &NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos{}
	return t.AdaptQos
}

// GetAdaptQos returns the value of the AdaptQos struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_Access. If the receiver or the field AdaptQos is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access) GetAdaptQos() *NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos {
	if t != nil && t.AdaptQos != nil {
		return t.AdaptQos
	}
	return nil
}

// GetBandwidth retrieves the value of the leaf Bandwidth from the NokiaConf_Configure_Groups_Group_Lag_Access
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Bandwidth is set, it can
// safely use t.GetBandwidth() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Bandwidth == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access) GetBandwidth() uint64 {
	if t == nil || t.Bandwidth == nil {
		return 0
	}
	return *t.Bandwidth
}

// GetBookingFactor retrieves the value of the leaf BookingFactor from the NokiaConf_Configure_Groups_Group_Lag_Access
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BookingFactor is set, it can
// safely use t.GetBookingFactor() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BookingFactor == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access) GetBookingFactor() uint32 {
	if t == nil || t.BookingFactor == nil {
		return 100
	}
	return *t.BookingFactor
}

// GetPerFpEgrQueuing retrieves the value of the leaf PerFpEgrQueuing from the NokiaConf_Configure_Groups_Group_Lag_Access
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PerFpEgrQueuing is set, it can
// safely use t.GetPerFpEgrQueuing() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PerFpEgrQueuing == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access) GetPerFpEgrQueuing() bool {
	if t == nil || t.PerFpEgrQueuing == nil {
		return false
	}
	return *t.PerFpEgrQueuing
}

// GetPerFpIngQueuing retrieves the value of the leaf PerFpIngQueuing from the NokiaConf_Configure_Groups_Group_Lag_Access
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PerFpIngQueuing is set, it can
// safely use t.GetPerFpIngQueuing() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PerFpIngQueuing == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access) GetPerFpIngQueuing() bool {
	if t == nil || t.PerFpIngQueuing == nil {
		return false
	}
	return *t.PerFpIngQueuing
}

// GetPerFpSapInstance retrieves the value of the leaf PerFpSapInstance from the NokiaConf_Configure_Groups_Group_Lag_Access
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PerFpSapInstance is set, it can
// safely use t.GetPerFpSapInstance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PerFpSapInstance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access) GetPerFpSapInstance() bool {
	if t == nil || t.PerFpSapInstance == nil {
		return false
	}
	return *t.PerFpSapInstance
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_Access
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.BookingFactor == nil {
		var v uint32 = 100
		t.BookingFactor = &v
	}
	if t.PerFpEgrQueuing == nil {
		var v bool = false
		t.PerFpEgrQueuing = &v
	}
	if t.PerFpIngQueuing == nil {
		var v bool = false
		t.PerFpIngQueuing = &v
	}
	if t.PerFpSapInstance == nil {
		var v bool = false
		t.PerFpSapInstance = &v
	}
	t.AdaptQos.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_Access"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_Access.
func (*NokiaConf_Configure_Groups_Group_Lag_Access) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos represents the /nokia-conf/configure/groups/group/lag/access/adapt-qos YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos struct {
	IncludeEgrHashCfg *bool                                                       `path:"include-egr-hash-cfg" module:"nokia-conf"`
	Mode              E_NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos_Mode `path:"mode" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos) IsYANGGoStruct() {}

// GetIncludeEgrHashCfg retrieves the value of the leaf IncludeEgrHashCfg from the NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeEgrHashCfg is set, it can
// safely use t.GetIncludeEgrHashCfg() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeEgrHashCfg == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos) GetIncludeEgrHashCfg() bool {
	if t == nil || t.IncludeEgrHashCfg == nil {
		return false
	}
	return *t.IncludeEgrHashCfg
}

// GetMode retrieves the value of the leaf Mode from the NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos) GetMode() E_NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos_Mode {
	if t == nil || t.Mode == 0 {
		return 0
	}
	return t.Mode
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.IncludeEgrHashCfg == nil {
		var v bool = false
		t.IncludeEgrHashCfg = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos.
func (*NokiaConf_Configure_Groups_Group_Lag_Access_AdaptQos) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing represents the /nokia-conf/configure/groups/group/lag/adaptive-load-balancing YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing struct {
	Interval  *uint32 `path:"interval" module:"nokia-conf"`
	Tolerance *uint32 `path:"tolerance" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing) IsYANGGoStruct() {}

// GetInterval retrieves the value of the leaf Interval from the NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 30
	}
	return *t.Interval
}

// GetTolerance retrieves the value of the leaf Tolerance from the NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Tolerance is set, it can
// safely use t.GetTolerance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Tolerance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing) GetTolerance() uint32 {
	if t == nil || t.Tolerance == nil {
		return 20
	}
	return *t.Tolerance
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Interval == nil {
		var v uint32 = 30
		t.Interval = &v
	}
	if t.Tolerance == nil {
		var v uint32 = 20
		t.Tolerance = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing.
func (*NokiaConf_Configure_Groups_Group_Lag_AdaptiveLoadBalancing) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_BfdLiveness represents the /nokia-conf/configure/groups/group/lag/bfd-liveness YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_BfdLiveness struct {
	Ipv4               *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4 `path:"ipv4" module:"nokia-conf" yangPresence:"true"`
	Ipv6               *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6 `path:"ipv6" module:"nokia-conf" yangPresence:"true"`
	SoftResetExtension *bool                                                  `path:"soft-reset-extension" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_BfdLiveness implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_BfdLiveness) IsYANGGoStruct() {}

// GetOrCreateIpv4 retrieves the value of the Ipv4 field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness) GetOrCreateIpv4() *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4 {
	if t.Ipv4 != nil {
		return t.Ipv4
	}
	t.Ipv4 = &NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4{}
	return t.Ipv4
}

// GetOrCreateIpv6 retrieves the value of the Ipv6 field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness) GetOrCreateIpv6() *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6 {
	if t.Ipv6 != nil {
		return t.Ipv6
	}
	t.Ipv6 = &NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6{}
	return t.Ipv6
}

// GetIpv4 returns the value of the Ipv4 struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_BfdLiveness. If the receiver or the field Ipv4 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness) GetIpv4() *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4 {
	if t != nil && t.Ipv4 != nil {
		return t.Ipv4
	}
	return nil
}

// GetIpv6 returns the value of the Ipv6 struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_BfdLiveness. If the receiver or the field Ipv6 is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness) GetIpv6() *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6 {
	if t != nil && t.Ipv6 != nil {
		return t.Ipv6
	}
	return nil
}

// GetSoftResetExtension retrieves the value of the leaf SoftResetExtension from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SoftResetExtension is set, it can
// safely use t.GetSoftResetExtension() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SoftResetExtension == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness) GetSoftResetExtension() bool {
	if t == nil || t.SoftResetExtension == nil {
		return true
	}
	return *t.SoftResetExtension
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.SoftResetExtension == nil {
		var v bool = true
		t.SoftResetExtension = &v
	}
	t.Ipv4.PopulateDefaults()
	t.Ipv6.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_BfdLiveness"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_BfdLiveness.
func (*NokiaConf_Configure_Groups_Group_Lag_BfdLiveness) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4 represents the /nokia-conf/configure/groups/group/lag/bfd-liveness/ipv4 YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4 struct {
	AdminState            E_NokiaTypesSros_AdminState                                                  `path:"admin-state" module:"nokia-conf"`
	BfdOnDistributingOnly *bool                                                                        `path:"bfd-on-distributing-only" module:"nokia-conf"`
	LocalIpAddress        *string                                                                      `path:"local-ip-address" module:"nokia-conf"`
	MaxAdminDownTime      NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4_MaxAdminDownTime_Union `path:"max-admin-down-time" module:"nokia-conf"`
	MaxSetupTime          NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4_MaxSetupTime_Union     `path:"max-setup-time" module:"nokia-conf"`
	Multiplier            *uint32                                                                      `path:"multiplier" module:"nokia-conf"`
	ReceiveInterval       *uint32                                                                      `path:"receive-interval" module:"nokia-conf"`
	RemoteIpAddress       *string                                                                      `path:"remote-ip-address" module:"nokia-conf"`
	TransmitInterval      *uint32                                                                      `path:"transmit-interval" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetBfdOnDistributingOnly retrieves the value of the leaf BfdOnDistributingOnly from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BfdOnDistributingOnly is set, it can
// safely use t.GetBfdOnDistributingOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BfdOnDistributingOnly == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) GetBfdOnDistributingOnly() bool {
	if t == nil || t.BfdOnDistributingOnly == nil {
		return false
	}
	return *t.BfdOnDistributingOnly
}

// GetLocalIpAddress retrieves the value of the leaf LocalIpAddress from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalIpAddress is set, it can
// safely use t.GetLocalIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalIpAddress == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) GetLocalIpAddress() string {
	if t == nil || t.LocalIpAddress == nil {
		return ""
	}
	return *t.LocalIpAddress
}

// GetMaxAdminDownTime retrieves the value of the leaf MaxAdminDownTime from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxAdminDownTime is set, it can
// safely use t.GetMaxAdminDownTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxAdminDownTime == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) GetMaxAdminDownTime() NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4_MaxAdminDownTime_Union {
	if t == nil || t.MaxAdminDownTime == nil {
		return UnionInt32(0)
	}
	return t.MaxAdminDownTime
}

// GetMaxSetupTime retrieves the value of the leaf MaxSetupTime from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxSetupTime is set, it can
// safely use t.GetMaxSetupTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxSetupTime == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) GetMaxSetupTime() NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4_MaxSetupTime_Union {
	if t == nil || t.MaxSetupTime == nil {
		return NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4_MaxSetupTime_Enum_infinite
	}
	return t.MaxSetupTime
}

// GetMultiplier retrieves the value of the leaf Multiplier from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Multiplier is set, it can
// safely use t.GetMultiplier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Multiplier == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) GetMultiplier() uint32 {
	if t == nil || t.Multiplier == nil {
		return 3
	}
	return *t.Multiplier
}

// GetReceiveInterval retrieves the value of the leaf ReceiveInterval from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReceiveInterval is set, it can
// safely use t.GetReceiveInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReceiveInterval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) GetReceiveInterval() uint32 {
	if t == nil || t.ReceiveInterval == nil {
		return 100
	}
	return *t.ReceiveInterval
}

// GetRemoteIpAddress retrieves the value of the leaf RemoteIpAddress from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteIpAddress is set, it can
// safely use t.GetRemoteIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteIpAddress == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) GetRemoteIpAddress() string {
	if t == nil || t.RemoteIpAddress == nil {
		return ""
	}
	return *t.RemoteIpAddress
}

// GetTransmitInterval retrieves the value of the leaf TransmitInterval from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TransmitInterval is set, it can
// safely use t.GetTransmitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TransmitInterval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) GetTransmitInterval() uint32 {
	if t == nil || t.TransmitInterval == nil {
		return 100
	}
	return *t.TransmitInterval
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.BfdOnDistributingOnly == nil {
		var v bool = false
		t.BfdOnDistributingOnly = &v
	}
	if t.MaxAdminDownTime == nil {
		t.MaxAdminDownTime = UnionInt32(0)
	}
	if t.MaxSetupTime == nil {
		t.MaxSetupTime = NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4_MaxSetupTime_Enum_infinite
	}
	if t.Multiplier == nil {
		var v uint32 = 3
		t.Multiplier = &v
	}
	if t.ReceiveInterval == nil {
		var v uint32 = 100
		t.ReceiveInterval = &v
	}
	if t.TransmitInterval == nil {
		var v uint32 = 100
		t.TransmitInterval = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4.
func (*NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv4) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6 represents the /nokia-conf/configure/groups/group/lag/bfd-liveness/ipv6 YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6 struct {
	AdminState            E_NokiaTypesSros_AdminState                                                  `path:"admin-state" module:"nokia-conf"`
	BfdOnDistributingOnly *bool                                                                        `path:"bfd-on-distributing-only" module:"nokia-conf"`
	LocalIpAddress        *string                                                                      `path:"local-ip-address" module:"nokia-conf"`
	MaxAdminDownTime      NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6_MaxAdminDownTime_Union `path:"max-admin-down-time" module:"nokia-conf"`
	MaxSetupTime          NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6_MaxSetupTime_Union     `path:"max-setup-time" module:"nokia-conf"`
	Multiplier            *uint32                                                                      `path:"multiplier" module:"nokia-conf"`
	ReceiveInterval       *uint32                                                                      `path:"receive-interval" module:"nokia-conf"`
	RemoteIpAddress       *string                                                                      `path:"remote-ip-address" module:"nokia-conf"`
	TransmitInterval      *uint32                                                                      `path:"transmit-interval" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6 implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) IsYANGGoStruct() {}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetBfdOnDistributingOnly retrieves the value of the leaf BfdOnDistributingOnly from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BfdOnDistributingOnly is set, it can
// safely use t.GetBfdOnDistributingOnly() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BfdOnDistributingOnly == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) GetBfdOnDistributingOnly() bool {
	if t == nil || t.BfdOnDistributingOnly == nil {
		return false
	}
	return *t.BfdOnDistributingOnly
}

// GetLocalIpAddress retrieves the value of the leaf LocalIpAddress from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LocalIpAddress is set, it can
// safely use t.GetLocalIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LocalIpAddress == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) GetLocalIpAddress() string {
	if t == nil || t.LocalIpAddress == nil {
		return ""
	}
	return *t.LocalIpAddress
}

// GetMaxAdminDownTime retrieves the value of the leaf MaxAdminDownTime from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxAdminDownTime is set, it can
// safely use t.GetMaxAdminDownTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxAdminDownTime == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) GetMaxAdminDownTime() NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6_MaxAdminDownTime_Union {
	if t == nil || t.MaxAdminDownTime == nil {
		return UnionInt32(0)
	}
	return t.MaxAdminDownTime
}

// GetMaxSetupTime retrieves the value of the leaf MaxSetupTime from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxSetupTime is set, it can
// safely use t.GetMaxSetupTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxSetupTime == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) GetMaxSetupTime() NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6_MaxSetupTime_Union {
	if t == nil || t.MaxSetupTime == nil {
		return NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6_MaxSetupTime_Enum_infinite
	}
	return t.MaxSetupTime
}

// GetMultiplier retrieves the value of the leaf Multiplier from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Multiplier is set, it can
// safely use t.GetMultiplier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Multiplier == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) GetMultiplier() uint32 {
	if t == nil || t.Multiplier == nil {
		return 3
	}
	return *t.Multiplier
}

// GetReceiveInterval retrieves the value of the leaf ReceiveInterval from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ReceiveInterval is set, it can
// safely use t.GetReceiveInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ReceiveInterval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) GetReceiveInterval() uint32 {
	if t == nil || t.ReceiveInterval == nil {
		return 100
	}
	return *t.ReceiveInterval
}

// GetRemoteIpAddress retrieves the value of the leaf RemoteIpAddress from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RemoteIpAddress is set, it can
// safely use t.GetRemoteIpAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RemoteIpAddress == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) GetRemoteIpAddress() string {
	if t == nil || t.RemoteIpAddress == nil {
		return ""
	}
	return *t.RemoteIpAddress
}

// GetTransmitInterval retrieves the value of the leaf TransmitInterval from the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TransmitInterval is set, it can
// safely use t.GetTransmitInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TransmitInterval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) GetTransmitInterval() uint32 {
	if t == nil || t.TransmitInterval == nil {
		return 100
	}
	return *t.TransmitInterval
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.BfdOnDistributingOnly == nil {
		var v bool = false
		t.BfdOnDistributingOnly = &v
	}
	if t.MaxAdminDownTime == nil {
		t.MaxAdminDownTime = UnionInt32(0)
	}
	if t.MaxSetupTime == nil {
		t.MaxSetupTime = NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6_MaxSetupTime_Enum_infinite
	}
	if t.Multiplier == nil {
		var v uint32 = 3
		t.Multiplier = &v
	}
	if t.ReceiveInterval == nil {
		var v uint32 = 100
		t.ReceiveInterval = &v
	}
	if t.TransmitInterval == nil {
		var v uint32 = 100
		t.TransmitInterval = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6.
func (*NokiaConf_Configure_Groups_Group_Lag_BfdLiveness_Ipv6) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_EthCfm represents the /nokia-conf/configure/groups/group/lag/eth-cfm YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_EthCfm struct {
	Mep map[NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Key]*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep `path:"mep" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_EthCfm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm) IsYANGGoStruct() {}

// NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Key represents the key for list Mep of element /nokia-conf/configure/groups/group/lag/eth-cfm.
type NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Key struct {
	MdAdminName string                                                      `path:"md-admin-name"`
	MaAdminName string                                                      `path:"ma-admin-name"`
	MepId       NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_MepId_Union `path:"mep-id"`
}

// NewMep creates a new entry in the Mep list of the
// NokiaConf_Configure_Groups_Group_Lag_EthCfm struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm) NewMep(MdAdminName string, MaAdminName string, MepId NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_MepId_Union) (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mep == nil {
		t.Mep = make(map[NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Key]*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep)
	}

	key := NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Key{
		MdAdminName: MdAdminName,
		MaAdminName: MaAdminName,
		MepId:       MepId,
	}

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mep[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mep", key)
	}

	t.Mep[key] = &NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep{
		MdAdminName: &MdAdminName,
		MaAdminName: &MaAdminName,
		MepId:       MepId,
	}

	return t.Mep[key], nil
}

// RenameMep renames an entry in the list Mep within
// the NokiaConf_Configure_Groups_Group_Lag_EthCfm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm) RenameMep(oldK, newK NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Key) error {
	if _, ok := t.Mep[newK]; ok {
		return fmt.Errorf("key %v already exists in Mep", newK)
	}

	e, ok := t.Mep[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mep", oldK)
	}
	e.MdAdminName = &newK.MdAdminName
	e.MaAdminName = &newK.MaAdminName
	e.MepId = newK.MepId

	t.Mep[newK] = e
	delete(t.Mep, oldK)
	return nil
}

// GetOrCreateMep retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Lag_EthCfm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm) GetOrCreateMep(MdAdminName string, MaAdminName string, MepId NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_MepId_Union) *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep {

	key := NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Key{
		MdAdminName: MdAdminName,
		MaAdminName: MaAdminName,
		MepId:       MepId,
	}

	if v, ok := t.Mep[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMep(MdAdminName, MaAdminName, MepId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMep got unexpected error: %v", err))
	}
	return v
}

// GetMep retrieves the value with the specified key from
// the Mep map field of NokiaConf_Configure_Groups_Group_Lag_EthCfm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm) GetMep(MdAdminName string, MaAdminName string, MepId NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_MepId_Union) *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep {

	if t == nil {
		return nil
	}

	key := NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Key{
		MdAdminName: MdAdminName,
		MaAdminName: MaAdminName,
		MepId:       MepId,
	}

	if lm, ok := t.Mep[key]; ok {
		return lm
	}
	return nil
}

// DeleteMep deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Lag_EthCfm. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm) DeleteMep(MdAdminName string, MaAdminName string, MepId NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_MepId_Union) {
	key := NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Key{
		MdAdminName: MdAdminName,
		MaAdminName: MaAdminName,
		MepId:       MepId,
	}

	delete(t.Mep, key)
}

// AppendMep appends the supplied NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep struct to the
// list Mep of NokiaConf_Configure_Groups_Group_Lag_EthCfm. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm) AppendMep(v *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) error {
	if v.MdAdminName == nil {
		return fmt.Errorf("invalid nil key for MdAdminName")
	}

	if v.MaAdminName == nil {
		return fmt.Errorf("invalid nil key for MaAdminName")
	}

	key := NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Key{
		MdAdminName: *v.MdAdminName,
		MaAdminName: *v.MaAdminName,
		MepId:       v.MepId,
	}

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mep == nil {
		t.Mep = make(map[NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Key]*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep)
	}

	if _, ok := t.Mep[key]; ok {
		return fmt.Errorf("duplicate key for list Mep %v", key)
	}

	t.Mep[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_EthCfm
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Mep {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_EthCfm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_EthCfm.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep represents the /nokia-conf/configure/groups/group/lag/eth-cfm/mep YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep struct {
	AdminState           E_NokiaTypesSros_AdminState                                        `path:"admin-state" module:"nokia-conf"`
	Ais                  *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais               `path:"ais" module:"nokia-conf" yangPresence:"true"`
	AlarmNotification    *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification `path:"alarm-notification" module:"nokia-conf"`
	Ccm                  *bool                                                              `path:"ccm" module:"nokia-conf"`
	CcmLtmPriority       *uint8                                                             `path:"ccm-ltm-priority" module:"nokia-conf"`
	CcmPaddingSize       *uint32                                                            `path:"ccm-padding-size" module:"nokia-conf"`
	CcmTlvIgnore         []E_NokiaTypesEthCfm_CcmTlvIgnoreType                              `path:"ccm-tlv-ignore" module:"nokia-conf"`
	CollectLmmStats      *bool                                                              `path:"collect-lmm-stats" module:"nokia-conf"`
	Csf                  *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf               `path:"csf" module:"nokia-conf" yangPresence:"true"`
	Description          *string                                                            `path:"description" module:"nokia-conf"`
	EthTest              *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest           `path:"eth-test" module:"nokia-conf" yangPresence:"true"`
	FacilityFault        *bool                                                              `path:"facility-fault" module:"nokia-conf"`
	Grace                *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace             `path:"grace" module:"nokia-conf"`
	LowPriorityDefect    E_NokiaTypesEthCfm_LowestAlarmPriority                             `path:"low-priority-defect" module:"nokia-conf"`
	MaAdminName          *string                                                            `path:"ma-admin-name" module:"nokia-conf"`
	MacAddress           *string                                                            `path:"mac-address" module:"nokia-conf"`
	MdAdminName          *string                                                            `path:"md-admin-name" module:"nokia-conf"`
	MepId                NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_MepId_Union        `path:"mep-id" module:"nokia-conf"`
	OneWayDelayThreshold *uint32                                                            `path:"one-way-delay-threshold" module:"nokia-conf"`
	Vlan                 NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Vlan_Union         `path:"vlan" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) IsYANGGoStruct() {}

// GetOrCreateAis retrieves the value of the Ais field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetOrCreateAis() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais {
	if t.Ais != nil {
		return t.Ais
	}
	t.Ais = &NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais{}
	return t.Ais
}

// GetOrCreateAlarmNotification retrieves the value of the AlarmNotification field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetOrCreateAlarmNotification() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification {
	if t.AlarmNotification != nil {
		return t.AlarmNotification
	}
	t.AlarmNotification = &NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification{}
	return t.AlarmNotification
}

// GetOrCreateCsf retrieves the value of the Csf field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetOrCreateCsf() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf {
	if t.Csf != nil {
		return t.Csf
	}
	t.Csf = &NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf{}
	return t.Csf
}

// GetOrCreateEthTest retrieves the value of the EthTest field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetOrCreateEthTest() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest {
	if t.EthTest != nil {
		return t.EthTest
	}
	t.EthTest = &NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest{}
	return t.EthTest
}

// GetOrCreateGrace retrieves the value of the Grace field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetOrCreateGrace() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace {
	if t.Grace != nil {
		return t.Grace
	}
	t.Grace = &NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace{}
	return t.Grace
}

// GetAis returns the value of the Ais struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep. If the receiver or the field Ais is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetAis() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais {
	if t != nil && t.Ais != nil {
		return t.Ais
	}
	return nil
}

// GetAlarmNotification returns the value of the AlarmNotification struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep. If the receiver or the field AlarmNotification is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetAlarmNotification() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification {
	if t != nil && t.AlarmNotification != nil {
		return t.AlarmNotification
	}
	return nil
}

// GetCsf returns the value of the Csf struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep. If the receiver or the field Csf is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetCsf() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf {
	if t != nil && t.Csf != nil {
		return t.Csf
	}
	return nil
}

// GetEthTest returns the value of the EthTest struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep. If the receiver or the field EthTest is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetEthTest() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest {
	if t != nil && t.EthTest != nil {
		return t.EthTest
	}
	return nil
}

// GetGrace returns the value of the Grace struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep. If the receiver or the field Grace is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetGrace() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace {
	if t != nil && t.Grace != nil {
		return t.Grace
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetCcm retrieves the value of the leaf Ccm from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Ccm is set, it can
// safely use t.GetCcm() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Ccm == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetCcm() bool {
	if t == nil || t.Ccm == nil {
		return false
	}
	return *t.Ccm
}

// GetCcmLtmPriority retrieves the value of the leaf CcmLtmPriority from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CcmLtmPriority is set, it can
// safely use t.GetCcmLtmPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CcmLtmPriority == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetCcmLtmPriority() uint8 {
	if t == nil || t.CcmLtmPriority == nil {
		return 7
	}
	return *t.CcmLtmPriority
}

// GetCcmPaddingSize retrieves the value of the leaf CcmPaddingSize from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CcmPaddingSize is set, it can
// safely use t.GetCcmPaddingSize() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CcmPaddingSize == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetCcmPaddingSize() uint32 {
	if t == nil || t.CcmPaddingSize == nil {
		return 0
	}
	return *t.CcmPaddingSize
}

// GetCcmTlvIgnore retrieves the value of the leaf CcmTlvIgnore from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CcmTlvIgnore is set, it can
// safely use t.GetCcmTlvIgnore() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CcmTlvIgnore == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetCcmTlvIgnore() []E_NokiaTypesEthCfm_CcmTlvIgnoreType {
	if t == nil || t.CcmTlvIgnore == nil {
		return nil
	}
	return t.CcmTlvIgnore
}

// GetCollectLmmStats retrieves the value of the leaf CollectLmmStats from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CollectLmmStats is set, it can
// safely use t.GetCollectLmmStats() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CollectLmmStats == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetCollectLmmStats() bool {
	if t == nil || t.CollectLmmStats == nil {
		return false
	}
	return *t.CollectLmmStats
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFacilityFault retrieves the value of the leaf FacilityFault from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FacilityFault is set, it can
// safely use t.GetFacilityFault() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FacilityFault == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetFacilityFault() bool {
	if t == nil || t.FacilityFault == nil {
		return false
	}
	return *t.FacilityFault
}

// GetLowPriorityDefect retrieves the value of the leaf LowPriorityDefect from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowPriorityDefect is set, it can
// safely use t.GetLowPriorityDefect() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowPriorityDefect == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetLowPriorityDefect() E_NokiaTypesEthCfm_LowestAlarmPriority {
	if t == nil || t.LowPriorityDefect == 0 {
		return NokiaTypesEthCfm_LowestAlarmPriority_mac_rem_err_xcon
	}
	return t.LowPriorityDefect
}

// GetMaAdminName retrieves the value of the leaf MaAdminName from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaAdminName is set, it can
// safely use t.GetMaAdminName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaAdminName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetMaAdminName() string {
	if t == nil || t.MaAdminName == nil {
		return ""
	}
	return *t.MaAdminName
}

// GetMacAddress retrieves the value of the leaf MacAddress from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MacAddress is set, it can
// safely use t.GetMacAddress() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MacAddress == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetMacAddress() string {
	if t == nil || t.MacAddress == nil {
		return ""
	}
	return *t.MacAddress
}

// GetMdAdminName retrieves the value of the leaf MdAdminName from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MdAdminName is set, it can
// safely use t.GetMdAdminName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MdAdminName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetMdAdminName() string {
	if t == nil || t.MdAdminName == nil {
		return ""
	}
	return *t.MdAdminName
}

// GetMepId retrieves the value of the leaf MepId from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MepId is set, it can
// safely use t.GetMepId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MepId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetMepId() NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_MepId_Union {
	if t == nil || t.MepId == nil {
		return nil
	}
	return t.MepId
}

// GetOneWayDelayThreshold retrieves the value of the leaf OneWayDelayThreshold from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OneWayDelayThreshold is set, it can
// safely use t.GetOneWayDelayThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OneWayDelayThreshold == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetOneWayDelayThreshold() uint32 {
	if t == nil || t.OneWayDelayThreshold == nil {
		return 3
	}
	return *t.OneWayDelayThreshold
}

// GetVlan retrieves the value of the leaf Vlan from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Vlan is set, it can
// safely use t.GetVlan() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Vlan == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) GetVlan() NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Vlan_Union {
	if t == nil || t.Vlan == nil {
		return NokiaTypesEthCfm_VlanIdOrNone_Enum_none
	}
	return t.Vlan
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.Ccm == nil {
		var v bool = false
		t.Ccm = &v
	}
	if t.CcmLtmPriority == nil {
		var v uint8 = 7
		t.CcmLtmPriority = &v
	}
	if t.CollectLmmStats == nil {
		var v bool = false
		t.CollectLmmStats = &v
	}
	if t.FacilityFault == nil {
		var v bool = false
		t.FacilityFault = &v
	}
	if t.LowPriorityDefect == 0 {
		t.LowPriorityDefect = NokiaTypesEthCfm_LowestAlarmPriority_mac_rem_err_xcon
	}
	if t.OneWayDelayThreshold == nil {
		var v uint32 = 3
		t.OneWayDelayThreshold = &v
	}
	if t.Vlan == nil {
		t.Vlan = NokiaTypesEthCfm_VlanIdOrNone_Enum_none
	}
	t.Ais.PopulateDefaults()
	t.AlarmNotification.PopulateDefaults()
	t.Csf.PopulateDefaults()
	t.EthTest.PopulateDefaults()
	t.Grace.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) ΛListKeyMap() (map[string]interface{}, error) {
	if t.MaAdminName == nil {
		return nil, fmt.Errorf("nil value for key MaAdminName")
	}

	if t.MdAdminName == nil {
		return nil, fmt.Errorf("nil value for key MdAdminName")
	}

	return map[string]interface{}{
		"ma-admin-name": *t.MaAdminName,
		"md-admin-name": *t.MdAdminName,
		"mep-id":        t.MepId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais represents the /nokia-conf/configure/groups/group/lag/eth-cfm/mep/ais YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais struct {
	ClientMegLevel    []uint32                                                                `path:"client-meg-level" module:"nokia-conf"`
	InterfaceSupport  *bool                                                                   `path:"interface-support" module:"nokia-conf"`
	Interval          *uint32                                                                 `path:"interval" module:"nokia-conf"`
	LowPriorityDefect E_NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais_LowPriorityDefect `path:"low-priority-defect" module:"nokia-conf"`
	Priority          *uint8                                                                  `path:"priority" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais) IsYANGGoStruct() {}

// GetClientMegLevel retrieves the value of the leaf ClientMegLevel from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ClientMegLevel is set, it can
// safely use t.GetClientMegLevel() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ClientMegLevel == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais) GetClientMegLevel() []uint32 {
	if t == nil || t.ClientMegLevel == nil {
		return nil
	}
	return t.ClientMegLevel
}

// GetInterfaceSupport retrieves the value of the leaf InterfaceSupport from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InterfaceSupport is set, it can
// safely use t.GetInterfaceSupport() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InterfaceSupport == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais) GetInterfaceSupport() bool {
	if t == nil || t.InterfaceSupport == nil {
		return false
	}
	return *t.InterfaceSupport
}

// GetInterval retrieves the value of the leaf Interval from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Interval is set, it can
// safely use t.GetInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Interval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais) GetInterval() uint32 {
	if t == nil || t.Interval == nil {
		return 1
	}
	return *t.Interval
}

// GetLowPriorityDefect retrieves the value of the leaf LowPriorityDefect from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowPriorityDefect is set, it can
// safely use t.GetLowPriorityDefect() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowPriorityDefect == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais) GetLowPriorityDefect() E_NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais_LowPriorityDefect {
	if t == nil || t.LowPriorityDefect == 0 {
		return NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais_LowPriorityDefect_all_def
	}
	return t.LowPriorityDefect
}

// GetPriority retrieves the value of the leaf Priority from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais) GetPriority() uint8 {
	if t == nil || t.Priority == nil {
		return 7
	}
	return *t.Priority
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.InterfaceSupport == nil {
		var v bool = false
		t.InterfaceSupport = &v
	}
	if t.Interval == nil {
		var v uint32 = 1
		t.Interval = &v
	}
	if t.LowPriorityDefect == 0 {
		t.LowPriorityDefect = NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais_LowPriorityDefect_all_def
	}
	if t.Priority == nil {
		var v uint8 = 7
		t.Priority = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Ais) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification represents the /nokia-conf/configure/groups/group/lag/eth-cfm/mep/alarm-notification YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification struct {
	FngAlarmTime *int32 `path:"fng-alarm-time" module:"nokia-conf"`
	FngResetTime *int32 `path:"fng-reset-time" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification) IsYANGGoStruct() {}

// GetFngAlarmTime retrieves the value of the leaf FngAlarmTime from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FngAlarmTime is set, it can
// safely use t.GetFngAlarmTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FngAlarmTime == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification) GetFngAlarmTime() int32 {
	if t == nil || t.FngAlarmTime == nil {
		return 0
	}
	return *t.FngAlarmTime
}

// GetFngResetTime retrieves the value of the leaf FngResetTime from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FngResetTime is set, it can
// safely use t.GetFngResetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FngResetTime == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification) GetFngResetTime() int32 {
	if t == nil || t.FngResetTime == nil {
		return 0
	}
	return *t.FngResetTime
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_AlarmNotification) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf represents the /nokia-conf/configure/groups/group/lag/eth-cfm/mep/csf YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf struct {
	Multiplier *float64 `path:"multiplier" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf) IsYANGGoStruct() {}

// GetMultiplier retrieves the value of the leaf Multiplier from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Multiplier is set, it can
// safely use t.GetMultiplier() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Multiplier == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf) GetMultiplier() float64 {
	if t == nil || t.Multiplier == nil {
		return 3.5
	}
	return *t.Multiplier
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Multiplier == nil {
		var v float64 = 3.5
		t.Multiplier = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Csf) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest represents the /nokia-conf/configure/groups/group/lag/eth-cfm/mep/eth-test YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest struct {
	BitErrorThreshold *uint32                                                              `path:"bit-error-threshold" module:"nokia-conf"`
	TestPattern       *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern `path:"test-pattern" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest) IsYANGGoStruct() {}

// GetOrCreateTestPattern retrieves the value of the TestPattern field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest) GetOrCreateTestPattern() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern {
	if t.TestPattern != nil {
		return t.TestPattern
	}
	t.TestPattern = &NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern{}
	return t.TestPattern
}

// GetTestPattern returns the value of the TestPattern struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest. If the receiver or the field TestPattern is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest) GetTestPattern() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern {
	if t != nil && t.TestPattern != nil {
		return t.TestPattern
	}
	return nil
}

// GetBitErrorThreshold retrieves the value of the leaf BitErrorThreshold from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if BitErrorThreshold is set, it can
// safely use t.GetBitErrorThreshold() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.BitErrorThreshold == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest) GetBitErrorThreshold() uint32 {
	if t == nil || t.BitErrorThreshold == nil {
		return 1
	}
	return *t.BitErrorThreshold
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.BitErrorThreshold == nil {
		var v uint32 = 1
		t.BitErrorThreshold = &v
	}
	t.TestPattern.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern represents the /nokia-conf/configure/groups/group/lag/eth-cfm/mep/eth-test/test-pattern YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern struct {
	CrcTlv  *bool                                                                         `path:"crc-tlv" module:"nokia-conf"`
	Pattern E_NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern_Pattern `path:"pattern" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern) IsYANGGoStruct() {}

// GetCrcTlv retrieves the value of the leaf CrcTlv from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CrcTlv is set, it can
// safely use t.GetCrcTlv() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CrcTlv == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern) GetCrcTlv() bool {
	if t == nil || t.CrcTlv == nil {
		return false
	}
	return *t.CrcTlv
}

// GetPattern retrieves the value of the leaf Pattern from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Pattern is set, it can
// safely use t.GetPattern() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Pattern == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern) GetPattern() E_NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern_Pattern {
	if t == nil || t.Pattern == 0 {
		return NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern_Pattern_all_zeros
	}
	return t.Pattern
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.CrcTlv == nil {
		var v bool = false
		t.CrcTlv = &v
	}
	if t.Pattern == 0 {
		t.Pattern = NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern_Pattern_all_zeros
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_EthTest_TestPattern) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace represents the /nokia-conf/configure/groups/group/lag/eth-cfm/mep/grace YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace struct {
	EthEd       *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd       `path:"eth-ed" module:"nokia-conf"`
	EthVsmGrace *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace `path:"eth-vsm-grace" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace) IsYANGGoStruct() {}

// GetOrCreateEthEd retrieves the value of the EthEd field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace) GetOrCreateEthEd() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd {
	if t.EthEd != nil {
		return t.EthEd
	}
	t.EthEd = &NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd{}
	return t.EthEd
}

// GetOrCreateEthVsmGrace retrieves the value of the EthVsmGrace field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace) GetOrCreateEthVsmGrace() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace {
	if t.EthVsmGrace != nil {
		return t.EthVsmGrace
	}
	t.EthVsmGrace = &NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace{}
	return t.EthVsmGrace
}

// GetEthEd returns the value of the EthEd struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace. If the receiver or the field EthEd is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace) GetEthEd() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd {
	if t != nil && t.EthEd != nil {
		return t.EthEd
	}
	return nil
}

// GetEthVsmGrace returns the value of the EthVsmGrace struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace. If the receiver or the field EthVsmGrace is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace) GetEthVsmGrace() *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace {
	if t != nil && t.EthVsmGrace != nil {
		return t.EthVsmGrace
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.EthEd.PopulateDefaults()
	t.EthVsmGrace.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd represents the /nokia-conf/configure/groups/group/lag/eth-cfm/mep/grace/eth-ed YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd struct {
	MaxRxDefectWindow *uint32 `path:"max-rx-defect-window" module:"nokia-conf"`
	Priority          *int32  `path:"priority" module:"nokia-conf"`
	RxEthEd           *bool   `path:"rx-eth-ed" module:"nokia-conf"`
	TxEthEd           *bool   `path:"tx-eth-ed" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd) IsYANGGoStruct() {}

// GetMaxRxDefectWindow retrieves the value of the leaf MaxRxDefectWindow from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxRxDefectWindow is set, it can
// safely use t.GetMaxRxDefectWindow() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxRxDefectWindow == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd) GetMaxRxDefectWindow() uint32 {
	if t == nil || t.MaxRxDefectWindow == nil {
		return 0
	}
	return *t.MaxRxDefectWindow
}

// GetPriority retrieves the value of the leaf Priority from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd) GetPriority() int32 {
	if t == nil || t.Priority == nil {
		return 0
	}
	return *t.Priority
}

// GetRxEthEd retrieves the value of the leaf RxEthEd from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RxEthEd is set, it can
// safely use t.GetRxEthEd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RxEthEd == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd) GetRxEthEd() bool {
	if t == nil || t.RxEthEd == nil {
		return true
	}
	return *t.RxEthEd
}

// GetTxEthEd retrieves the value of the leaf TxEthEd from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TxEthEd is set, it can
// safely use t.GetTxEthEd() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TxEthEd == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd) GetTxEthEd() bool {
	if t == nil || t.TxEthEd == nil {
		return false
	}
	return *t.TxEthEd
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RxEthEd == nil {
		var v bool = true
		t.RxEthEd = &v
	}
	if t.TxEthEd == nil {
		var v bool = false
		t.TxEthEd = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthEd) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace represents the /nokia-conf/configure/groups/group/lag/eth-cfm/mep/grace/eth-vsm-grace YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace struct {
	RxEthVsmGrace *bool `path:"rx-eth-vsm-grace" module:"nokia-conf"`
	TxEthVsmGrace *bool `path:"tx-eth-vsm-grace" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace) IsYANGGoStruct() {}

// GetRxEthVsmGrace retrieves the value of the leaf RxEthVsmGrace from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RxEthVsmGrace is set, it can
// safely use t.GetRxEthVsmGrace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RxEthVsmGrace == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace) GetRxEthVsmGrace() bool {
	if t == nil || t.RxEthVsmGrace == nil {
		return true
	}
	return *t.RxEthVsmGrace
}

// GetTxEthVsmGrace retrieves the value of the leaf TxEthVsmGrace from the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TxEthVsmGrace is set, it can
// safely use t.GetTxEthVsmGrace() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TxEthVsmGrace == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace) GetTxEthVsmGrace() bool {
	if t == nil || t.TxEthVsmGrace == nil {
		return true
	}
	return *t.TxEthVsmGrace
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.RxEthVsmGrace == nil {
		var v bool = true
		t.RxEthVsmGrace = &v
	}
	if t.TxEthVsmGrace == nil {
		var v bool = true
		t.TxEthVsmGrace = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace.
func (*NokiaConf_Configure_Groups_Group_Lag_EthCfm_Mep_Grace_EthVsmGrace) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold represents the /nokia-conf/configure/groups/group/lag/hash-weight-threshold YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold struct {
	Action E_NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold_Action `path:"action" module:"nokia-conf"`
	Cost   *uint32                                                           `path:"cost" module:"nokia-conf"`
	Value  *int32                                                            `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold) IsYANGGoStruct() {}

// GetAction retrieves the value of the leaf Action from the NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Action is set, it can
// safely use t.GetAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Action == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold) GetAction() E_NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold_Action {
	if t == nil || t.Action == 0 {
		return NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold_Action_down
	}
	return t.Action
}

// GetCost retrieves the value of the leaf Cost from the NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cost is set, it can
// safely use t.GetCost() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cost == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold) GetCost() uint32 {
	if t == nil || t.Cost == nil {
		return 0
	}
	return *t.Cost
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold) GetValue() int32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Action == 0 {
		t.Action = NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold_Action_down
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold.
func (*NokiaConf_Configure_Groups_Group_Lag_HashWeightThreshold) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_Lacp represents the /nokia-conf/configure/groups/group/lag/lacp YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_Lacp struct {
	AdministrativeKey *int32                                           `path:"administrative-key" module:"nokia-conf"`
	Mode              E_NokiaConf_Configure_Groups_Group_Lag_Lacp_Mode `path:"mode" module:"nokia-conf"`
	SystemId          *string                                          `path:"system-id" module:"nokia-conf"`
	SystemPriority    *int32                                           `path:"system-priority" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_Lacp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_Lacp) IsYANGGoStruct() {}

// GetAdministrativeKey retrieves the value of the leaf AdministrativeKey from the NokiaConf_Configure_Groups_Group_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdministrativeKey is set, it can
// safely use t.GetAdministrativeKey() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdministrativeKey == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Lacp) GetAdministrativeKey() int32 {
	if t == nil || t.AdministrativeKey == nil {
		return 0
	}
	return *t.AdministrativeKey
}

// GetMode retrieves the value of the leaf Mode from the NokiaConf_Configure_Groups_Group_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Lacp) GetMode() E_NokiaConf_Configure_Groups_Group_Lag_Lacp_Mode {
	if t == nil || t.Mode == 0 {
		return NokiaConf_Configure_Groups_Group_Lag_Lacp_Mode_passive
	}
	return t.Mode
}

// GetSystemId retrieves the value of the leaf SystemId from the NokiaConf_Configure_Groups_Group_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemId is set, it can
// safely use t.GetSystemId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Lacp) GetSystemId() string {
	if t == nil || t.SystemId == nil {
		return "00:00:00:00:00:00"
	}
	return *t.SystemId
}

// GetSystemPriority retrieves the value of the leaf SystemPriority from the NokiaConf_Configure_Groups_Group_Lag_Lacp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SystemPriority is set, it can
// safely use t.GetSystemPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SystemPriority == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Lacp) GetSystemPriority() int32 {
	if t == nil || t.SystemPriority == nil {
		return 0
	}
	return *t.SystemPriority
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_Lacp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_Lacp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mode == 0 {
		t.Mode = NokiaConf_Configure_Groups_Group_Lag_Lacp_Mode_passive
	}
	if t.SystemId == nil {
		var v string = "00:00:00:00:00:00"
		t.SystemId = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Lacp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_Lacp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Lacp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_Lacp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_Lacp.
func (*NokiaConf_Configure_Groups_Group_Lag_Lacp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile represents the /nokia-conf/configure/groups/group/lag/link-map-profile YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile struct {
	Description      *string                                                                    `path:"description" module:"nokia-conf"`
	FailureMode      E_NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_FailureMode          `path:"failure-mode" module:"nokia-conf"`
	Link             map[string]*NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link       `path:"link" module:"nokia-conf"`
	LinkMapProfileId NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_LinkMapProfileId_Union `path:"link-map-profile-id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) IsYANGGoStruct() {}

// NewLink creates a new entry in the Link list of the
// NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) NewLink(PortId string) (*NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Link == nil {
		t.Link = make(map[string]*NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link)
	}

	key := PortId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Link[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Link", key)
	}

	t.Link[key] = &NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link{
		PortId: &PortId,
	}

	return t.Link[key], nil
}

// RenameLink renames an entry in the list Link within
// the NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) RenameLink(oldK, newK string) error {
	if _, ok := t.Link[newK]; ok {
		return fmt.Errorf("key %v already exists in Link", newK)
	}

	e, ok := t.Link[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Link", oldK)
	}
	e.PortId = &newK

	t.Link[newK] = e
	delete(t.Link, oldK)
	return nil
}

// GetOrCreateLink retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) GetOrCreateLink(PortId string) *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link {

	key := PortId

	if v, ok := t.Link[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLink(PortId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLink got unexpected error: %v", err))
	}
	return v
}

// GetLink retrieves the value with the specified key from
// the Link map field of NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) GetLink(PortId string) *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link {

	if t == nil {
		return nil
	}

	key := PortId

	if lm, ok := t.Link[key]; ok {
		return lm
	}
	return nil
}

// DeleteLink deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) DeleteLink(PortId string) {
	key := PortId

	delete(t.Link, key)
}

// AppendLink appends the supplied NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link struct to the
// list Link of NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) AppendLink(v *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link) error {
	if v.PortId == nil {
		return fmt.Errorf("invalid nil key received for PortId")
	}

	key := *v.PortId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Link == nil {
		t.Link = make(map[string]*NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link)
	}

	if _, ok := t.Link[key]; ok {
		return fmt.Errorf("duplicate key for list Link %v", key)
	}

	t.Link[key] = v
	return nil
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFailureMode retrieves the value of the leaf FailureMode from the NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FailureMode is set, it can
// safely use t.GetFailureMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FailureMode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) GetFailureMode() E_NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_FailureMode {
	if t == nil || t.FailureMode == 0 {
		return NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_FailureMode_per_link_hash
	}
	return t.FailureMode
}

// GetLinkMapProfileId retrieves the value of the leaf LinkMapProfileId from the NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LinkMapProfileId is set, it can
// safely use t.GetLinkMapProfileId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LinkMapProfileId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) GetLinkMapProfileId() NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_LinkMapProfileId_Union {
	if t == nil || t.LinkMapProfileId == nil {
		return nil
	}
	return t.LinkMapProfileId
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FailureMode == 0 {
		t.FailureMode = NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_FailureMode_per_link_hash
	}
	for _, e := range t.Link {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"link-map-profile-id": t.LinkMapProfileId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile.
func (*NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link represents the /nokia-conf/configure/groups/group/lag/link-map-profile/link YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link struct {
	PortId   *string                                                             `path:"port-id" module:"nokia-conf"`
	PortType E_NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link_PortType `path:"port-type" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link) IsYANGGoStruct() {}

// GetPortId retrieves the value of the leaf PortId from the NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortId is set, it can
// safely use t.GetPortId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link) GetPortId() string {
	if t == nil || t.PortId == nil {
		return ""
	}
	return *t.PortId
}

// GetPortType retrieves the value of the leaf PortType from the NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortType is set, it can
// safely use t.GetPortType() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortType == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link) GetPortType() E_NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link_PortType {
	if t == nil || t.PortType == 0 {
		return 0
	}
	return t.PortType
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PortId == nil {
		return nil, fmt.Errorf("nil value for key PortId")
	}

	return map[string]interface{}{
		"port-id": *t.PortId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link.
func (*NokiaConf_Configure_Groups_Group_Lag_LinkMapProfile_Link) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_PerLinkHash represents the /nokia-conf/configure/groups/group/lag/per-link-hash YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_PerLinkHash struct {
	Weighted *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted `path:"weighted" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_PerLinkHash implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_PerLinkHash) IsYANGGoStruct() {}

// GetOrCreateWeighted retrieves the value of the Weighted field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash) GetOrCreateWeighted() *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted {
	if t.Weighted != nil {
		return t.Weighted
	}
	t.Weighted = &NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted{}
	return t.Weighted
}

// GetWeighted returns the value of the Weighted struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_PerLinkHash. If the receiver or the field Weighted is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash) GetWeighted() *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted {
	if t != nil && t.Weighted != nil {
		return t.Weighted
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_PerLinkHash
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.Weighted.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_PerLinkHash"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_PerLinkHash.
func (*NokiaConf_Configure_Groups_Group_Lag_PerLinkHash) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted represents the /nokia-conf/configure/groups/group/lag/per-link-hash/weighted YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted struct {
	AutoRebalance *bool `path:"auto-rebalance" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted) IsYANGGoStruct() {}

// GetAutoRebalance retrieves the value of the leaf AutoRebalance from the NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AutoRebalance is set, it can
// safely use t.GetAutoRebalance() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AutoRebalance == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted) GetAutoRebalance() bool {
	if t == nil || t.AutoRebalance == nil {
		return false
	}
	return *t.AutoRebalance
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AutoRebalance == nil {
		var v bool = false
		t.AutoRebalance = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted.
func (*NokiaConf_Configure_Groups_Group_Lag_PerLinkHash_Weighted) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_Port represents the /nokia-conf/configure/groups/group/lag/port YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_Port struct {
	HashWeight NokiaConf_Configure_Groups_Group_Lag_Port_HashWeight_Union `path:"hash-weight" module:"nokia-conf"`
	PortId     *string                                                    `path:"port-id" module:"nokia-conf"`
	Priority   *uint32                                                    `path:"priority" module:"nokia-conf"`
	SubGroup   NokiaConf_Configure_Groups_Group_Lag_Port_SubGroup_Union   `path:"sub-group" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_Port implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_Port) IsYANGGoStruct() {}

// GetHashWeight retrieves the value of the leaf HashWeight from the NokiaConf_Configure_Groups_Group_Lag_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HashWeight is set, it can
// safely use t.GetHashWeight() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HashWeight == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Port) GetHashWeight() NokiaConf_Configure_Groups_Group_Lag_Port_HashWeight_Union {
	if t == nil || t.HashWeight == nil {
		return nil
	}
	return t.HashWeight
}

// GetPortId retrieves the value of the leaf PortId from the NokiaConf_Configure_Groups_Group_Lag_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PortId is set, it can
// safely use t.GetPortId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PortId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Port) GetPortId() string {
	if t == nil || t.PortId == nil {
		return ""
	}
	return *t.PortId
}

// GetPriority retrieves the value of the leaf Priority from the NokiaConf_Configure_Groups_Group_Lag_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Priority is set, it can
// safely use t.GetPriority() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Priority == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Port) GetPriority() uint32 {
	if t == nil || t.Priority == nil {
		return 32768
	}
	return *t.Priority
}

// GetSubGroup retrieves the value of the leaf SubGroup from the NokiaConf_Configure_Groups_Group_Lag_Port
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubGroup is set, it can
// safely use t.GetSubGroup() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubGroup == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Port) GetSubGroup() NokiaConf_Configure_Groups_Group_Lag_Port_SubGroup_Union {
	if t == nil || t.SubGroup == nil {
		return UnionUint32(1)
	}
	return t.SubGroup
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_Port
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_Port) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Priority == nil {
		var v uint32 = 32768
		t.Priority = &v
	}
	if t.SubGroup == nil {
		t.SubGroup = UnionUint32(1)
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Lag_Port struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Lag_Port) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PortId == nil {
		return nil, fmt.Errorf("nil value for key PortId")
	}

	return map[string]interface{}{
		"port-id": *t.PortId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Port) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_Port"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Port) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_Port) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_Port.
func (*NokiaConf_Configure_Groups_Group_Lag_Port) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_PortThreshold represents the /nokia-conf/configure/groups/group/lag/port-threshold YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_PortThreshold struct {
	Action E_NokiaConf_Configure_Groups_Group_Lag_PortThreshold_Action `path:"action" module:"nokia-conf"`
	Cost   *uint32                                                     `path:"cost" module:"nokia-conf"`
	Value  *int32                                                      `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_PortThreshold implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_PortThreshold) IsYANGGoStruct() {}

// GetAction retrieves the value of the leaf Action from the NokiaConf_Configure_Groups_Group_Lag_PortThreshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Action is set, it can
// safely use t.GetAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Action == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_PortThreshold) GetAction() E_NokiaConf_Configure_Groups_Group_Lag_PortThreshold_Action {
	if t == nil || t.Action == 0 {
		return NokiaConf_Configure_Groups_Group_Lag_PortThreshold_Action_down
	}
	return t.Action
}

// GetCost retrieves the value of the leaf Cost from the NokiaConf_Configure_Groups_Group_Lag_PortThreshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cost is set, it can
// safely use t.GetCost() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cost == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_PortThreshold) GetCost() uint32 {
	if t == nil || t.Cost == nil {
		return 0
	}
	return *t.Cost
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Lag_PortThreshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_PortThreshold) GetValue() int32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_PortThreshold
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_PortThreshold) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Action == 0 {
		t.Action = NokiaConf_Configure_Groups_Group_Lag_PortThreshold_Action_down
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_PortThreshold) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_PortThreshold"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_PortThreshold) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_PortThreshold) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_PortThreshold.
func (*NokiaConf_Configure_Groups_Group_Lag_PortThreshold) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_Scheduler represents the /nokia-conf/configure/groups/group/lag/scheduler YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_Scheduler struct {
	Mode          E_NokiaConf_Configure_Groups_Group_Lag_Scheduler_Mode                    `path:"mode" module:"nokia-conf"`
	VlanQosPolicy map[string]*NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy `path:"vlan-qos-policy" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_Scheduler implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_Scheduler) IsYANGGoStruct() {}

// NewVlanQosPolicy creates a new entry in the VlanQosPolicy list of the
// NokiaConf_Configure_Groups_Group_Lag_Scheduler struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler) NewVlanQosPolicy(PolicyName string) (*NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VlanQosPolicy == nil {
		t.VlanQosPolicy = make(map[string]*NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy)
	}

	key := PolicyName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.VlanQosPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list VlanQosPolicy", key)
	}

	t.VlanQosPolicy[key] = &NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy{
		PolicyName: &PolicyName,
	}

	return t.VlanQosPolicy[key], nil
}

// RenameVlanQosPolicy renames an entry in the list VlanQosPolicy within
// the NokiaConf_Configure_Groups_Group_Lag_Scheduler struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler) RenameVlanQosPolicy(oldK, newK string) error {
	if _, ok := t.VlanQosPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in VlanQosPolicy", newK)
	}

	e, ok := t.VlanQosPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in VlanQosPolicy", oldK)
	}
	e.PolicyName = &newK

	t.VlanQosPolicy[newK] = e
	delete(t.VlanQosPolicy, oldK)
	return nil
}

// GetOrCreateVlanQosPolicy retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Lag_Scheduler. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler) GetOrCreateVlanQosPolicy(PolicyName string) *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy {

	key := PolicyName

	if v, ok := t.VlanQosPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVlanQosPolicy(PolicyName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVlanQosPolicy got unexpected error: %v", err))
	}
	return v
}

// GetVlanQosPolicy retrieves the value with the specified key from
// the VlanQosPolicy map field of NokiaConf_Configure_Groups_Group_Lag_Scheduler. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler) GetVlanQosPolicy(PolicyName string) *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy {

	if t == nil {
		return nil
	}

	key := PolicyName

	if lm, ok := t.VlanQosPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteVlanQosPolicy deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Lag_Scheduler. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler) DeleteVlanQosPolicy(PolicyName string) {
	key := PolicyName

	delete(t.VlanQosPolicy, key)
}

// AppendVlanQosPolicy appends the supplied NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy struct to the
// list VlanQosPolicy of NokiaConf_Configure_Groups_Group_Lag_Scheduler. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler) AppendVlanQosPolicy(v *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy) error {
	if v.PolicyName == nil {
		return fmt.Errorf("invalid nil key received for PolicyName")
	}

	key := *v.PolicyName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.VlanQosPolicy == nil {
		t.VlanQosPolicy = make(map[string]*NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy)
	}

	if _, ok := t.VlanQosPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list VlanQosPolicy %v", key)
	}

	t.VlanQosPolicy[key] = v
	return nil
}

// GetMode retrieves the value of the leaf Mode from the NokiaConf_Configure_Groups_Group_Lag_Scheduler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler) GetMode() E_NokiaConf_Configure_Groups_Group_Lag_Scheduler_Mode {
	if t == nil || t.Mode == 0 {
		return 0
	}
	return t.Mode
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_Scheduler
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.VlanQosPolicy {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_Scheduler"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_Scheduler.
func (*NokiaConf_Configure_Groups_Group_Lag_Scheduler) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy represents the /nokia-conf/configure/groups/group/lag/scheduler/vlan-qos-policy YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy struct {
	AggRate    *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate `path:"agg-rate" module:"nokia-conf"`
	PolicyName *string                                                               `path:"policy-name" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy) IsYANGGoStruct() {}

// GetOrCreateAggRate retrieves the value of the AggRate field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy) GetOrCreateAggRate() *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate {
	if t.AggRate != nil {
		return t.AggRate
	}
	t.AggRate = &NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate{}
	return t.AggRate
}

// GetAggRate returns the value of the AggRate struct pointer
// from NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy. If the receiver or the field AggRate is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy) GetAggRate() *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate {
	if t != nil && t.AggRate != nil {
		return t.AggRate
	}
	return nil
}

// GetPolicyName retrieves the value of the leaf PolicyName from the NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PolicyName is set, it can
// safely use t.GetPolicyName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PolicyName == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy) GetPolicyName() string {
	if t == nil || t.PolicyName == nil {
		return ""
	}
	return *t.PolicyName
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AggRate.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy) ΛListKeyMap() (map[string]interface{}, error) {
	if t.PolicyName == nil {
		return nil, fmt.Errorf("nil value for key PolicyName")
	}

	return map[string]interface{}{
		"policy-name": *t.PolicyName,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy.
func (*NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate represents the /nokia-conf/configure/groups/group/lag/scheduler/vlan-qos-policy/agg-rate YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate struct {
	Cir  NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate_Cir_Union `path:"cir" module:"nokia-conf"`
	Rate *int64                                                                         `path:"rate" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate) IsYANGGoStruct() {}

// GetCir retrieves the value of the leaf Cir from the NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cir is set, it can
// safely use t.GetCir() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cir == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate) GetCir() NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate_Cir_Union {
	if t == nil || t.Cir == nil {
		return UnionInt32(0)
	}
	return t.Cir
}

// GetRate retrieves the value of the leaf Rate from the NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Rate is set, it can
// safely use t.GetRate() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Rate == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate) GetRate() int64 {
	if t == nil || t.Rate == nil {
		return 0
	}
	return *t.Rate
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Cir == nil {
		t.Cir = UnionInt32(0)
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate.
func (*NokiaConf_Configure_Groups_Group_Lag_Scheduler_VlanQosPolicy_AggRate) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria represents the /nokia-conf/configure/groups/group/lag/selection-criteria YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria struct {
	Mode             E_NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria_Mode                 `path:"mode" module:"nokia-conf"`
	SlaveToPartner   *bool                                                                         `path:"slave-to-partner" module:"nokia-conf"`
	SubgroupHoldTime NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria_SubgroupHoldTime_Union `path:"subgroup-hold-time" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria) IsYANGGoStruct() {}

// GetMode retrieves the value of the leaf Mode from the NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Mode is set, it can
// safely use t.GetMode() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Mode == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria) GetMode() E_NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria_Mode {
	if t == nil || t.Mode == 0 {
		return NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria_Mode_highest_count
	}
	return t.Mode
}

// GetSlaveToPartner retrieves the value of the leaf SlaveToPartner from the NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SlaveToPartner is set, it can
// safely use t.GetSlaveToPartner() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SlaveToPartner == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria) GetSlaveToPartner() bool {
	if t == nil || t.SlaveToPartner == nil {
		return false
	}
	return *t.SlaveToPartner
}

// GetSubgroupHoldTime retrieves the value of the leaf SubgroupHoldTime from the NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SubgroupHoldTime is set, it can
// safely use t.GetSubgroupHoldTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SubgroupHoldTime == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria) GetSubgroupHoldTime() NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria_SubgroupHoldTime_Union {
	if t == nil || t.SubgroupHoldTime == nil {
		return UnionInt32(0)
	}
	return t.SubgroupHoldTime
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Mode == 0 {
		t.Mode = NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria_Mode_highest_count
	}
	if t.SlaveToPartner == nil {
		var v bool = false
		t.SlaveToPartner = &v
	}
	if t.SubgroupHoldTime == nil {
		t.SubgroupHoldTime = UnionInt32(0)
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria.
func (*NokiaConf_Configure_Groups_Group_Lag_SelectionCriteria) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Lag_WeightThreshold represents the /nokia-conf/configure/groups/group/lag/weight-threshold YANG schema element.
type NokiaConf_Configure_Groups_Group_Lag_WeightThreshold struct {
	Action E_NokiaConf_Configure_Groups_Group_Lag_WeightThreshold_Action `path:"action" module:"nokia-conf"`
	Cost   *uint32                                                       `path:"cost" module:"nokia-conf"`
	Value  *int32                                                        `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Lag_WeightThreshold implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Lag_WeightThreshold) IsYANGGoStruct() {}

// GetAction retrieves the value of the leaf Action from the NokiaConf_Configure_Groups_Group_Lag_WeightThreshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Action is set, it can
// safely use t.GetAction() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Action == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_WeightThreshold) GetAction() E_NokiaConf_Configure_Groups_Group_Lag_WeightThreshold_Action {
	if t == nil || t.Action == 0 {
		return NokiaConf_Configure_Groups_Group_Lag_WeightThreshold_Action_down
	}
	return t.Action
}

// GetCost retrieves the value of the leaf Cost from the NokiaConf_Configure_Groups_Group_Lag_WeightThreshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Cost is set, it can
// safely use t.GetCost() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Cost == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_WeightThreshold) GetCost() uint32 {
	if t == nil || t.Cost == nil {
		return 0
	}
	return *t.Cost
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Lag_WeightThreshold
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Lag_WeightThreshold) GetValue() int32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Lag_WeightThreshold
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Lag_WeightThreshold) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Action == 0 {
		t.Action = NokiaConf_Configure_Groups_Group_Lag_WeightThreshold_Action_down
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_WeightThreshold) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Lag_WeightThreshold"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Lag_WeightThreshold) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Lag_WeightThreshold) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Lag_WeightThreshold.
func (*NokiaConf_Configure_Groups_Group_Lag_WeightThreshold) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log represents the /nokia-conf/configure/groups/group/log YANG schema element.
type NokiaConf_Configure_Groups_Group_Log struct {
	AccountingPolicy      map[NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_PolicyId_Union]*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy `path:"accounting-policy" module:"nokia-conf"`
	AppRouteNotifications *NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications                                                                     `path:"app-route-notifications" module:"nokia-conf"`
	EventDamping          *bool                                                                                                                           `path:"event-damping" module:"nokia-conf"`
	EventHandling         *NokiaConf_Configure_Groups_Group_Log_EventHandling                                                                             `path:"event-handling" module:"nokia-conf"`
	EventTrigger          *NokiaConf_Configure_Groups_Group_Log_EventTrigger                                                                              `path:"event-trigger" module:"nokia-conf"`
	File                  map[string]*NokiaConf_Configure_Groups_Group_Log_File                                                                           `path:"file" module:"nokia-conf"`
	Filter                map[string]*NokiaConf_Configure_Groups_Group_Log_Filter                                                                         `path:"filter" module:"nokia-conf"`
	LogEvents             *NokiaConf_Configure_Groups_Group_Log_LogEvents                                                                                 `path:"log-events" module:"nokia-conf"`
	LogId                 map[string]*NokiaConf_Configure_Groups_Group_Log_LogId                                                                          `path:"log-id" module:"nokia-conf"`
	RoutePreference       *NokiaConf_Configure_Groups_Group_Log_RoutePreference                                                                           `path:"route-preference" module:"nokia-conf"`
	ServicesAllEvents     *NokiaConf_Configure_Groups_Group_Log_ServicesAllEvents                                                                         `path:"services-all-events" module:"nokia-conf"`
	SnmpTrapGroup         map[string]*NokiaConf_Configure_Groups_Group_Log_SnmpTrapGroup                                                                  `path:"snmp-trap-group" module:"nokia-conf"`
	Syslog                map[string]*NokiaConf_Configure_Groups_Group_Log_Syslog                                                                         `path:"syslog" module:"nokia-conf"`
	ThrottleRate          *NokiaConf_Configure_Groups_Group_Log_ThrottleRate                                                                              `path:"throttle-rate" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log) IsYANGGoStruct() {}

// NewAccountingPolicy creates a new entry in the AccountingPolicy list of the
// NokiaConf_Configure_Groups_Group_Log struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log) NewAccountingPolicy(PolicyId NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_PolicyId_Union) (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AccountingPolicy == nil {
		t.AccountingPolicy = make(map[NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_PolicyId_Union]*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy)
	}

	key := PolicyId

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AccountingPolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AccountingPolicy", key)
	}

	t.AccountingPolicy[key] = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy{
		PolicyId: PolicyId,
	}

	return t.AccountingPolicy[key], nil
}

// RenameAccountingPolicy renames an entry in the list AccountingPolicy within
// the NokiaConf_Configure_Groups_Group_Log struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log) RenameAccountingPolicy(oldK, newK NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_PolicyId_Union) error {
	if _, ok := t.AccountingPolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in AccountingPolicy", newK)
	}

	e, ok := t.AccountingPolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AccountingPolicy", oldK)
	}
	e.PolicyId = newK

	t.AccountingPolicy[newK] = e
	delete(t.AccountingPolicy, oldK)
	return nil
}

// GetOrCreateAccountingPolicy retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateAccountingPolicy(PolicyId NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_PolicyId_Union) *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy {

	key := PolicyId

	if v, ok := t.AccountingPolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAccountingPolicy(PolicyId)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAccountingPolicy got unexpected error: %v", err))
	}
	return v
}

// GetAccountingPolicy retrieves the value with the specified key from
// the AccountingPolicy map field of NokiaConf_Configure_Groups_Group_Log. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetAccountingPolicy(PolicyId NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_PolicyId_Union) *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy {

	if t == nil {
		return nil
	}

	key := PolicyId

	if lm, ok := t.AccountingPolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteAccountingPolicy deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log) DeleteAccountingPolicy(PolicyId NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_PolicyId_Union) {
	key := PolicyId

	delete(t.AccountingPolicy, key)
}

// AppendAccountingPolicy appends the supplied NokiaConf_Configure_Groups_Group_Log_AccountingPolicy struct to the
// list AccountingPolicy of NokiaConf_Configure_Groups_Group_Log. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_AccountingPolicy already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log) AppendAccountingPolicy(v *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) error {
	key := v.PolicyId

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AccountingPolicy == nil {
		t.AccountingPolicy = make(map[NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_PolicyId_Union]*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy)
	}

	if _, ok := t.AccountingPolicy[key]; ok {
		return fmt.Errorf("duplicate key for list AccountingPolicy %v", key)
	}

	t.AccountingPolicy[key] = v
	return nil
}

// NewFile creates a new entry in the File list of the
// NokiaConf_Configure_Groups_Group_Log struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log) NewFile(FilePolicyName string) (*NokiaConf_Configure_Groups_Group_Log_File, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.File == nil {
		t.File = make(map[string]*NokiaConf_Configure_Groups_Group_Log_File)
	}

	key := FilePolicyName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.File[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list File", key)
	}

	t.File[key] = &NokiaConf_Configure_Groups_Group_Log_File{
		FilePolicyName: &FilePolicyName,
	}

	return t.File[key], nil
}

// RenameFile renames an entry in the list File within
// the NokiaConf_Configure_Groups_Group_Log struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log) RenameFile(oldK, newK string) error {
	if _, ok := t.File[newK]; ok {
		return fmt.Errorf("key %v already exists in File", newK)
	}

	e, ok := t.File[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in File", oldK)
	}
	e.FilePolicyName = &newK

	t.File[newK] = e
	delete(t.File, oldK)
	return nil
}

// GetOrCreateFile retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateFile(FilePolicyName string) *NokiaConf_Configure_Groups_Group_Log_File {

	key := FilePolicyName

	if v, ok := t.File[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFile(FilePolicyName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFile got unexpected error: %v", err))
	}
	return v
}

// GetFile retrieves the value with the specified key from
// the File map field of NokiaConf_Configure_Groups_Group_Log. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetFile(FilePolicyName string) *NokiaConf_Configure_Groups_Group_Log_File {

	if t == nil {
		return nil
	}

	key := FilePolicyName

	if lm, ok := t.File[key]; ok {
		return lm
	}
	return nil
}

// DeleteFile deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log) DeleteFile(FilePolicyName string) {
	key := FilePolicyName

	delete(t.File, key)
}

// AppendFile appends the supplied NokiaConf_Configure_Groups_Group_Log_File struct to the
// list File of NokiaConf_Configure_Groups_Group_Log. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_File already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log) AppendFile(v *NokiaConf_Configure_Groups_Group_Log_File) error {
	if v.FilePolicyName == nil {
		return fmt.Errorf("invalid nil key received for FilePolicyName")
	}

	key := *v.FilePolicyName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.File == nil {
		t.File = make(map[string]*NokiaConf_Configure_Groups_Group_Log_File)
	}

	if _, ok := t.File[key]; ok {
		return fmt.Errorf("duplicate key for list File %v", key)
	}

	t.File[key] = v
	return nil
}

// NewFilter creates a new entry in the Filter list of the
// NokiaConf_Configure_Groups_Group_Log struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log) NewFilter(FilterName string) (*NokiaConf_Configure_Groups_Group_Log_Filter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Filter == nil {
		t.Filter = make(map[string]*NokiaConf_Configure_Groups_Group_Log_Filter)
	}

	key := FilterName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Filter", key)
	}

	t.Filter[key] = &NokiaConf_Configure_Groups_Group_Log_Filter{
		FilterName: &FilterName,
	}

	return t.Filter[key], nil
}

// RenameFilter renames an entry in the list Filter within
// the NokiaConf_Configure_Groups_Group_Log struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log) RenameFilter(oldK, newK string) error {
	if _, ok := t.Filter[newK]; ok {
		return fmt.Errorf("key %v already exists in Filter", newK)
	}

	e, ok := t.Filter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Filter", oldK)
	}
	e.FilterName = &newK

	t.Filter[newK] = e
	delete(t.Filter, oldK)
	return nil
}

// GetOrCreateFilter retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateFilter(FilterName string) *NokiaConf_Configure_Groups_Group_Log_Filter {

	key := FilterName

	if v, ok := t.Filter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFilter(FilterName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFilter got unexpected error: %v", err))
	}
	return v
}

// GetFilter retrieves the value with the specified key from
// the Filter map field of NokiaConf_Configure_Groups_Group_Log. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetFilter(FilterName string) *NokiaConf_Configure_Groups_Group_Log_Filter {

	if t == nil {
		return nil
	}

	key := FilterName

	if lm, ok := t.Filter[key]; ok {
		return lm
	}
	return nil
}

// DeleteFilter deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log) DeleteFilter(FilterName string) {
	key := FilterName

	delete(t.Filter, key)
}

// AppendFilter appends the supplied NokiaConf_Configure_Groups_Group_Log_Filter struct to the
// list Filter of NokiaConf_Configure_Groups_Group_Log. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_Filter already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log) AppendFilter(v *NokiaConf_Configure_Groups_Group_Log_Filter) error {
	if v.FilterName == nil {
		return fmt.Errorf("invalid nil key received for FilterName")
	}

	key := *v.FilterName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Filter == nil {
		t.Filter = make(map[string]*NokiaConf_Configure_Groups_Group_Log_Filter)
	}

	if _, ok := t.Filter[key]; ok {
		return fmt.Errorf("duplicate key for list Filter %v", key)
	}

	t.Filter[key] = v
	return nil
}

// NewLogId creates a new entry in the LogId list of the
// NokiaConf_Configure_Groups_Group_Log struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log) NewLogId(Name string) (*NokiaConf_Configure_Groups_Group_Log_LogId, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LogId == nil {
		t.LogId = make(map[string]*NokiaConf_Configure_Groups_Group_Log_LogId)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.LogId[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list LogId", key)
	}

	t.LogId[key] = &NokiaConf_Configure_Groups_Group_Log_LogId{
		Name: &Name,
	}

	return t.LogId[key], nil
}

// RenameLogId renames an entry in the list LogId within
// the NokiaConf_Configure_Groups_Group_Log struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log) RenameLogId(oldK, newK string) error {
	if _, ok := t.LogId[newK]; ok {
		return fmt.Errorf("key %v already exists in LogId", newK)
	}

	e, ok := t.LogId[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in LogId", oldK)
	}
	e.Name = &newK

	t.LogId[newK] = e
	delete(t.LogId, oldK)
	return nil
}

// GetOrCreateLogId retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateLogId(Name string) *NokiaConf_Configure_Groups_Group_Log_LogId {

	key := Name

	if v, ok := t.LogId[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLogId(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLogId got unexpected error: %v", err))
	}
	return v
}

// GetLogId retrieves the value with the specified key from
// the LogId map field of NokiaConf_Configure_Groups_Group_Log. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetLogId(Name string) *NokiaConf_Configure_Groups_Group_Log_LogId {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.LogId[key]; ok {
		return lm
	}
	return nil
}

// DeleteLogId deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log) DeleteLogId(Name string) {
	key := Name

	delete(t.LogId, key)
}

// AppendLogId appends the supplied NokiaConf_Configure_Groups_Group_Log_LogId struct to the
// list LogId of NokiaConf_Configure_Groups_Group_Log. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_LogId already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log) AppendLogId(v *NokiaConf_Configure_Groups_Group_Log_LogId) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.LogId == nil {
		t.LogId = make(map[string]*NokiaConf_Configure_Groups_Group_Log_LogId)
	}

	if _, ok := t.LogId[key]; ok {
		return fmt.Errorf("duplicate key for list LogId %v", key)
	}

	t.LogId[key] = v
	return nil
}

// NewSnmpTrapGroup creates a new entry in the SnmpTrapGroup list of the
// NokiaConf_Configure_Groups_Group_Log struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log) NewSnmpTrapGroup(LogName string) (*NokiaConf_Configure_Groups_Group_Log_SnmpTrapGroup, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SnmpTrapGroup == nil {
		t.SnmpTrapGroup = make(map[string]*NokiaConf_Configure_Groups_Group_Log_SnmpTrapGroup)
	}

	key := LogName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SnmpTrapGroup[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SnmpTrapGroup", key)
	}

	t.SnmpTrapGroup[key] = &NokiaConf_Configure_Groups_Group_Log_SnmpTrapGroup{
		LogName: &LogName,
	}

	return t.SnmpTrapGroup[key], nil
}

// RenameSnmpTrapGroup renames an entry in the list SnmpTrapGroup within
// the NokiaConf_Configure_Groups_Group_Log struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log) RenameSnmpTrapGroup(oldK, newK string) error {
	if _, ok := t.SnmpTrapGroup[newK]; ok {
		return fmt.Errorf("key %v already exists in SnmpTrapGroup", newK)
	}

	e, ok := t.SnmpTrapGroup[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SnmpTrapGroup", oldK)
	}
	e.LogName = &newK

	t.SnmpTrapGroup[newK] = e
	delete(t.SnmpTrapGroup, oldK)
	return nil
}

// GetOrCreateSnmpTrapGroup retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateSnmpTrapGroup(LogName string) *NokiaConf_Configure_Groups_Group_Log_SnmpTrapGroup {

	key := LogName

	if v, ok := t.SnmpTrapGroup[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSnmpTrapGroup(LogName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSnmpTrapGroup got unexpected error: %v", err))
	}
	return v
}

// GetSnmpTrapGroup retrieves the value with the specified key from
// the SnmpTrapGroup map field of NokiaConf_Configure_Groups_Group_Log. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetSnmpTrapGroup(LogName string) *NokiaConf_Configure_Groups_Group_Log_SnmpTrapGroup {

	if t == nil {
		return nil
	}

	key := LogName

	if lm, ok := t.SnmpTrapGroup[key]; ok {
		return lm
	}
	return nil
}

// DeleteSnmpTrapGroup deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log) DeleteSnmpTrapGroup(LogName string) {
	key := LogName

	delete(t.SnmpTrapGroup, key)
}

// AppendSnmpTrapGroup appends the supplied NokiaConf_Configure_Groups_Group_Log_SnmpTrapGroup struct to the
// list SnmpTrapGroup of NokiaConf_Configure_Groups_Group_Log. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_SnmpTrapGroup already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log) AppendSnmpTrapGroup(v *NokiaConf_Configure_Groups_Group_Log_SnmpTrapGroup) error {
	if v.LogName == nil {
		return fmt.Errorf("invalid nil key received for LogName")
	}

	key := *v.LogName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SnmpTrapGroup == nil {
		t.SnmpTrapGroup = make(map[string]*NokiaConf_Configure_Groups_Group_Log_SnmpTrapGroup)
	}

	if _, ok := t.SnmpTrapGroup[key]; ok {
		return fmt.Errorf("duplicate key for list SnmpTrapGroup %v", key)
	}

	t.SnmpTrapGroup[key] = v
	return nil
}

// NewSyslog creates a new entry in the Syslog list of the
// NokiaConf_Configure_Groups_Group_Log struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log) NewSyslog(SyslogName string) (*NokiaConf_Configure_Groups_Group_Log_Syslog, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Syslog == nil {
		t.Syslog = make(map[string]*NokiaConf_Configure_Groups_Group_Log_Syslog)
	}

	key := SyslogName

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Syslog[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Syslog", key)
	}

	t.Syslog[key] = &NokiaConf_Configure_Groups_Group_Log_Syslog{
		SyslogName: &SyslogName,
	}

	return t.Syslog[key], nil
}

// RenameSyslog renames an entry in the list Syslog within
// the NokiaConf_Configure_Groups_Group_Log struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log) RenameSyslog(oldK, newK string) error {
	if _, ok := t.Syslog[newK]; ok {
		return fmt.Errorf("key %v already exists in Syslog", newK)
	}

	e, ok := t.Syslog[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Syslog", oldK)
	}
	e.SyslogName = &newK

	t.Syslog[newK] = e
	delete(t.Syslog, oldK)
	return nil
}

// GetOrCreateSyslog retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateSyslog(SyslogName string) *NokiaConf_Configure_Groups_Group_Log_Syslog {

	key := SyslogName

	if v, ok := t.Syslog[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSyslog(SyslogName)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSyslog got unexpected error: %v", err))
	}
	return v
}

// GetSyslog retrieves the value with the specified key from
// the Syslog map field of NokiaConf_Configure_Groups_Group_Log. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetSyslog(SyslogName string) *NokiaConf_Configure_Groups_Group_Log_Syslog {

	if t == nil {
		return nil
	}

	key := SyslogName

	if lm, ok := t.Syslog[key]; ok {
		return lm
	}
	return nil
}

// DeleteSyslog deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log) DeleteSyslog(SyslogName string) {
	key := SyslogName

	delete(t.Syslog, key)
}

// AppendSyslog appends the supplied NokiaConf_Configure_Groups_Group_Log_Syslog struct to the
// list Syslog of NokiaConf_Configure_Groups_Group_Log. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_Syslog already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log) AppendSyslog(v *NokiaConf_Configure_Groups_Group_Log_Syslog) error {
	if v.SyslogName == nil {
		return fmt.Errorf("invalid nil key received for SyslogName")
	}

	key := *v.SyslogName

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Syslog == nil {
		t.Syslog = make(map[string]*NokiaConf_Configure_Groups_Group_Log_Syslog)
	}

	if _, ok := t.Syslog[key]; ok {
		return fmt.Errorf("duplicate key for list Syslog %v", key)
	}

	t.Syslog[key] = v
	return nil
}

// GetOrCreateAppRouteNotifications retrieves the value of the AppRouteNotifications field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateAppRouteNotifications() *NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications {
	if t.AppRouteNotifications != nil {
		return t.AppRouteNotifications
	}
	t.AppRouteNotifications = &NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications{}
	return t.AppRouteNotifications
}

// GetOrCreateEventHandling retrieves the value of the EventHandling field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateEventHandling() *NokiaConf_Configure_Groups_Group_Log_EventHandling {
	if t.EventHandling != nil {
		return t.EventHandling
	}
	t.EventHandling = &NokiaConf_Configure_Groups_Group_Log_EventHandling{}
	return t.EventHandling
}

// GetOrCreateEventTrigger retrieves the value of the EventTrigger field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateEventTrigger() *NokiaConf_Configure_Groups_Group_Log_EventTrigger {
	if t.EventTrigger != nil {
		return t.EventTrigger
	}
	t.EventTrigger = &NokiaConf_Configure_Groups_Group_Log_EventTrigger{}
	return t.EventTrigger
}

// GetOrCreateLogEvents retrieves the value of the LogEvents field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateLogEvents() *NokiaConf_Configure_Groups_Group_Log_LogEvents {
	if t.LogEvents != nil {
		return t.LogEvents
	}
	t.LogEvents = &NokiaConf_Configure_Groups_Group_Log_LogEvents{}
	return t.LogEvents
}

// GetOrCreateRoutePreference retrieves the value of the RoutePreference field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateRoutePreference() *NokiaConf_Configure_Groups_Group_Log_RoutePreference {
	if t.RoutePreference != nil {
		return t.RoutePreference
	}
	t.RoutePreference = &NokiaConf_Configure_Groups_Group_Log_RoutePreference{}
	return t.RoutePreference
}

// GetOrCreateServicesAllEvents retrieves the value of the ServicesAllEvents field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateServicesAllEvents() *NokiaConf_Configure_Groups_Group_Log_ServicesAllEvents {
	if t.ServicesAllEvents != nil {
		return t.ServicesAllEvents
	}
	t.ServicesAllEvents = &NokiaConf_Configure_Groups_Group_Log_ServicesAllEvents{}
	return t.ServicesAllEvents
}

// GetOrCreateThrottleRate retrieves the value of the ThrottleRate field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log) GetOrCreateThrottleRate() *NokiaConf_Configure_Groups_Group_Log_ThrottleRate {
	if t.ThrottleRate != nil {
		return t.ThrottleRate
	}
	t.ThrottleRate = &NokiaConf_Configure_Groups_Group_Log_ThrottleRate{}
	return t.ThrottleRate
}

// GetAppRouteNotifications returns the value of the AppRouteNotifications struct pointer
// from NokiaConf_Configure_Groups_Group_Log. If the receiver or the field AppRouteNotifications is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetAppRouteNotifications() *NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications {
	if t != nil && t.AppRouteNotifications != nil {
		return t.AppRouteNotifications
	}
	return nil
}

// GetEventHandling returns the value of the EventHandling struct pointer
// from NokiaConf_Configure_Groups_Group_Log. If the receiver or the field EventHandling is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetEventHandling() *NokiaConf_Configure_Groups_Group_Log_EventHandling {
	if t != nil && t.EventHandling != nil {
		return t.EventHandling
	}
	return nil
}

// GetEventTrigger returns the value of the EventTrigger struct pointer
// from NokiaConf_Configure_Groups_Group_Log. If the receiver or the field EventTrigger is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetEventTrigger() *NokiaConf_Configure_Groups_Group_Log_EventTrigger {
	if t != nil && t.EventTrigger != nil {
		return t.EventTrigger
	}
	return nil
}

// GetLogEvents returns the value of the LogEvents struct pointer
// from NokiaConf_Configure_Groups_Group_Log. If the receiver or the field LogEvents is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetLogEvents() *NokiaConf_Configure_Groups_Group_Log_LogEvents {
	if t != nil && t.LogEvents != nil {
		return t.LogEvents
	}
	return nil
}

// GetRoutePreference returns the value of the RoutePreference struct pointer
// from NokiaConf_Configure_Groups_Group_Log. If the receiver or the field RoutePreference is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetRoutePreference() *NokiaConf_Configure_Groups_Group_Log_RoutePreference {
	if t != nil && t.RoutePreference != nil {
		return t.RoutePreference
	}
	return nil
}

// GetServicesAllEvents returns the value of the ServicesAllEvents struct pointer
// from NokiaConf_Configure_Groups_Group_Log. If the receiver or the field ServicesAllEvents is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetServicesAllEvents() *NokiaConf_Configure_Groups_Group_Log_ServicesAllEvents {
	if t != nil && t.ServicesAllEvents != nil {
		return t.ServicesAllEvents
	}
	return nil
}

// GetThrottleRate returns the value of the ThrottleRate struct pointer
// from NokiaConf_Configure_Groups_Group_Log. If the receiver or the field ThrottleRate is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log) GetThrottleRate() *NokiaConf_Configure_Groups_Group_Log_ThrottleRate {
	if t != nil && t.ThrottleRate != nil {
		return t.ThrottleRate
	}
	return nil
}

// GetEventDamping retrieves the value of the leaf EventDamping from the NokiaConf_Configure_Groups_Group_Log
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if EventDamping is set, it can
// safely use t.GetEventDamping() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.EventDamping == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log) GetEventDamping() bool {
	if t == nil || t.EventDamping == nil {
		return true
	}
	return *t.EventDamping
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.EventDamping == nil {
		var v bool = true
		t.EventDamping = &v
	}
	t.AppRouteNotifications.PopulateDefaults()
	t.EventHandling.PopulateDefaults()
	t.EventTrigger.PopulateDefaults()
	t.LogEvents.PopulateDefaults()
	t.RoutePreference.PopulateDefaults()
	t.ServicesAllEvents.PopulateDefaults()
	t.ThrottleRate.PopulateDefaults()
	for _, e := range t.AccountingPolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.File {
		e.PopulateDefaults()
	}
	for _, e := range t.Filter {
		e.PopulateDefaults()
	}
	for _, e := range t.LogId {
		e.PopulateDefaults()
	}
	for _, e := range t.SnmpTrapGroup {
		e.PopulateDefaults()
	}
	for _, e := range t.Syslog {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log.
func (*NokiaConf_Configure_Groups_Group_Log) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy represents the /nokia-conf/configure/groups/group/log/accounting-policy YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy struct {
	AdminState         E_NokiaTypesSros_AdminState                                          `path:"admin-state" module:"nokia-conf"`
	Align              *bool                                                                `path:"align" module:"nokia-conf"`
	CollectionInterval *int32                                                               `path:"collection-interval" module:"nokia-conf"`
	CustomRecord       *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord  `path:"custom-record" module:"nokia-conf" yangPresence:"true"`
	Default            *bool                                                                `path:"default" module:"nokia-conf"`
	Description        *string                                                              `path:"description" module:"nokia-conf"`
	Destination        *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination   `path:"destination" module:"nokia-conf"`
	IncludeSystemInfo  *bool                                                                `path:"include-system-info" module:"nokia-conf"`
	PolicyId           NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_PolicyId_Union `path:"policy-id" module:"nokia-conf"`
	Record             E_NokiaTypesLog_AccountingRecordType                                 `path:"record" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) IsYANGGoStruct() {}

// GetOrCreateCustomRecord retrieves the value of the CustomRecord field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) GetOrCreateCustomRecord() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord {
	if t.CustomRecord != nil {
		return t.CustomRecord
	}
	t.CustomRecord = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord{}
	return t.CustomRecord
}

// GetOrCreateDestination retrieves the value of the Destination field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) GetOrCreateDestination() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination {
	if t.Destination != nil {
		return t.Destination
	}
	t.Destination = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination{}
	return t.Destination
}

// GetCustomRecord returns the value of the CustomRecord struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy. If the receiver or the field CustomRecord is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) GetCustomRecord() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord {
	if t != nil && t.CustomRecord != nil {
		return t.CustomRecord
	}
	return nil
}

// GetDestination returns the value of the Destination struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy. If the receiver or the field Destination is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) GetDestination() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination {
	if t != nil && t.Destination != nil {
		return t.Destination
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetAlign retrieves the value of the leaf Align from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Align is set, it can
// safely use t.GetAlign() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Align == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) GetAlign() bool {
	if t == nil || t.Align == nil {
		return false
	}
	return *t.Align
}

// GetCollectionInterval retrieves the value of the leaf CollectionInterval from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if CollectionInterval is set, it can
// safely use t.GetCollectionInterval() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.CollectionInterval == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) GetCollectionInterval() int32 {
	if t == nil || t.CollectionInterval == nil {
		return 0
	}
	return *t.CollectionInterval
}

// GetDefault retrieves the value of the leaf Default from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Default is set, it can
// safely use t.GetDefault() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Default == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) GetDefault() bool {
	if t == nil || t.Default == nil {
		return false
	}
	return *t.Default
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetIncludeSystemInfo retrieves the value of the leaf IncludeSystemInfo from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if IncludeSystemInfo is set, it can
// safely use t.GetIncludeSystemInfo() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.IncludeSystemInfo == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) GetIncludeSystemInfo() bool {
	if t == nil || t.IncludeSystemInfo == nil {
		return false
	}
	return *t.IncludeSystemInfo
}

// GetPolicyId retrieves the value of the leaf PolicyId from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PolicyId is set, it can
// safely use t.GetPolicyId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PolicyId == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) GetPolicyId() NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_PolicyId_Union {
	if t == nil || t.PolicyId == nil {
		return nil
	}
	return t.PolicyId
}

// GetRecord retrieves the value of the leaf Record from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Record is set, it can
// safely use t.GetRecord() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Record == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) GetRecord() E_NokiaTypesLog_AccountingRecordType {
	if t == nil || t.Record == 0 {
		return 0
	}
	return t.Record
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	if t.Align == nil {
		var v bool = false
		t.Align = &v
	}
	if t.Default == nil {
		var v bool = false
		t.Default = &v
	}
	if t.IncludeSystemInfo == nil {
		var v bool = false
		t.IncludeSystemInfo = &v
	}
	t.CustomRecord.PopulateDefaults()
	t.Destination.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"policy-id": t.PolicyId,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord struct {
	AaSpecific           *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific                                                                                                      `path:"aa-specific" module:"nokia-conf"`
	OverrideCounter      map[NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_Id_Union]*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter `path:"override-counter" module:"nokia-conf"`
	Policer              map[NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_Id_Union]*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer                 `path:"policer" module:"nokia-conf"`
	Queue                map[NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_Id_Union]*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue                     `path:"queue" module:"nokia-conf"`
	RefAaSpecificCounter *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter                                                                                            `path:"ref-aa-specific-counter" module:"nokia-conf"`
	RefOverrideCounter   *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter                                                                                              `path:"ref-override-counter" module:"nokia-conf"`
	RefPolicer           *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer                                                                                                      `path:"ref-policer" module:"nokia-conf"`
	RefQueue             *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue                                                                                                        `path:"ref-queue" module:"nokia-conf"`
	SignificantChange    *uint32                                                                                                                                                                             `path:"significant-change" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) IsYANGGoStruct() {}

// NewOverrideCounter creates a new entry in the OverrideCounter list of the
// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) NewOverrideCounter(Id NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.OverrideCounter == nil {
		t.OverrideCounter = make(map[NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_Id_Union]*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.OverrideCounter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list OverrideCounter", key)
	}

	t.OverrideCounter[key] = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter{
		Id: Id,
	}

	return t.OverrideCounter[key], nil
}

// RenameOverrideCounter renames an entry in the list OverrideCounter within
// the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) RenameOverrideCounter(oldK, newK NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_Id_Union) error {
	if _, ok := t.OverrideCounter[newK]; ok {
		return fmt.Errorf("key %v already exists in OverrideCounter", newK)
	}

	e, ok := t.OverrideCounter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in OverrideCounter", oldK)
	}
	e.Id = newK

	t.OverrideCounter[newK] = e
	delete(t.OverrideCounter, oldK)
	return nil
}

// GetOrCreateOverrideCounter retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetOrCreateOverrideCounter(Id NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_Id_Union) *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter {

	key := Id

	if v, ok := t.OverrideCounter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewOverrideCounter(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateOverrideCounter got unexpected error: %v", err))
	}
	return v
}

// GetOverrideCounter retrieves the value with the specified key from
// the OverrideCounter map field of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetOverrideCounter(Id NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_Id_Union) *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.OverrideCounter[key]; ok {
		return lm
	}
	return nil
}

// DeleteOverrideCounter deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) DeleteOverrideCounter(Id NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_Id_Union) {
	key := Id

	delete(t.OverrideCounter, key)
}

// AppendOverrideCounter appends the supplied NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter struct to the
// list OverrideCounter of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) AppendOverrideCounter(v *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.OverrideCounter == nil {
		t.OverrideCounter = make(map[NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_Id_Union]*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter)
	}

	if _, ok := t.OverrideCounter[key]; ok {
		return fmt.Errorf("duplicate key for list OverrideCounter %v", key)
	}

	t.OverrideCounter[key] = v
	return nil
}

// NewPolicer creates a new entry in the Policer list of the
// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) NewPolicer(Id NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policer == nil {
		t.Policer = make(map[NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_Id_Union]*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Policer[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Policer", key)
	}

	t.Policer[key] = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer{
		Id: Id,
	}

	return t.Policer[key], nil
}

// RenamePolicer renames an entry in the list Policer within
// the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) RenamePolicer(oldK, newK NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_Id_Union) error {
	if _, ok := t.Policer[newK]; ok {
		return fmt.Errorf("key %v already exists in Policer", newK)
	}

	e, ok := t.Policer[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Policer", oldK)
	}
	e.Id = newK

	t.Policer[newK] = e
	delete(t.Policer, oldK)
	return nil
}

// GetOrCreatePolicer retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetOrCreatePolicer(Id NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_Id_Union) *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer {

	key := Id

	if v, ok := t.Policer[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPolicer(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePolicer got unexpected error: %v", err))
	}
	return v
}

// GetPolicer retrieves the value with the specified key from
// the Policer map field of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetPolicer(Id NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_Id_Union) *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Policer[key]; ok {
		return lm
	}
	return nil
}

// DeletePolicer deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) DeletePolicer(Id NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_Id_Union) {
	key := Id

	delete(t.Policer, key)
}

// AppendPolicer appends the supplied NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer struct to the
// list Policer of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) AppendPolicer(v *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Policer == nil {
		t.Policer = make(map[NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_Id_Union]*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer)
	}

	if _, ok := t.Policer[key]; ok {
		return fmt.Errorf("duplicate key for list Policer %v", key)
	}

	t.Policer[key] = v
	return nil
}

// NewQueue creates a new entry in the Queue list of the
// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) NewQueue(Id NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_Id_Union]*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Queue[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Queue", key)
	}

	t.Queue[key] = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue{
		Id: Id,
	}

	return t.Queue[key], nil
}

// RenameQueue renames an entry in the list Queue within
// the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) RenameQueue(oldK, newK NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_Id_Union) error {
	if _, ok := t.Queue[newK]; ok {
		return fmt.Errorf("key %v already exists in Queue", newK)
	}

	e, ok := t.Queue[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Queue", oldK)
	}
	e.Id = newK

	t.Queue[newK] = e
	delete(t.Queue, oldK)
	return nil
}

// GetOrCreateQueue retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetOrCreateQueue(Id NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_Id_Union) *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue {

	key := Id

	if v, ok := t.Queue[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewQueue(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateQueue got unexpected error: %v", err))
	}
	return v
}

// GetQueue retrieves the value with the specified key from
// the Queue map field of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetQueue(Id NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_Id_Union) *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Queue[key]; ok {
		return lm
	}
	return nil
}

// DeleteQueue deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) DeleteQueue(Id NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_Id_Union) {
	key := Id

	delete(t.Queue, key)
}

// AppendQueue appends the supplied NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue struct to the
// list Queue of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) AppendQueue(v *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Queue == nil {
		t.Queue = make(map[NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_Id_Union]*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue)
	}

	if _, ok := t.Queue[key]; ok {
		return fmt.Errorf("duplicate key for list Queue %v", key)
	}

	t.Queue[key] = v
	return nil
}

// GetOrCreateAaSpecific retrieves the value of the AaSpecific field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetOrCreateAaSpecific() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific {
	if t.AaSpecific != nil {
		return t.AaSpecific
	}
	t.AaSpecific = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific{}
	return t.AaSpecific
}

// GetOrCreateRefAaSpecificCounter retrieves the value of the RefAaSpecificCounter field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetOrCreateRefAaSpecificCounter() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter {
	if t.RefAaSpecificCounter != nil {
		return t.RefAaSpecificCounter
	}
	t.RefAaSpecificCounter = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter{}
	return t.RefAaSpecificCounter
}

// GetOrCreateRefOverrideCounter retrieves the value of the RefOverrideCounter field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetOrCreateRefOverrideCounter() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter {
	if t.RefOverrideCounter != nil {
		return t.RefOverrideCounter
	}
	t.RefOverrideCounter = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter{}
	return t.RefOverrideCounter
}

// GetOrCreateRefPolicer retrieves the value of the RefPolicer field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetOrCreateRefPolicer() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer {
	if t.RefPolicer != nil {
		return t.RefPolicer
	}
	t.RefPolicer = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer{}
	return t.RefPolicer
}

// GetOrCreateRefQueue retrieves the value of the RefQueue field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetOrCreateRefQueue() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue {
	if t.RefQueue != nil {
		return t.RefQueue
	}
	t.RefQueue = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue{}
	return t.RefQueue
}

// GetAaSpecific returns the value of the AaSpecific struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the receiver or the field AaSpecific is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetAaSpecific() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific {
	if t != nil && t.AaSpecific != nil {
		return t.AaSpecific
	}
	return nil
}

// GetRefAaSpecificCounter returns the value of the RefAaSpecificCounter struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the receiver or the field RefAaSpecificCounter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetRefAaSpecificCounter() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter {
	if t != nil && t.RefAaSpecificCounter != nil {
		return t.RefAaSpecificCounter
	}
	return nil
}

// GetRefOverrideCounter returns the value of the RefOverrideCounter struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the receiver or the field RefOverrideCounter is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetRefOverrideCounter() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter {
	if t != nil && t.RefOverrideCounter != nil {
		return t.RefOverrideCounter
	}
	return nil
}

// GetRefPolicer returns the value of the RefPolicer struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the receiver or the field RefPolicer is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetRefPolicer() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer {
	if t != nil && t.RefPolicer != nil {
		return t.RefPolicer
	}
	return nil
}

// GetRefQueue returns the value of the RefQueue struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord. If the receiver or the field RefQueue is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetRefQueue() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue {
	if t != nil && t.RefQueue != nil {
		return t.RefQueue
	}
	return nil
}

// GetSignificantChange retrieves the value of the leaf SignificantChange from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if SignificantChange is set, it can
// safely use t.GetSignificantChange() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.SignificantChange == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) GetSignificantChange() uint32 {
	if t == nil || t.SignificantChange == nil {
		return 0
	}
	return *t.SignificantChange
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AaSpecific.PopulateDefaults()
	t.RefAaSpecificCounter.PopulateDefaults()
	t.RefOverrideCounter.PopulateDefaults()
	t.RefPolicer.PopulateDefaults()
	t.RefQueue.PopulateDefaults()
	for _, e := range t.OverrideCounter {
		e.PopulateDefaults()
	}
	for _, e := range t.Policer {
		e.PopulateDefaults()
	}
	for _, e := range t.Queue {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/aa-specific YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific struct {
	AaSubAttributes   *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes   `path:"aa-sub-attributes" module:"nokia-conf"`
	AaSubCounters     *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters     `path:"aa-sub-counters" module:"nokia-conf"`
	FromAaSubCounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters `path:"from-aa-sub-counters" module:"nokia-conf"`
	ToAaSubCounters   *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters   `path:"to-aa-sub-counters" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) IsYANGGoStruct() {
}

// GetOrCreateAaSubAttributes retrieves the value of the AaSubAttributes field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) GetOrCreateAaSubAttributes() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes {
	if t.AaSubAttributes != nil {
		return t.AaSubAttributes
	}
	t.AaSubAttributes = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes{}
	return t.AaSubAttributes
}

// GetOrCreateAaSubCounters retrieves the value of the AaSubCounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) GetOrCreateAaSubCounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters {
	if t.AaSubCounters != nil {
		return t.AaSubCounters
	}
	t.AaSubCounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters{}
	return t.AaSubCounters
}

// GetOrCreateFromAaSubCounters retrieves the value of the FromAaSubCounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) GetOrCreateFromAaSubCounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters {
	if t.FromAaSubCounters != nil {
		return t.FromAaSubCounters
	}
	t.FromAaSubCounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters{}
	return t.FromAaSubCounters
}

// GetOrCreateToAaSubCounters retrieves the value of the ToAaSubCounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) GetOrCreateToAaSubCounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters {
	if t.ToAaSubCounters != nil {
		return t.ToAaSubCounters
	}
	t.ToAaSubCounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters{}
	return t.ToAaSubCounters
}

// GetAaSubAttributes returns the value of the AaSubAttributes struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific. If the receiver or the field AaSubAttributes is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) GetAaSubAttributes() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes {
	if t != nil && t.AaSubAttributes != nil {
		return t.AaSubAttributes
	}
	return nil
}

// GetAaSubCounters returns the value of the AaSubCounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific. If the receiver or the field AaSubCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) GetAaSubCounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters {
	if t != nil && t.AaSubCounters != nil {
		return t.AaSubCounters
	}
	return nil
}

// GetFromAaSubCounters returns the value of the FromAaSubCounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific. If the receiver or the field FromAaSubCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) GetFromAaSubCounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters {
	if t != nil && t.FromAaSubCounters != nil {
		return t.FromAaSubCounters
	}
	return nil
}

// GetToAaSubCounters returns the value of the ToAaSubCounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific. If the receiver or the field ToAaSubCounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) GetToAaSubCounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters {
	if t != nil && t.ToAaSubCounters != nil {
		return t.ToAaSubCounters
	}
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.AaSubAttributes.PopulateDefaults()
	t.AaSubCounters.PopulateDefaults()
	t.FromAaSubCounters.PopulateDefaults()
	t.ToAaSubCounters.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/aa-specific/aa-sub-attributes YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes struct {
	AppProfile        *bool `path:"app-profile" module:"nokia-conf"`
	AppServiceOptions *bool `path:"app-service-options" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes) IsYANGGoStruct() {
}

// GetAppProfile retrieves the value of the leaf AppProfile from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AppProfile is set, it can
// safely use t.GetAppProfile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AppProfile == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes) GetAppProfile() bool {
	if t == nil || t.AppProfile == nil {
		return false
	}
	return *t.AppProfile
}

// GetAppServiceOptions retrieves the value of the leaf AppServiceOptions from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AppServiceOptions is set, it can
// safely use t.GetAppServiceOptions() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AppServiceOptions == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes) GetAppServiceOptions() bool {
	if t == nil || t.AppServiceOptions == nil {
		return false
	}
	return *t.AppServiceOptions
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AppProfile == nil {
		var v bool = false
		t.AppProfile = &v
	}
	if t.AppServiceOptions == nil {
		var v bool = false
		t.AppServiceOptions = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubAttributes) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/aa-specific/aa-sub-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters struct {
	LongDurationFlowCount    *bool `path:"long-duration-flow-count" module:"nokia-conf"`
	MediumDurationFlowCount  *bool `path:"medium-duration-flow-count" module:"nokia-conf"`
	ShortDurationFlowCount   *bool `path:"short-duration-flow-count" module:"nokia-conf"`
	TotalFlowDuration        *bool `path:"total-flow-duration" module:"nokia-conf"`
	TotalFlowsCompletedCount *bool `path:"total-flows-completed-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters) IsYANGGoStruct() {
}

// GetLongDurationFlowCount retrieves the value of the leaf LongDurationFlowCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LongDurationFlowCount is set, it can
// safely use t.GetLongDurationFlowCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LongDurationFlowCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters) GetLongDurationFlowCount() bool {
	if t == nil || t.LongDurationFlowCount == nil {
		return false
	}
	return *t.LongDurationFlowCount
}

// GetMediumDurationFlowCount retrieves the value of the leaf MediumDurationFlowCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MediumDurationFlowCount is set, it can
// safely use t.GetMediumDurationFlowCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MediumDurationFlowCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters) GetMediumDurationFlowCount() bool {
	if t == nil || t.MediumDurationFlowCount == nil {
		return false
	}
	return *t.MediumDurationFlowCount
}

// GetShortDurationFlowCount retrieves the value of the leaf ShortDurationFlowCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ShortDurationFlowCount is set, it can
// safely use t.GetShortDurationFlowCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ShortDurationFlowCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters) GetShortDurationFlowCount() bool {
	if t == nil || t.ShortDurationFlowCount == nil {
		return false
	}
	return *t.ShortDurationFlowCount
}

// GetTotalFlowDuration retrieves the value of the leaf TotalFlowDuration from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalFlowDuration is set, it can
// safely use t.GetTotalFlowDuration() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalFlowDuration == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters) GetTotalFlowDuration() bool {
	if t == nil || t.TotalFlowDuration == nil {
		return false
	}
	return *t.TotalFlowDuration
}

// GetTotalFlowsCompletedCount retrieves the value of the leaf TotalFlowsCompletedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if TotalFlowsCompletedCount is set, it can
// safely use t.GetTotalFlowsCompletedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.TotalFlowsCompletedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters) GetTotalFlowsCompletedCount() bool {
	if t == nil || t.TotalFlowsCompletedCount == nil {
		return false
	}
	return *t.TotalFlowsCompletedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.LongDurationFlowCount == nil {
		var v bool = false
		t.LongDurationFlowCount = &v
	}
	if t.MediumDurationFlowCount == nil {
		var v bool = false
		t.MediumDurationFlowCount = &v
	}
	if t.ShortDurationFlowCount == nil {
		var v bool = false
		t.ShortDurationFlowCount = &v
	}
	if t.TotalFlowDuration == nil {
		var v bool = false
		t.TotalFlowDuration = &v
	}
	if t.TotalFlowsCompletedCount == nil {
		var v bool = false
		t.TotalFlowsCompletedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_AaSubCounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/aa-specific/from-aa-sub-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters struct {
	FlowsActiveCount         *bool `path:"flows-active-count" module:"nokia-conf"`
	FlowsAdmittedCount       *bool `path:"flows-admitted-count" module:"nokia-conf"`
	FlowsDeniedCount         *bool `path:"flows-denied-count" module:"nokia-conf"`
	ForwardingClass          *bool `path:"forwarding-class" module:"nokia-conf"`
	MaxThroughputOctetCount  *bool `path:"max-throughput-octet-count" module:"nokia-conf"`
	MaxThroughputPacketCount *bool `path:"max-throughput-packet-count" module:"nokia-conf"`
	MaxThroughputTimestamp   *bool `path:"max-throughput-timestamp" module:"nokia-conf"`
	OctetsAdmittedCount      *bool `path:"octets-admitted-count" module:"nokia-conf"`
	OctetsDeniedCount        *bool `path:"octets-denied-count" module:"nokia-conf"`
	PacketsAdmittedCount     *bool `path:"packets-admitted-count" module:"nokia-conf"`
	PacketsDeniedCount       *bool `path:"packets-denied-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) IsYANGGoStruct() {
}

// GetFlowsActiveCount retrieves the value of the leaf FlowsActiveCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlowsActiveCount is set, it can
// safely use t.GetFlowsActiveCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlowsActiveCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) GetFlowsActiveCount() bool {
	if t == nil || t.FlowsActiveCount == nil {
		return false
	}
	return *t.FlowsActiveCount
}

// GetFlowsAdmittedCount retrieves the value of the leaf FlowsAdmittedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlowsAdmittedCount is set, it can
// safely use t.GetFlowsAdmittedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlowsAdmittedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) GetFlowsAdmittedCount() bool {
	if t == nil || t.FlowsAdmittedCount == nil {
		return false
	}
	return *t.FlowsAdmittedCount
}

// GetFlowsDeniedCount retrieves the value of the leaf FlowsDeniedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlowsDeniedCount is set, it can
// safely use t.GetFlowsDeniedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlowsDeniedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) GetFlowsDeniedCount() bool {
	if t == nil || t.FlowsDeniedCount == nil {
		return false
	}
	return *t.FlowsDeniedCount
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) GetForwardingClass() bool {
	if t == nil || t.ForwardingClass == nil {
		return false
	}
	return *t.ForwardingClass
}

// GetMaxThroughputOctetCount retrieves the value of the leaf MaxThroughputOctetCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxThroughputOctetCount is set, it can
// safely use t.GetMaxThroughputOctetCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxThroughputOctetCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) GetMaxThroughputOctetCount() bool {
	if t == nil || t.MaxThroughputOctetCount == nil {
		return false
	}
	return *t.MaxThroughputOctetCount
}

// GetMaxThroughputPacketCount retrieves the value of the leaf MaxThroughputPacketCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxThroughputPacketCount is set, it can
// safely use t.GetMaxThroughputPacketCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxThroughputPacketCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) GetMaxThroughputPacketCount() bool {
	if t == nil || t.MaxThroughputPacketCount == nil {
		return false
	}
	return *t.MaxThroughputPacketCount
}

// GetMaxThroughputTimestamp retrieves the value of the leaf MaxThroughputTimestamp from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxThroughputTimestamp is set, it can
// safely use t.GetMaxThroughputTimestamp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxThroughputTimestamp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) GetMaxThroughputTimestamp() bool {
	if t == nil || t.MaxThroughputTimestamp == nil {
		return false
	}
	return *t.MaxThroughputTimestamp
}

// GetOctetsAdmittedCount retrieves the value of the leaf OctetsAdmittedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsAdmittedCount is set, it can
// safely use t.GetOctetsAdmittedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsAdmittedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) GetOctetsAdmittedCount() bool {
	if t == nil || t.OctetsAdmittedCount == nil {
		return false
	}
	return *t.OctetsAdmittedCount
}

// GetOctetsDeniedCount retrieves the value of the leaf OctetsDeniedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsDeniedCount is set, it can
// safely use t.GetOctetsDeniedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsDeniedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) GetOctetsDeniedCount() bool {
	if t == nil || t.OctetsDeniedCount == nil {
		return false
	}
	return *t.OctetsDeniedCount
}

// GetPacketsAdmittedCount retrieves the value of the leaf PacketsAdmittedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsAdmittedCount is set, it can
// safely use t.GetPacketsAdmittedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsAdmittedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) GetPacketsAdmittedCount() bool {
	if t == nil || t.PacketsAdmittedCount == nil {
		return false
	}
	return *t.PacketsAdmittedCount
}

// GetPacketsDeniedCount retrieves the value of the leaf PacketsDeniedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsDeniedCount is set, it can
// safely use t.GetPacketsDeniedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsDeniedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) GetPacketsDeniedCount() bool {
	if t == nil || t.PacketsDeniedCount == nil {
		return false
	}
	return *t.PacketsDeniedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FlowsActiveCount == nil {
		var v bool = false
		t.FlowsActiveCount = &v
	}
	if t.FlowsAdmittedCount == nil {
		var v bool = false
		t.FlowsAdmittedCount = &v
	}
	if t.FlowsDeniedCount == nil {
		var v bool = false
		t.FlowsDeniedCount = &v
	}
	if t.ForwardingClass == nil {
		var v bool = false
		t.ForwardingClass = &v
	}
	if t.MaxThroughputOctetCount == nil {
		var v bool = false
		t.MaxThroughputOctetCount = &v
	}
	if t.MaxThroughputPacketCount == nil {
		var v bool = false
		t.MaxThroughputPacketCount = &v
	}
	if t.MaxThroughputTimestamp == nil {
		var v bool = false
		t.MaxThroughputTimestamp = &v
	}
	if t.OctetsAdmittedCount == nil {
		var v bool = false
		t.OctetsAdmittedCount = &v
	}
	if t.OctetsDeniedCount == nil {
		var v bool = false
		t.OctetsDeniedCount = &v
	}
	if t.PacketsAdmittedCount == nil {
		var v bool = false
		t.PacketsAdmittedCount = &v
	}
	if t.PacketsDeniedCount == nil {
		var v bool = false
		t.PacketsDeniedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_FromAaSubCounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/aa-specific/to-aa-sub-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters struct {
	FlowsActiveCount         *bool `path:"flows-active-count" module:"nokia-conf"`
	FlowsAdmittedCount       *bool `path:"flows-admitted-count" module:"nokia-conf"`
	FlowsDeniedCount         *bool `path:"flows-denied-count" module:"nokia-conf"`
	ForwardingClass          *bool `path:"forwarding-class" module:"nokia-conf"`
	MaxThroughputOctetCount  *bool `path:"max-throughput-octet-count" module:"nokia-conf"`
	MaxThroughputPacketCount *bool `path:"max-throughput-packet-count" module:"nokia-conf"`
	MaxThroughputTimestamp   *bool `path:"max-throughput-timestamp" module:"nokia-conf"`
	OctetsAdmittedCount      *bool `path:"octets-admitted-count" module:"nokia-conf"`
	OctetsDeniedCount        *bool `path:"octets-denied-count" module:"nokia-conf"`
	PacketsAdmittedCount     *bool `path:"packets-admitted-count" module:"nokia-conf"`
	PacketsDeniedCount       *bool `path:"packets-denied-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) IsYANGGoStruct() {
}

// GetFlowsActiveCount retrieves the value of the leaf FlowsActiveCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlowsActiveCount is set, it can
// safely use t.GetFlowsActiveCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlowsActiveCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) GetFlowsActiveCount() bool {
	if t == nil || t.FlowsActiveCount == nil {
		return false
	}
	return *t.FlowsActiveCount
}

// GetFlowsAdmittedCount retrieves the value of the leaf FlowsAdmittedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlowsAdmittedCount is set, it can
// safely use t.GetFlowsAdmittedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlowsAdmittedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) GetFlowsAdmittedCount() bool {
	if t == nil || t.FlowsAdmittedCount == nil {
		return false
	}
	return *t.FlowsAdmittedCount
}

// GetFlowsDeniedCount retrieves the value of the leaf FlowsDeniedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if FlowsDeniedCount is set, it can
// safely use t.GetFlowsDeniedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.FlowsDeniedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) GetFlowsDeniedCount() bool {
	if t == nil || t.FlowsDeniedCount == nil {
		return false
	}
	return *t.FlowsDeniedCount
}

// GetForwardingClass retrieves the value of the leaf ForwardingClass from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ForwardingClass is set, it can
// safely use t.GetForwardingClass() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ForwardingClass == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) GetForwardingClass() bool {
	if t == nil || t.ForwardingClass == nil {
		return false
	}
	return *t.ForwardingClass
}

// GetMaxThroughputOctetCount retrieves the value of the leaf MaxThroughputOctetCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxThroughputOctetCount is set, it can
// safely use t.GetMaxThroughputOctetCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxThroughputOctetCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) GetMaxThroughputOctetCount() bool {
	if t == nil || t.MaxThroughputOctetCount == nil {
		return false
	}
	return *t.MaxThroughputOctetCount
}

// GetMaxThroughputPacketCount retrieves the value of the leaf MaxThroughputPacketCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxThroughputPacketCount is set, it can
// safely use t.GetMaxThroughputPacketCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxThroughputPacketCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) GetMaxThroughputPacketCount() bool {
	if t == nil || t.MaxThroughputPacketCount == nil {
		return false
	}
	return *t.MaxThroughputPacketCount
}

// GetMaxThroughputTimestamp retrieves the value of the leaf MaxThroughputTimestamp from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MaxThroughputTimestamp is set, it can
// safely use t.GetMaxThroughputTimestamp() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MaxThroughputTimestamp == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) GetMaxThroughputTimestamp() bool {
	if t == nil || t.MaxThroughputTimestamp == nil {
		return false
	}
	return *t.MaxThroughputTimestamp
}

// GetOctetsAdmittedCount retrieves the value of the leaf OctetsAdmittedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsAdmittedCount is set, it can
// safely use t.GetOctetsAdmittedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsAdmittedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) GetOctetsAdmittedCount() bool {
	if t == nil || t.OctetsAdmittedCount == nil {
		return false
	}
	return *t.OctetsAdmittedCount
}

// GetOctetsDeniedCount retrieves the value of the leaf OctetsDeniedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OctetsDeniedCount is set, it can
// safely use t.GetOctetsDeniedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OctetsDeniedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) GetOctetsDeniedCount() bool {
	if t == nil || t.OctetsDeniedCount == nil {
		return false
	}
	return *t.OctetsDeniedCount
}

// GetPacketsAdmittedCount retrieves the value of the leaf PacketsAdmittedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsAdmittedCount is set, it can
// safely use t.GetPacketsAdmittedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsAdmittedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) GetPacketsAdmittedCount() bool {
	if t == nil || t.PacketsAdmittedCount == nil {
		return false
	}
	return *t.PacketsAdmittedCount
}

// GetPacketsDeniedCount retrieves the value of the leaf PacketsDeniedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if PacketsDeniedCount is set, it can
// safely use t.GetPacketsDeniedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.PacketsDeniedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) GetPacketsDeniedCount() bool {
	if t == nil || t.PacketsDeniedCount == nil {
		return false
	}
	return *t.PacketsDeniedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.FlowsActiveCount == nil {
		var v bool = false
		t.FlowsActiveCount = &v
	}
	if t.FlowsAdmittedCount == nil {
		var v bool = false
		t.FlowsAdmittedCount = &v
	}
	if t.FlowsDeniedCount == nil {
		var v bool = false
		t.FlowsDeniedCount = &v
	}
	if t.ForwardingClass == nil {
		var v bool = false
		t.ForwardingClass = &v
	}
	if t.MaxThroughputOctetCount == nil {
		var v bool = false
		t.MaxThroughputOctetCount = &v
	}
	if t.MaxThroughputPacketCount == nil {
		var v bool = false
		t.MaxThroughputPacketCount = &v
	}
	if t.MaxThroughputTimestamp == nil {
		var v bool = false
		t.MaxThroughputTimestamp = &v
	}
	if t.OctetsAdmittedCount == nil {
		var v bool = false
		t.OctetsAdmittedCount = &v
	}
	if t.OctetsDeniedCount == nil {
		var v bool = false
		t.OctetsDeniedCount = &v
	}
	if t.PacketsAdmittedCount == nil {
		var v bool = false
		t.PacketsAdmittedCount = &v
	}
	if t.PacketsDeniedCount == nil {
		var v bool = false
		t.PacketsDeniedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_AaSpecific_ToAaSubCounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/override-counter YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter struct {
	ECounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters `path:"e-counters" module:"nokia-conf"`
	ICounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters `path:"i-counters" module:"nokia-conf"`
	Id        NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_Id_Union   `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) IsYANGGoStruct() {
}

// GetOrCreateECounters retrieves the value of the ECounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) GetOrCreateECounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters {
	if t.ECounters != nil {
		return t.ECounters
	}
	t.ECounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters{}
	return t.ECounters
}

// GetOrCreateICounters retrieves the value of the ICounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) GetOrCreateICounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters {
	if t.ICounters != nil {
		return t.ICounters
	}
	t.ICounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters{}
	return t.ICounters
}

// GetECounters returns the value of the ECounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter. If the receiver or the field ECounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) GetECounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters {
	if t != nil && t.ECounters != nil {
		return t.ECounters
	}
	return nil
}

// GetICounters returns the value of the ICounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter. If the receiver or the field ICounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) GetICounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters {
	if t != nil && t.ICounters != nil {
		return t.ICounters
	}
	return nil
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) GetId() NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ECounters.PopulateDefaults()
	t.ICounters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/override-counter/e-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters struct {
	InProfileOctetsDiscardedCount   *bool `path:"in-profile-octets-discarded-count" module:"nokia-conf"`
	InProfileOctetsForwardedCount   *bool `path:"in-profile-octets-forwarded-count" module:"nokia-conf"`
	InProfilePacketsDiscardedCount  *bool `path:"in-profile-packets-discarded-count" module:"nokia-conf"`
	InProfilePacketsForwardedCount  *bool `path:"in-profile-packets-forwarded-count" module:"nokia-conf"`
	OutProfileOctetsDiscardedCount  *bool `path:"out-profile-octets-discarded-count" module:"nokia-conf"`
	OutProfileOctetsForwardedCount  *bool `path:"out-profile-octets-forwarded-count" module:"nokia-conf"`
	OutProfilePacketsDiscardedCount *bool `path:"out-profile-packets-discarded-count" module:"nokia-conf"`
	OutProfilePacketsForwardedCount *bool `path:"out-profile-packets-forwarded-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) IsYANGGoStruct() {
}

// GetInProfileOctetsDiscardedCount retrieves the value of the leaf InProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsDiscardedCount is set, it can
// safely use t.GetInProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) GetInProfileOctetsDiscardedCount() bool {
	if t == nil || t.InProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.InProfileOctetsDiscardedCount
}

// GetInProfileOctetsForwardedCount retrieves the value of the leaf InProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsForwardedCount is set, it can
// safely use t.GetInProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) GetInProfileOctetsForwardedCount() bool {
	if t == nil || t.InProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InProfileOctetsForwardedCount
}

// GetInProfilePacketsDiscardedCount retrieves the value of the leaf InProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsDiscardedCount is set, it can
// safely use t.GetInProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) GetInProfilePacketsDiscardedCount() bool {
	if t == nil || t.InProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.InProfilePacketsDiscardedCount
}

// GetInProfilePacketsForwardedCount retrieves the value of the leaf InProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsForwardedCount is set, it can
// safely use t.GetInProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) GetInProfilePacketsForwardedCount() bool {
	if t == nil || t.InProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InProfilePacketsForwardedCount
}

// GetOutProfileOctetsDiscardedCount retrieves the value of the leaf OutProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsDiscardedCount is set, it can
// safely use t.GetOutProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) GetOutProfileOctetsDiscardedCount() bool {
	if t == nil || t.OutProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsDiscardedCount
}

// GetOutProfileOctetsForwardedCount retrieves the value of the leaf OutProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsForwardedCount is set, it can
// safely use t.GetOutProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) GetOutProfileOctetsForwardedCount() bool {
	if t == nil || t.OutProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsForwardedCount
}

// GetOutProfilePacketsDiscardedCount retrieves the value of the leaf OutProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsDiscardedCount is set, it can
// safely use t.GetOutProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) GetOutProfilePacketsDiscardedCount() bool {
	if t == nil || t.OutProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsDiscardedCount
}

// GetOutProfilePacketsForwardedCount retrieves the value of the leaf OutProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsForwardedCount is set, it can
// safely use t.GetOutProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) GetOutProfilePacketsForwardedCount() bool {
	if t == nil || t.OutProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsForwardedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.InProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.InProfileOctetsDiscardedCount = &v
	}
	if t.InProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InProfileOctetsForwardedCount = &v
	}
	if t.InProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.InProfilePacketsDiscardedCount = &v
	}
	if t.InProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InProfilePacketsForwardedCount = &v
	}
	if t.OutProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.OutProfileOctetsDiscardedCount = &v
	}
	if t.OutProfileOctetsForwardedCount == nil {
		var v bool = false
		t.OutProfileOctetsForwardedCount = &v
	}
	if t.OutProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.OutProfilePacketsDiscardedCount = &v
	}
	if t.OutProfilePacketsForwardedCount == nil {
		var v bool = false
		t.OutProfilePacketsForwardedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ECounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/override-counter/i-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters struct {
	AllOctetsOfferedCount           *bool `path:"all-octets-offered-count" module:"nokia-conf"`
	AllPacketsOfferedCount          *bool `path:"all-packets-offered-count" module:"nokia-conf"`
	HighOctetsDiscardedCount        *bool `path:"high-octets-discarded-count" module:"nokia-conf"`
	HighPacketsDiscardedCount       *bool `path:"high-packets-discarded-count" module:"nokia-conf"`
	InProfileOctetsForwardedCount   *bool `path:"in-profile-octets-forwarded-count" module:"nokia-conf"`
	InProfilePacketsForwardedCount  *bool `path:"in-profile-packets-forwarded-count" module:"nokia-conf"`
	LowOctetsDiscardedCount         *bool `path:"low-octets-discarded-count" module:"nokia-conf"`
	LowPacketsDiscardedCount        *bool `path:"low-packets-discarded-count" module:"nokia-conf"`
	OutProfileOctetsForwardedCount  *bool `path:"out-profile-octets-forwarded-count" module:"nokia-conf"`
	OutProfilePacketsForwardedCount *bool `path:"out-profile-packets-forwarded-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) IsYANGGoStruct() {
}

// GetAllOctetsOfferedCount retrieves the value of the leaf AllOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllOctetsOfferedCount is set, it can
// safely use t.GetAllOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) GetAllOctetsOfferedCount() bool {
	if t == nil || t.AllOctetsOfferedCount == nil {
		return false
	}
	return *t.AllOctetsOfferedCount
}

// GetAllPacketsOfferedCount retrieves the value of the leaf AllPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllPacketsOfferedCount is set, it can
// safely use t.GetAllPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) GetAllPacketsOfferedCount() bool {
	if t == nil || t.AllPacketsOfferedCount == nil {
		return false
	}
	return *t.AllPacketsOfferedCount
}

// GetHighOctetsDiscardedCount retrieves the value of the leaf HighOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighOctetsDiscardedCount is set, it can
// safely use t.GetHighOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) GetHighOctetsDiscardedCount() bool {
	if t == nil || t.HighOctetsDiscardedCount == nil {
		return false
	}
	return *t.HighOctetsDiscardedCount
}

// GetHighPacketsDiscardedCount retrieves the value of the leaf HighPacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighPacketsDiscardedCount is set, it can
// safely use t.GetHighPacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighPacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) GetHighPacketsDiscardedCount() bool {
	if t == nil || t.HighPacketsDiscardedCount == nil {
		return false
	}
	return *t.HighPacketsDiscardedCount
}

// GetInProfileOctetsForwardedCount retrieves the value of the leaf InProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsForwardedCount is set, it can
// safely use t.GetInProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) GetInProfileOctetsForwardedCount() bool {
	if t == nil || t.InProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InProfileOctetsForwardedCount
}

// GetInProfilePacketsForwardedCount retrieves the value of the leaf InProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsForwardedCount is set, it can
// safely use t.GetInProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) GetInProfilePacketsForwardedCount() bool {
	if t == nil || t.InProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InProfilePacketsForwardedCount
}

// GetLowOctetsDiscardedCount retrieves the value of the leaf LowOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowOctetsDiscardedCount is set, it can
// safely use t.GetLowOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) GetLowOctetsDiscardedCount() bool {
	if t == nil || t.LowOctetsDiscardedCount == nil {
		return false
	}
	return *t.LowOctetsDiscardedCount
}

// GetLowPacketsDiscardedCount retrieves the value of the leaf LowPacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowPacketsDiscardedCount is set, it can
// safely use t.GetLowPacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowPacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) GetLowPacketsDiscardedCount() bool {
	if t == nil || t.LowPacketsDiscardedCount == nil {
		return false
	}
	return *t.LowPacketsDiscardedCount
}

// GetOutProfileOctetsForwardedCount retrieves the value of the leaf OutProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsForwardedCount is set, it can
// safely use t.GetOutProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) GetOutProfileOctetsForwardedCount() bool {
	if t == nil || t.OutProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsForwardedCount
}

// GetOutProfilePacketsForwardedCount retrieves the value of the leaf OutProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsForwardedCount is set, it can
// safely use t.GetOutProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) GetOutProfilePacketsForwardedCount() bool {
	if t == nil || t.OutProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsForwardedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AllOctetsOfferedCount == nil {
		var v bool = false
		t.AllOctetsOfferedCount = &v
	}
	if t.AllPacketsOfferedCount == nil {
		var v bool = false
		t.AllPacketsOfferedCount = &v
	}
	if t.HighOctetsDiscardedCount == nil {
		var v bool = false
		t.HighOctetsDiscardedCount = &v
	}
	if t.HighPacketsDiscardedCount == nil {
		var v bool = false
		t.HighPacketsDiscardedCount = &v
	}
	if t.InProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InProfileOctetsForwardedCount = &v
	}
	if t.InProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InProfilePacketsForwardedCount = &v
	}
	if t.LowOctetsDiscardedCount == nil {
		var v bool = false
		t.LowOctetsDiscardedCount = &v
	}
	if t.LowPacketsDiscardedCount == nil {
		var v bool = false
		t.LowPacketsDiscardedCount = &v
	}
	if t.OutProfileOctetsForwardedCount == nil {
		var v bool = false
		t.OutProfileOctetsForwardedCount = &v
	}
	if t.OutProfilePacketsForwardedCount == nil {
		var v bool = false
		t.OutProfilePacketsForwardedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_OverrideCounter_ICounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/policer YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer struct {
	ECounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters `path:"e-counters" module:"nokia-conf"`
	ICounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters `path:"i-counters" module:"nokia-conf"`
	Id        NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_Id_Union   `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) IsYANGGoStruct() {}

// GetOrCreateECounters retrieves the value of the ECounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) GetOrCreateECounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters {
	if t.ECounters != nil {
		return t.ECounters
	}
	t.ECounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters{}
	return t.ECounters
}

// GetOrCreateICounters retrieves the value of the ICounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) GetOrCreateICounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters {
	if t.ICounters != nil {
		return t.ICounters
	}
	t.ICounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters{}
	return t.ICounters
}

// GetECounters returns the value of the ECounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer. If the receiver or the field ECounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) GetECounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters {
	if t != nil && t.ECounters != nil {
		return t.ECounters
	}
	return nil
}

// GetICounters returns the value of the ICounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer. If the receiver or the field ICounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) GetICounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters {
	if t != nil && t.ICounters != nil {
		return t.ICounters
	}
	return nil
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) GetId() NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ECounters.PopulateDefaults()
	t.ICounters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/policer/e-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters struct {
	ExceedProfileOctetsDiscardedCount  *bool `path:"exceed-profile-octets-discarded-count" module:"nokia-conf"`
	ExceedProfileOctetsForwardedCount  *bool `path:"exceed-profile-octets-forwarded-count" module:"nokia-conf"`
	ExceedProfileOctetsOfferedCount    *bool `path:"exceed-profile-octets-offered-count" module:"nokia-conf"`
	ExceedProfilePacketsDiscardedCount *bool `path:"exceed-profile-packets-discarded-count" module:"nokia-conf"`
	ExceedProfilePacketsForwardedCount *bool `path:"exceed-profile-packets-forwarded-count" module:"nokia-conf"`
	ExceedProfilePacketsOfferedCount   *bool `path:"exceed-profile-packets-offered-count" module:"nokia-conf"`
	InPlusProfileOctetsDiscardedCount  *bool `path:"in-plus-profile-octets-discarded-count" module:"nokia-conf"`
	InPlusProfileOctetsForwardedCount  *bool `path:"in-plus-profile-octets-forwarded-count" module:"nokia-conf"`
	InPlusProfileOctetsOfferedCount    *bool `path:"in-plus-profile-octets-offered-count" module:"nokia-conf"`
	InPlusProfilePacketsDiscardedCount *bool `path:"in-plus-profile-packets-discarded-count" module:"nokia-conf"`
	InPlusProfilePacketsForwardedCount *bool `path:"in-plus-profile-packets-forwarded-count" module:"nokia-conf"`
	InPlusProfilePacketsOfferedCount   *bool `path:"in-plus-profile-packets-offered-count" module:"nokia-conf"`
	InProfileOctetsDiscardedCount      *bool `path:"in-profile-octets-discarded-count" module:"nokia-conf"`
	InProfileOctetsForwardedCount      *bool `path:"in-profile-octets-forwarded-count" module:"nokia-conf"`
	InProfileOctetsOfferedCount        *bool `path:"in-profile-octets-offered-count" module:"nokia-conf"`
	InProfilePacketsDiscardedCount     *bool `path:"in-profile-packets-discarded-count" module:"nokia-conf"`
	InProfilePacketsForwardedCount     *bool `path:"in-profile-packets-forwarded-count" module:"nokia-conf"`
	InProfilePacketsOfferedCount       *bool `path:"in-profile-packets-offered-count" module:"nokia-conf"`
	OutProfileOctetsDiscardedCount     *bool `path:"out-profile-octets-discarded-count" module:"nokia-conf"`
	OutProfileOctetsForwardedCount     *bool `path:"out-profile-octets-forwarded-count" module:"nokia-conf"`
	OutProfileOctetsOfferedCount       *bool `path:"out-profile-octets-offered-count" module:"nokia-conf"`
	OutProfilePacketsDiscardedCount    *bool `path:"out-profile-packets-discarded-count" module:"nokia-conf"`
	OutProfilePacketsForwardedCount    *bool `path:"out-profile-packets-forwarded-count" module:"nokia-conf"`
	OutProfilePacketsOfferedCount      *bool `path:"out-profile-packets-offered-count" module:"nokia-conf"`
	UncolouredOctetsOfferedCount       *bool `path:"uncoloured-octets-offered-count" module:"nokia-conf"`
	UncolouredPacketsOfferedCount      *bool `path:"uncoloured-packets-offered-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) IsYANGGoStruct() {
}

// GetExceedProfileOctetsDiscardedCount retrieves the value of the leaf ExceedProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceedProfileOctetsDiscardedCount is set, it can
// safely use t.GetExceedProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceedProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetExceedProfileOctetsDiscardedCount() bool {
	if t == nil || t.ExceedProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.ExceedProfileOctetsDiscardedCount
}

// GetExceedProfileOctetsForwardedCount retrieves the value of the leaf ExceedProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceedProfileOctetsForwardedCount is set, it can
// safely use t.GetExceedProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceedProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetExceedProfileOctetsForwardedCount() bool {
	if t == nil || t.ExceedProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.ExceedProfileOctetsForwardedCount
}

// GetExceedProfileOctetsOfferedCount retrieves the value of the leaf ExceedProfileOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceedProfileOctetsOfferedCount is set, it can
// safely use t.GetExceedProfileOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceedProfileOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetExceedProfileOctetsOfferedCount() bool {
	if t == nil || t.ExceedProfileOctetsOfferedCount == nil {
		return false
	}
	return *t.ExceedProfileOctetsOfferedCount
}

// GetExceedProfilePacketsDiscardedCount retrieves the value of the leaf ExceedProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceedProfilePacketsDiscardedCount is set, it can
// safely use t.GetExceedProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceedProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetExceedProfilePacketsDiscardedCount() bool {
	if t == nil || t.ExceedProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.ExceedProfilePacketsDiscardedCount
}

// GetExceedProfilePacketsForwardedCount retrieves the value of the leaf ExceedProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceedProfilePacketsForwardedCount is set, it can
// safely use t.GetExceedProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceedProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetExceedProfilePacketsForwardedCount() bool {
	if t == nil || t.ExceedProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.ExceedProfilePacketsForwardedCount
}

// GetExceedProfilePacketsOfferedCount retrieves the value of the leaf ExceedProfilePacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceedProfilePacketsOfferedCount is set, it can
// safely use t.GetExceedProfilePacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceedProfilePacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetExceedProfilePacketsOfferedCount() bool {
	if t == nil || t.ExceedProfilePacketsOfferedCount == nil {
		return false
	}
	return *t.ExceedProfilePacketsOfferedCount
}

// GetInPlusProfileOctetsDiscardedCount retrieves the value of the leaf InPlusProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPlusProfileOctetsDiscardedCount is set, it can
// safely use t.GetInPlusProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPlusProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetInPlusProfileOctetsDiscardedCount() bool {
	if t == nil || t.InPlusProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.InPlusProfileOctetsDiscardedCount
}

// GetInPlusProfileOctetsForwardedCount retrieves the value of the leaf InPlusProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPlusProfileOctetsForwardedCount is set, it can
// safely use t.GetInPlusProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPlusProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetInPlusProfileOctetsForwardedCount() bool {
	if t == nil || t.InPlusProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InPlusProfileOctetsForwardedCount
}

// GetInPlusProfileOctetsOfferedCount retrieves the value of the leaf InPlusProfileOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPlusProfileOctetsOfferedCount is set, it can
// safely use t.GetInPlusProfileOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPlusProfileOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetInPlusProfileOctetsOfferedCount() bool {
	if t == nil || t.InPlusProfileOctetsOfferedCount == nil {
		return false
	}
	return *t.InPlusProfileOctetsOfferedCount
}

// GetInPlusProfilePacketsDiscardedCount retrieves the value of the leaf InPlusProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPlusProfilePacketsDiscardedCount is set, it can
// safely use t.GetInPlusProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPlusProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetInPlusProfilePacketsDiscardedCount() bool {
	if t == nil || t.InPlusProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.InPlusProfilePacketsDiscardedCount
}

// GetInPlusProfilePacketsForwardedCount retrieves the value of the leaf InPlusProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPlusProfilePacketsForwardedCount is set, it can
// safely use t.GetInPlusProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPlusProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetInPlusProfilePacketsForwardedCount() bool {
	if t == nil || t.InPlusProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InPlusProfilePacketsForwardedCount
}

// GetInPlusProfilePacketsOfferedCount retrieves the value of the leaf InPlusProfilePacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPlusProfilePacketsOfferedCount is set, it can
// safely use t.GetInPlusProfilePacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPlusProfilePacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetInPlusProfilePacketsOfferedCount() bool {
	if t == nil || t.InPlusProfilePacketsOfferedCount == nil {
		return false
	}
	return *t.InPlusProfilePacketsOfferedCount
}

// GetInProfileOctetsDiscardedCount retrieves the value of the leaf InProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsDiscardedCount is set, it can
// safely use t.GetInProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetInProfileOctetsDiscardedCount() bool {
	if t == nil || t.InProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.InProfileOctetsDiscardedCount
}

// GetInProfileOctetsForwardedCount retrieves the value of the leaf InProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsForwardedCount is set, it can
// safely use t.GetInProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetInProfileOctetsForwardedCount() bool {
	if t == nil || t.InProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InProfileOctetsForwardedCount
}

// GetInProfileOctetsOfferedCount retrieves the value of the leaf InProfileOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsOfferedCount is set, it can
// safely use t.GetInProfileOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetInProfileOctetsOfferedCount() bool {
	if t == nil || t.InProfileOctetsOfferedCount == nil {
		return false
	}
	return *t.InProfileOctetsOfferedCount
}

// GetInProfilePacketsDiscardedCount retrieves the value of the leaf InProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsDiscardedCount is set, it can
// safely use t.GetInProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetInProfilePacketsDiscardedCount() bool {
	if t == nil || t.InProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.InProfilePacketsDiscardedCount
}

// GetInProfilePacketsForwardedCount retrieves the value of the leaf InProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsForwardedCount is set, it can
// safely use t.GetInProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetInProfilePacketsForwardedCount() bool {
	if t == nil || t.InProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InProfilePacketsForwardedCount
}

// GetInProfilePacketsOfferedCount retrieves the value of the leaf InProfilePacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsOfferedCount is set, it can
// safely use t.GetInProfilePacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetInProfilePacketsOfferedCount() bool {
	if t == nil || t.InProfilePacketsOfferedCount == nil {
		return false
	}
	return *t.InProfilePacketsOfferedCount
}

// GetOutProfileOctetsDiscardedCount retrieves the value of the leaf OutProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsDiscardedCount is set, it can
// safely use t.GetOutProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetOutProfileOctetsDiscardedCount() bool {
	if t == nil || t.OutProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsDiscardedCount
}

// GetOutProfileOctetsForwardedCount retrieves the value of the leaf OutProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsForwardedCount is set, it can
// safely use t.GetOutProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetOutProfileOctetsForwardedCount() bool {
	if t == nil || t.OutProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsForwardedCount
}

// GetOutProfileOctetsOfferedCount retrieves the value of the leaf OutProfileOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsOfferedCount is set, it can
// safely use t.GetOutProfileOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetOutProfileOctetsOfferedCount() bool {
	if t == nil || t.OutProfileOctetsOfferedCount == nil {
		return false
	}
	return *t.OutProfileOctetsOfferedCount
}

// GetOutProfilePacketsDiscardedCount retrieves the value of the leaf OutProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsDiscardedCount is set, it can
// safely use t.GetOutProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetOutProfilePacketsDiscardedCount() bool {
	if t == nil || t.OutProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsDiscardedCount
}

// GetOutProfilePacketsForwardedCount retrieves the value of the leaf OutProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsForwardedCount is set, it can
// safely use t.GetOutProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetOutProfilePacketsForwardedCount() bool {
	if t == nil || t.OutProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsForwardedCount
}

// GetOutProfilePacketsOfferedCount retrieves the value of the leaf OutProfilePacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsOfferedCount is set, it can
// safely use t.GetOutProfilePacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetOutProfilePacketsOfferedCount() bool {
	if t == nil || t.OutProfilePacketsOfferedCount == nil {
		return false
	}
	return *t.OutProfilePacketsOfferedCount
}

// GetUncolouredOctetsOfferedCount retrieves the value of the leaf UncolouredOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UncolouredOctetsOfferedCount is set, it can
// safely use t.GetUncolouredOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UncolouredOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetUncolouredOctetsOfferedCount() bool {
	if t == nil || t.UncolouredOctetsOfferedCount == nil {
		return false
	}
	return *t.UncolouredOctetsOfferedCount
}

// GetUncolouredPacketsOfferedCount retrieves the value of the leaf UncolouredPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UncolouredPacketsOfferedCount is set, it can
// safely use t.GetUncolouredPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UncolouredPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) GetUncolouredPacketsOfferedCount() bool {
	if t == nil || t.UncolouredPacketsOfferedCount == nil {
		return false
	}
	return *t.UncolouredPacketsOfferedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ExceedProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.ExceedProfileOctetsDiscardedCount = &v
	}
	if t.ExceedProfileOctetsForwardedCount == nil {
		var v bool = false
		t.ExceedProfileOctetsForwardedCount = &v
	}
	if t.ExceedProfileOctetsOfferedCount == nil {
		var v bool = false
		t.ExceedProfileOctetsOfferedCount = &v
	}
	if t.ExceedProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.ExceedProfilePacketsDiscardedCount = &v
	}
	if t.ExceedProfilePacketsForwardedCount == nil {
		var v bool = false
		t.ExceedProfilePacketsForwardedCount = &v
	}
	if t.ExceedProfilePacketsOfferedCount == nil {
		var v bool = false
		t.ExceedProfilePacketsOfferedCount = &v
	}
	if t.InPlusProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.InPlusProfileOctetsDiscardedCount = &v
	}
	if t.InPlusProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InPlusProfileOctetsForwardedCount = &v
	}
	if t.InPlusProfileOctetsOfferedCount == nil {
		var v bool = false
		t.InPlusProfileOctetsOfferedCount = &v
	}
	if t.InPlusProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.InPlusProfilePacketsDiscardedCount = &v
	}
	if t.InPlusProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InPlusProfilePacketsForwardedCount = &v
	}
	if t.InPlusProfilePacketsOfferedCount == nil {
		var v bool = false
		t.InPlusProfilePacketsOfferedCount = &v
	}
	if t.InProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.InProfileOctetsDiscardedCount = &v
	}
	if t.InProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InProfileOctetsForwardedCount = &v
	}
	if t.InProfileOctetsOfferedCount == nil {
		var v bool = false
		t.InProfileOctetsOfferedCount = &v
	}
	if t.InProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.InProfilePacketsDiscardedCount = &v
	}
	if t.InProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InProfilePacketsForwardedCount = &v
	}
	if t.InProfilePacketsOfferedCount == nil {
		var v bool = false
		t.InProfilePacketsOfferedCount = &v
	}
	if t.OutProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.OutProfileOctetsDiscardedCount = &v
	}
	if t.OutProfileOctetsForwardedCount == nil {
		var v bool = false
		t.OutProfileOctetsForwardedCount = &v
	}
	if t.OutProfileOctetsOfferedCount == nil {
		var v bool = false
		t.OutProfileOctetsOfferedCount = &v
	}
	if t.OutProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.OutProfilePacketsDiscardedCount = &v
	}
	if t.OutProfilePacketsForwardedCount == nil {
		var v bool = false
		t.OutProfilePacketsForwardedCount = &v
	}
	if t.OutProfilePacketsOfferedCount == nil {
		var v bool = false
		t.OutProfilePacketsOfferedCount = &v
	}
	if t.UncolouredOctetsOfferedCount == nil {
		var v bool = false
		t.UncolouredOctetsOfferedCount = &v
	}
	if t.UncolouredPacketsOfferedCount == nil {
		var v bool = false
		t.UncolouredPacketsOfferedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ECounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/policer/i-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters struct {
	InProfileOctetsDiscardedCount   *bool `path:"in-profile-octets-discarded-count" module:"nokia-conf"`
	InProfileOctetsForwardedCount   *bool `path:"in-profile-octets-forwarded-count" module:"nokia-conf"`
	InProfileOctetsOfferedCount     *bool `path:"in-profile-octets-offered-count" module:"nokia-conf"`
	InProfilePacketsDiscardedCount  *bool `path:"in-profile-packets-discarded-count" module:"nokia-conf"`
	InProfilePacketsForwardedCount  *bool `path:"in-profile-packets-forwarded-count" module:"nokia-conf"`
	InProfilePacketsOfferedCount    *bool `path:"in-profile-packets-offered-count" module:"nokia-conf"`
	OutProfileOctetsDiscardedCount  *bool `path:"out-profile-octets-discarded-count" module:"nokia-conf"`
	OutProfileOctetsForwardedCount  *bool `path:"out-profile-octets-forwarded-count" module:"nokia-conf"`
	OutProfileOctetsOfferedCount    *bool `path:"out-profile-octets-offered-count" module:"nokia-conf"`
	OutProfilePacketsDiscardedCount *bool `path:"out-profile-packets-discarded-count" module:"nokia-conf"`
	OutProfilePacketsForwardedCount *bool `path:"out-profile-packets-forwarded-count" module:"nokia-conf"`
	OutProfilePacketsOfferedCount   *bool `path:"out-profile-packets-offered-count" module:"nokia-conf"`
	UncolouredOctetsOfferedCount    *bool `path:"uncoloured-octets-offered-count" module:"nokia-conf"`
	UncolouredPacketsOfferedCount   *bool `path:"uncoloured-packets-offered-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) IsYANGGoStruct() {
}

// GetInProfileOctetsDiscardedCount retrieves the value of the leaf InProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsDiscardedCount is set, it can
// safely use t.GetInProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetInProfileOctetsDiscardedCount() bool {
	if t == nil || t.InProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.InProfileOctetsDiscardedCount
}

// GetInProfileOctetsForwardedCount retrieves the value of the leaf InProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsForwardedCount is set, it can
// safely use t.GetInProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetInProfileOctetsForwardedCount() bool {
	if t == nil || t.InProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InProfileOctetsForwardedCount
}

// GetInProfileOctetsOfferedCount retrieves the value of the leaf InProfileOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsOfferedCount is set, it can
// safely use t.GetInProfileOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetInProfileOctetsOfferedCount() bool {
	if t == nil || t.InProfileOctetsOfferedCount == nil {
		return false
	}
	return *t.InProfileOctetsOfferedCount
}

// GetInProfilePacketsDiscardedCount retrieves the value of the leaf InProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsDiscardedCount is set, it can
// safely use t.GetInProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetInProfilePacketsDiscardedCount() bool {
	if t == nil || t.InProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.InProfilePacketsDiscardedCount
}

// GetInProfilePacketsForwardedCount retrieves the value of the leaf InProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsForwardedCount is set, it can
// safely use t.GetInProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetInProfilePacketsForwardedCount() bool {
	if t == nil || t.InProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InProfilePacketsForwardedCount
}

// GetInProfilePacketsOfferedCount retrieves the value of the leaf InProfilePacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsOfferedCount is set, it can
// safely use t.GetInProfilePacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetInProfilePacketsOfferedCount() bool {
	if t == nil || t.InProfilePacketsOfferedCount == nil {
		return false
	}
	return *t.InProfilePacketsOfferedCount
}

// GetOutProfileOctetsDiscardedCount retrieves the value of the leaf OutProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsDiscardedCount is set, it can
// safely use t.GetOutProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetOutProfileOctetsDiscardedCount() bool {
	if t == nil || t.OutProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsDiscardedCount
}

// GetOutProfileOctetsForwardedCount retrieves the value of the leaf OutProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsForwardedCount is set, it can
// safely use t.GetOutProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetOutProfileOctetsForwardedCount() bool {
	if t == nil || t.OutProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsForwardedCount
}

// GetOutProfileOctetsOfferedCount retrieves the value of the leaf OutProfileOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsOfferedCount is set, it can
// safely use t.GetOutProfileOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetOutProfileOctetsOfferedCount() bool {
	if t == nil || t.OutProfileOctetsOfferedCount == nil {
		return false
	}
	return *t.OutProfileOctetsOfferedCount
}

// GetOutProfilePacketsDiscardedCount retrieves the value of the leaf OutProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsDiscardedCount is set, it can
// safely use t.GetOutProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetOutProfilePacketsDiscardedCount() bool {
	if t == nil || t.OutProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsDiscardedCount
}

// GetOutProfilePacketsForwardedCount retrieves the value of the leaf OutProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsForwardedCount is set, it can
// safely use t.GetOutProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetOutProfilePacketsForwardedCount() bool {
	if t == nil || t.OutProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsForwardedCount
}

// GetOutProfilePacketsOfferedCount retrieves the value of the leaf OutProfilePacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsOfferedCount is set, it can
// safely use t.GetOutProfilePacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetOutProfilePacketsOfferedCount() bool {
	if t == nil || t.OutProfilePacketsOfferedCount == nil {
		return false
	}
	return *t.OutProfilePacketsOfferedCount
}

// GetUncolouredOctetsOfferedCount retrieves the value of the leaf UncolouredOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UncolouredOctetsOfferedCount is set, it can
// safely use t.GetUncolouredOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UncolouredOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetUncolouredOctetsOfferedCount() bool {
	if t == nil || t.UncolouredOctetsOfferedCount == nil {
		return false
	}
	return *t.UncolouredOctetsOfferedCount
}

// GetUncolouredPacketsOfferedCount retrieves the value of the leaf UncolouredPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UncolouredPacketsOfferedCount is set, it can
// safely use t.GetUncolouredPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UncolouredPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) GetUncolouredPacketsOfferedCount() bool {
	if t == nil || t.UncolouredPacketsOfferedCount == nil {
		return false
	}
	return *t.UncolouredPacketsOfferedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.InProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.InProfileOctetsDiscardedCount = &v
	}
	if t.InProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InProfileOctetsForwardedCount = &v
	}
	if t.InProfileOctetsOfferedCount == nil {
		var v bool = false
		t.InProfileOctetsOfferedCount = &v
	}
	if t.InProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.InProfilePacketsDiscardedCount = &v
	}
	if t.InProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InProfilePacketsForwardedCount = &v
	}
	if t.InProfilePacketsOfferedCount == nil {
		var v bool = false
		t.InProfilePacketsOfferedCount = &v
	}
	if t.OutProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.OutProfileOctetsDiscardedCount = &v
	}
	if t.OutProfileOctetsForwardedCount == nil {
		var v bool = false
		t.OutProfileOctetsForwardedCount = &v
	}
	if t.OutProfileOctetsOfferedCount == nil {
		var v bool = false
		t.OutProfileOctetsOfferedCount = &v
	}
	if t.OutProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.OutProfilePacketsDiscardedCount = &v
	}
	if t.OutProfilePacketsForwardedCount == nil {
		var v bool = false
		t.OutProfilePacketsForwardedCount = &v
	}
	if t.OutProfilePacketsOfferedCount == nil {
		var v bool = false
		t.OutProfilePacketsOfferedCount = &v
	}
	if t.UncolouredOctetsOfferedCount == nil {
		var v bool = false
		t.UncolouredOctetsOfferedCount = &v
	}
	if t.UncolouredPacketsOfferedCount == nil {
		var v bool = false
		t.UncolouredPacketsOfferedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Policer_ICounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/queue YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue struct {
	ECounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters `path:"e-counters" module:"nokia-conf"`
	ICounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters `path:"i-counters" module:"nokia-conf"`
	Id        NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_Id_Union   `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) IsYANGGoStruct() {}

// GetOrCreateECounters retrieves the value of the ECounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) GetOrCreateECounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters {
	if t.ECounters != nil {
		return t.ECounters
	}
	t.ECounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters{}
	return t.ECounters
}

// GetOrCreateICounters retrieves the value of the ICounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) GetOrCreateICounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters {
	if t.ICounters != nil {
		return t.ICounters
	}
	t.ICounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters{}
	return t.ICounters
}

// GetECounters returns the value of the ECounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue. If the receiver or the field ECounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) GetECounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters {
	if t != nil && t.ECounters != nil {
		return t.ECounters
	}
	return nil
}

// GetICounters returns the value of the ICounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue. If the receiver or the field ICounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) GetICounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters {
	if t != nil && t.ICounters != nil {
		return t.ICounters
	}
	return nil
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) GetId() NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ECounters.PopulateDefaults()
	t.ICounters.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/queue/e-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters struct {
	InProfileOctetsDiscardedCount   *bool `path:"in-profile-octets-discarded-count" module:"nokia-conf"`
	InProfileOctetsForwardedCount   *bool `path:"in-profile-octets-forwarded-count" module:"nokia-conf"`
	InProfilePacketsDiscardedCount  *bool `path:"in-profile-packets-discarded-count" module:"nokia-conf"`
	InProfilePacketsForwardedCount  *bool `path:"in-profile-packets-forwarded-count" module:"nokia-conf"`
	OutProfileOctetsDiscardedCount  *bool `path:"out-profile-octets-discarded-count" module:"nokia-conf"`
	OutProfileOctetsForwardedCount  *bool `path:"out-profile-octets-forwarded-count" module:"nokia-conf"`
	OutProfilePacketsDiscardedCount *bool `path:"out-profile-packets-discarded-count" module:"nokia-conf"`
	OutProfilePacketsForwardedCount *bool `path:"out-profile-packets-forwarded-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) IsYANGGoStruct() {
}

// GetInProfileOctetsDiscardedCount retrieves the value of the leaf InProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsDiscardedCount is set, it can
// safely use t.GetInProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) GetInProfileOctetsDiscardedCount() bool {
	if t == nil || t.InProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.InProfileOctetsDiscardedCount
}

// GetInProfileOctetsForwardedCount retrieves the value of the leaf InProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsForwardedCount is set, it can
// safely use t.GetInProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) GetInProfileOctetsForwardedCount() bool {
	if t == nil || t.InProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InProfileOctetsForwardedCount
}

// GetInProfilePacketsDiscardedCount retrieves the value of the leaf InProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsDiscardedCount is set, it can
// safely use t.GetInProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) GetInProfilePacketsDiscardedCount() bool {
	if t == nil || t.InProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.InProfilePacketsDiscardedCount
}

// GetInProfilePacketsForwardedCount retrieves the value of the leaf InProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsForwardedCount is set, it can
// safely use t.GetInProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) GetInProfilePacketsForwardedCount() bool {
	if t == nil || t.InProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InProfilePacketsForwardedCount
}

// GetOutProfileOctetsDiscardedCount retrieves the value of the leaf OutProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsDiscardedCount is set, it can
// safely use t.GetOutProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) GetOutProfileOctetsDiscardedCount() bool {
	if t == nil || t.OutProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsDiscardedCount
}

// GetOutProfileOctetsForwardedCount retrieves the value of the leaf OutProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsForwardedCount is set, it can
// safely use t.GetOutProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) GetOutProfileOctetsForwardedCount() bool {
	if t == nil || t.OutProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsForwardedCount
}

// GetOutProfilePacketsDiscardedCount retrieves the value of the leaf OutProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsDiscardedCount is set, it can
// safely use t.GetOutProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) GetOutProfilePacketsDiscardedCount() bool {
	if t == nil || t.OutProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsDiscardedCount
}

// GetOutProfilePacketsForwardedCount retrieves the value of the leaf OutProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsForwardedCount is set, it can
// safely use t.GetOutProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) GetOutProfilePacketsForwardedCount() bool {
	if t == nil || t.OutProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsForwardedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.InProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.InProfileOctetsDiscardedCount = &v
	}
	if t.InProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InProfileOctetsForwardedCount = &v
	}
	if t.InProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.InProfilePacketsDiscardedCount = &v
	}
	if t.InProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InProfilePacketsForwardedCount = &v
	}
	if t.OutProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.OutProfileOctetsDiscardedCount = &v
	}
	if t.OutProfileOctetsForwardedCount == nil {
		var v bool = false
		t.OutProfileOctetsForwardedCount = &v
	}
	if t.OutProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.OutProfilePacketsDiscardedCount = &v
	}
	if t.OutProfilePacketsForwardedCount == nil {
		var v bool = false
		t.OutProfilePacketsForwardedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ECounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/queue/i-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters struct {
	AllOctetsOfferedCount           *bool `path:"all-octets-offered-count" module:"nokia-conf"`
	AllPacketsOfferedCount          *bool `path:"all-packets-offered-count" module:"nokia-conf"`
	HighOctetsDiscardedCount        *bool `path:"high-octets-discarded-count" module:"nokia-conf"`
	HighOctetsOfferedCount          *bool `path:"high-octets-offered-count" module:"nokia-conf"`
	HighPacketsDiscardedCount       *bool `path:"high-packets-discarded-count" module:"nokia-conf"`
	HighPacketsOfferedCount         *bool `path:"high-packets-offered-count" module:"nokia-conf"`
	InProfileOctetsForwardedCount   *bool `path:"in-profile-octets-forwarded-count" module:"nokia-conf"`
	InProfilePacketsForwardedCount  *bool `path:"in-profile-packets-forwarded-count" module:"nokia-conf"`
	LowOctetsDiscardedCount         *bool `path:"low-octets-discarded-count" module:"nokia-conf"`
	LowOctetsOfferedCount           *bool `path:"low-octets-offered-count" module:"nokia-conf"`
	LowPacketsDiscardedCount        *bool `path:"low-packets-discarded-count" module:"nokia-conf"`
	LowPacketsOfferedCount          *bool `path:"low-packets-offered-count" module:"nokia-conf"`
	OutProfileOctetsForwardedCount  *bool `path:"out-profile-octets-forwarded-count" module:"nokia-conf"`
	OutProfilePacketsForwardedCount *bool `path:"out-profile-packets-forwarded-count" module:"nokia-conf"`
	UncolouredOctetsOfferedCount    *bool `path:"uncoloured-octets-offered-count" module:"nokia-conf"`
	UncolouredPacketsOfferedCount   *bool `path:"uncoloured-packets-offered-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) IsYANGGoStruct() {
}

// GetAllOctetsOfferedCount retrieves the value of the leaf AllOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllOctetsOfferedCount is set, it can
// safely use t.GetAllOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetAllOctetsOfferedCount() bool {
	if t == nil || t.AllOctetsOfferedCount == nil {
		return false
	}
	return *t.AllOctetsOfferedCount
}

// GetAllPacketsOfferedCount retrieves the value of the leaf AllPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllPacketsOfferedCount is set, it can
// safely use t.GetAllPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetAllPacketsOfferedCount() bool {
	if t == nil || t.AllPacketsOfferedCount == nil {
		return false
	}
	return *t.AllPacketsOfferedCount
}

// GetHighOctetsDiscardedCount retrieves the value of the leaf HighOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighOctetsDiscardedCount is set, it can
// safely use t.GetHighOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetHighOctetsDiscardedCount() bool {
	if t == nil || t.HighOctetsDiscardedCount == nil {
		return false
	}
	return *t.HighOctetsDiscardedCount
}

// GetHighOctetsOfferedCount retrieves the value of the leaf HighOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighOctetsOfferedCount is set, it can
// safely use t.GetHighOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetHighOctetsOfferedCount() bool {
	if t == nil || t.HighOctetsOfferedCount == nil {
		return false
	}
	return *t.HighOctetsOfferedCount
}

// GetHighPacketsDiscardedCount retrieves the value of the leaf HighPacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighPacketsDiscardedCount is set, it can
// safely use t.GetHighPacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighPacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetHighPacketsDiscardedCount() bool {
	if t == nil || t.HighPacketsDiscardedCount == nil {
		return false
	}
	return *t.HighPacketsDiscardedCount
}

// GetHighPacketsOfferedCount retrieves the value of the leaf HighPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighPacketsOfferedCount is set, it can
// safely use t.GetHighPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetHighPacketsOfferedCount() bool {
	if t == nil || t.HighPacketsOfferedCount == nil {
		return false
	}
	return *t.HighPacketsOfferedCount
}

// GetInProfileOctetsForwardedCount retrieves the value of the leaf InProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsForwardedCount is set, it can
// safely use t.GetInProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetInProfileOctetsForwardedCount() bool {
	if t == nil || t.InProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InProfileOctetsForwardedCount
}

// GetInProfilePacketsForwardedCount retrieves the value of the leaf InProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsForwardedCount is set, it can
// safely use t.GetInProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetInProfilePacketsForwardedCount() bool {
	if t == nil || t.InProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InProfilePacketsForwardedCount
}

// GetLowOctetsDiscardedCount retrieves the value of the leaf LowOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowOctetsDiscardedCount is set, it can
// safely use t.GetLowOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetLowOctetsDiscardedCount() bool {
	if t == nil || t.LowOctetsDiscardedCount == nil {
		return false
	}
	return *t.LowOctetsDiscardedCount
}

// GetLowOctetsOfferedCount retrieves the value of the leaf LowOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowOctetsOfferedCount is set, it can
// safely use t.GetLowOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetLowOctetsOfferedCount() bool {
	if t == nil || t.LowOctetsOfferedCount == nil {
		return false
	}
	return *t.LowOctetsOfferedCount
}

// GetLowPacketsDiscardedCount retrieves the value of the leaf LowPacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowPacketsDiscardedCount is set, it can
// safely use t.GetLowPacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowPacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetLowPacketsDiscardedCount() bool {
	if t == nil || t.LowPacketsDiscardedCount == nil {
		return false
	}
	return *t.LowPacketsDiscardedCount
}

// GetLowPacketsOfferedCount retrieves the value of the leaf LowPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowPacketsOfferedCount is set, it can
// safely use t.GetLowPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetLowPacketsOfferedCount() bool {
	if t == nil || t.LowPacketsOfferedCount == nil {
		return false
	}
	return *t.LowPacketsOfferedCount
}

// GetOutProfileOctetsForwardedCount retrieves the value of the leaf OutProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsForwardedCount is set, it can
// safely use t.GetOutProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetOutProfileOctetsForwardedCount() bool {
	if t == nil || t.OutProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsForwardedCount
}

// GetOutProfilePacketsForwardedCount retrieves the value of the leaf OutProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsForwardedCount is set, it can
// safely use t.GetOutProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetOutProfilePacketsForwardedCount() bool {
	if t == nil || t.OutProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsForwardedCount
}

// GetUncolouredOctetsOfferedCount retrieves the value of the leaf UncolouredOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UncolouredOctetsOfferedCount is set, it can
// safely use t.GetUncolouredOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UncolouredOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetUncolouredOctetsOfferedCount() bool {
	if t == nil || t.UncolouredOctetsOfferedCount == nil {
		return false
	}
	return *t.UncolouredOctetsOfferedCount
}

// GetUncolouredPacketsOfferedCount retrieves the value of the leaf UncolouredPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UncolouredPacketsOfferedCount is set, it can
// safely use t.GetUncolouredPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UncolouredPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) GetUncolouredPacketsOfferedCount() bool {
	if t == nil || t.UncolouredPacketsOfferedCount == nil {
		return false
	}
	return *t.UncolouredPacketsOfferedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AllOctetsOfferedCount == nil {
		var v bool = false
		t.AllOctetsOfferedCount = &v
	}
	if t.AllPacketsOfferedCount == nil {
		var v bool = false
		t.AllPacketsOfferedCount = &v
	}
	if t.HighOctetsDiscardedCount == nil {
		var v bool = false
		t.HighOctetsDiscardedCount = &v
	}
	if t.HighOctetsOfferedCount == nil {
		var v bool = false
		t.HighOctetsOfferedCount = &v
	}
	if t.HighPacketsDiscardedCount == nil {
		var v bool = false
		t.HighPacketsDiscardedCount = &v
	}
	if t.HighPacketsOfferedCount == nil {
		var v bool = false
		t.HighPacketsOfferedCount = &v
	}
	if t.InProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InProfileOctetsForwardedCount = &v
	}
	if t.InProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InProfilePacketsForwardedCount = &v
	}
	if t.LowOctetsDiscardedCount == nil {
		var v bool = false
		t.LowOctetsDiscardedCount = &v
	}
	if t.LowOctetsOfferedCount == nil {
		var v bool = false
		t.LowOctetsOfferedCount = &v
	}
	if t.LowPacketsDiscardedCount == nil {
		var v bool = false
		t.LowPacketsDiscardedCount = &v
	}
	if t.LowPacketsOfferedCount == nil {
		var v bool = false
		t.LowPacketsOfferedCount = &v
	}
	if t.OutProfileOctetsForwardedCount == nil {
		var v bool = false
		t.OutProfileOctetsForwardedCount = &v
	}
	if t.OutProfilePacketsForwardedCount == nil {
		var v bool = false
		t.OutProfilePacketsForwardedCount = &v
	}
	if t.UncolouredOctetsOfferedCount == nil {
		var v bool = false
		t.UncolouredOctetsOfferedCount = &v
	}
	if t.UncolouredPacketsOfferedCount == nil {
		var v bool = false
		t.UncolouredPacketsOfferedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_Queue_ICounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/ref-aa-specific-counter YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter struct {
	Any *bool `path:"any" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter) IsYANGGoStruct() {
}

// GetAny retrieves the value of the leaf Any from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Any is set, it can
// safely use t.GetAny() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Any == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter) GetAny() bool {
	if t == nil || t.Any == nil {
		return false
	}
	return *t.Any
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Any == nil {
		var v bool = false
		t.Any = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefAaSpecificCounter) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/ref-override-counter YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter struct {
	All       YANGEmpty                                                                                        `path:"all" module:"nokia-conf"`
	ECounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters `path:"e-counters" module:"nokia-conf"`
	ICounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters `path:"i-counters" module:"nokia-conf"`
	Id        *uint32                                                                                          `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter) IsYANGGoStruct() {
}

// GetOrCreateECounters retrieves the value of the ECounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter) GetOrCreateECounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters {
	if t.ECounters != nil {
		return t.ECounters
	}
	t.ECounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters{}
	return t.ECounters
}

// GetOrCreateICounters retrieves the value of the ICounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter) GetOrCreateICounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters {
	if t.ICounters != nil {
		return t.ICounters
	}
	t.ICounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters{}
	return t.ICounters
}

// GetECounters returns the value of the ECounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter. If the receiver or the field ECounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter) GetECounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters {
	if t != nil && t.ECounters != nil {
		return t.ECounters
	}
	return nil
}

// GetICounters returns the value of the ICounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter. If the receiver or the field ICounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter) GetICounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters {
	if t != nil && t.ICounters != nil {
		return t.ICounters
	}
	return nil
}

// GetAll retrieves the value of the leaf All from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if All is set, it can
// safely use t.GetAll() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.All == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter) GetAll() YANGEmpty {
	if t == nil || t.All == false {
		return false
	}
	return t.All
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter) GetId() uint32 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ECounters.PopulateDefaults()
	t.ICounters.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/ref-override-counter/e-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters struct {
	InProfileOctetsDiscardedCount   *bool `path:"in-profile-octets-discarded-count" module:"nokia-conf"`
	InProfileOctetsForwardedCount   *bool `path:"in-profile-octets-forwarded-count" module:"nokia-conf"`
	InProfilePacketsDiscardedCount  *bool `path:"in-profile-packets-discarded-count" module:"nokia-conf"`
	InProfilePacketsForwardedCount  *bool `path:"in-profile-packets-forwarded-count" module:"nokia-conf"`
	OutProfileOctetsDiscardedCount  *bool `path:"out-profile-octets-discarded-count" module:"nokia-conf"`
	OutProfileOctetsForwardedCount  *bool `path:"out-profile-octets-forwarded-count" module:"nokia-conf"`
	OutProfilePacketsDiscardedCount *bool `path:"out-profile-packets-discarded-count" module:"nokia-conf"`
	OutProfilePacketsForwardedCount *bool `path:"out-profile-packets-forwarded-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) IsYANGGoStruct() {
}

// GetInProfileOctetsDiscardedCount retrieves the value of the leaf InProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsDiscardedCount is set, it can
// safely use t.GetInProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) GetInProfileOctetsDiscardedCount() bool {
	if t == nil || t.InProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.InProfileOctetsDiscardedCount
}

// GetInProfileOctetsForwardedCount retrieves the value of the leaf InProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsForwardedCount is set, it can
// safely use t.GetInProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) GetInProfileOctetsForwardedCount() bool {
	if t == nil || t.InProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InProfileOctetsForwardedCount
}

// GetInProfilePacketsDiscardedCount retrieves the value of the leaf InProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsDiscardedCount is set, it can
// safely use t.GetInProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) GetInProfilePacketsDiscardedCount() bool {
	if t == nil || t.InProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.InProfilePacketsDiscardedCount
}

// GetInProfilePacketsForwardedCount retrieves the value of the leaf InProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsForwardedCount is set, it can
// safely use t.GetInProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) GetInProfilePacketsForwardedCount() bool {
	if t == nil || t.InProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InProfilePacketsForwardedCount
}

// GetOutProfileOctetsDiscardedCount retrieves the value of the leaf OutProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsDiscardedCount is set, it can
// safely use t.GetOutProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) GetOutProfileOctetsDiscardedCount() bool {
	if t == nil || t.OutProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsDiscardedCount
}

// GetOutProfileOctetsForwardedCount retrieves the value of the leaf OutProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsForwardedCount is set, it can
// safely use t.GetOutProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) GetOutProfileOctetsForwardedCount() bool {
	if t == nil || t.OutProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsForwardedCount
}

// GetOutProfilePacketsDiscardedCount retrieves the value of the leaf OutProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsDiscardedCount is set, it can
// safely use t.GetOutProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) GetOutProfilePacketsDiscardedCount() bool {
	if t == nil || t.OutProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsDiscardedCount
}

// GetOutProfilePacketsForwardedCount retrieves the value of the leaf OutProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsForwardedCount is set, it can
// safely use t.GetOutProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) GetOutProfilePacketsForwardedCount() bool {
	if t == nil || t.OutProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsForwardedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.InProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.InProfileOctetsDiscardedCount = &v
	}
	if t.InProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InProfileOctetsForwardedCount = &v
	}
	if t.InProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.InProfilePacketsDiscardedCount = &v
	}
	if t.InProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InProfilePacketsForwardedCount = &v
	}
	if t.OutProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.OutProfileOctetsDiscardedCount = &v
	}
	if t.OutProfileOctetsForwardedCount == nil {
		var v bool = false
		t.OutProfileOctetsForwardedCount = &v
	}
	if t.OutProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.OutProfilePacketsDiscardedCount = &v
	}
	if t.OutProfilePacketsForwardedCount == nil {
		var v bool = false
		t.OutProfilePacketsForwardedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ECounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/ref-override-counter/i-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters struct {
	AllOctetsOfferedCount           *bool `path:"all-octets-offered-count" module:"nokia-conf"`
	AllPacketsOfferedCount          *bool `path:"all-packets-offered-count" module:"nokia-conf"`
	HighOctetsDiscardedCount        *bool `path:"high-octets-discarded-count" module:"nokia-conf"`
	HighPacketsDiscardedCount       *bool `path:"high-packets-discarded-count" module:"nokia-conf"`
	InProfileOctetsForwardedCount   *bool `path:"in-profile-octets-forwarded-count" module:"nokia-conf"`
	InProfilePacketsForwardedCount  *bool `path:"in-profile-packets-forwarded-count" module:"nokia-conf"`
	LowOctetsDiscardedCount         *bool `path:"low-octets-discarded-count" module:"nokia-conf"`
	LowPacketsDiscardedCount        *bool `path:"low-packets-discarded-count" module:"nokia-conf"`
	OutProfileOctetsForwardedCount  *bool `path:"out-profile-octets-forwarded-count" module:"nokia-conf"`
	OutProfilePacketsForwardedCount *bool `path:"out-profile-packets-forwarded-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) IsYANGGoStruct() {
}

// GetAllOctetsOfferedCount retrieves the value of the leaf AllOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllOctetsOfferedCount is set, it can
// safely use t.GetAllOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) GetAllOctetsOfferedCount() bool {
	if t == nil || t.AllOctetsOfferedCount == nil {
		return false
	}
	return *t.AllOctetsOfferedCount
}

// GetAllPacketsOfferedCount retrieves the value of the leaf AllPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllPacketsOfferedCount is set, it can
// safely use t.GetAllPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) GetAllPacketsOfferedCount() bool {
	if t == nil || t.AllPacketsOfferedCount == nil {
		return false
	}
	return *t.AllPacketsOfferedCount
}

// GetHighOctetsDiscardedCount retrieves the value of the leaf HighOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighOctetsDiscardedCount is set, it can
// safely use t.GetHighOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) GetHighOctetsDiscardedCount() bool {
	if t == nil || t.HighOctetsDiscardedCount == nil {
		return false
	}
	return *t.HighOctetsDiscardedCount
}

// GetHighPacketsDiscardedCount retrieves the value of the leaf HighPacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighPacketsDiscardedCount is set, it can
// safely use t.GetHighPacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighPacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) GetHighPacketsDiscardedCount() bool {
	if t == nil || t.HighPacketsDiscardedCount == nil {
		return false
	}
	return *t.HighPacketsDiscardedCount
}

// GetInProfileOctetsForwardedCount retrieves the value of the leaf InProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsForwardedCount is set, it can
// safely use t.GetInProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) GetInProfileOctetsForwardedCount() bool {
	if t == nil || t.InProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InProfileOctetsForwardedCount
}

// GetInProfilePacketsForwardedCount retrieves the value of the leaf InProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsForwardedCount is set, it can
// safely use t.GetInProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) GetInProfilePacketsForwardedCount() bool {
	if t == nil || t.InProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InProfilePacketsForwardedCount
}

// GetLowOctetsDiscardedCount retrieves the value of the leaf LowOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowOctetsDiscardedCount is set, it can
// safely use t.GetLowOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) GetLowOctetsDiscardedCount() bool {
	if t == nil || t.LowOctetsDiscardedCount == nil {
		return false
	}
	return *t.LowOctetsDiscardedCount
}

// GetLowPacketsDiscardedCount retrieves the value of the leaf LowPacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowPacketsDiscardedCount is set, it can
// safely use t.GetLowPacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowPacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) GetLowPacketsDiscardedCount() bool {
	if t == nil || t.LowPacketsDiscardedCount == nil {
		return false
	}
	return *t.LowPacketsDiscardedCount
}

// GetOutProfileOctetsForwardedCount retrieves the value of the leaf OutProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsForwardedCount is set, it can
// safely use t.GetOutProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) GetOutProfileOctetsForwardedCount() bool {
	if t == nil || t.OutProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsForwardedCount
}

// GetOutProfilePacketsForwardedCount retrieves the value of the leaf OutProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsForwardedCount is set, it can
// safely use t.GetOutProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) GetOutProfilePacketsForwardedCount() bool {
	if t == nil || t.OutProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsForwardedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AllOctetsOfferedCount == nil {
		var v bool = false
		t.AllOctetsOfferedCount = &v
	}
	if t.AllPacketsOfferedCount == nil {
		var v bool = false
		t.AllPacketsOfferedCount = &v
	}
	if t.HighOctetsDiscardedCount == nil {
		var v bool = false
		t.HighOctetsDiscardedCount = &v
	}
	if t.HighPacketsDiscardedCount == nil {
		var v bool = false
		t.HighPacketsDiscardedCount = &v
	}
	if t.InProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InProfileOctetsForwardedCount = &v
	}
	if t.InProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InProfilePacketsForwardedCount = &v
	}
	if t.LowOctetsDiscardedCount == nil {
		var v bool = false
		t.LowOctetsDiscardedCount = &v
	}
	if t.LowPacketsDiscardedCount == nil {
		var v bool = false
		t.LowPacketsDiscardedCount = &v
	}
	if t.OutProfileOctetsForwardedCount == nil {
		var v bool = false
		t.OutProfileOctetsForwardedCount = &v
	}
	if t.OutProfilePacketsForwardedCount == nil {
		var v bool = false
		t.OutProfilePacketsForwardedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefOverrideCounter_ICounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/ref-policer YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer struct {
	All       YANGEmpty                                                                                `path:"all" module:"nokia-conf"`
	ECounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters `path:"e-counters" module:"nokia-conf"`
	ICounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters `path:"i-counters" module:"nokia-conf"`
	Id        *uint32                                                                                  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer) IsYANGGoStruct() {
}

// GetOrCreateECounters retrieves the value of the ECounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer) GetOrCreateECounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters {
	if t.ECounters != nil {
		return t.ECounters
	}
	t.ECounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters{}
	return t.ECounters
}

// GetOrCreateICounters retrieves the value of the ICounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer) GetOrCreateICounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters {
	if t.ICounters != nil {
		return t.ICounters
	}
	t.ICounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters{}
	return t.ICounters
}

// GetECounters returns the value of the ECounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer. If the receiver or the field ECounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer) GetECounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters {
	if t != nil && t.ECounters != nil {
		return t.ECounters
	}
	return nil
}

// GetICounters returns the value of the ICounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer. If the receiver or the field ICounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer) GetICounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters {
	if t != nil && t.ICounters != nil {
		return t.ICounters
	}
	return nil
}

// GetAll retrieves the value of the leaf All from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if All is set, it can
// safely use t.GetAll() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.All == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer) GetAll() YANGEmpty {
	if t == nil || t.All == false {
		return false
	}
	return t.All
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer) GetId() uint32 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ECounters.PopulateDefaults()
	t.ICounters.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/ref-policer/e-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters struct {
	ExceedProfileOctetsDiscardedCount  *bool `path:"exceed-profile-octets-discarded-count" module:"nokia-conf"`
	ExceedProfileOctetsForwardedCount  *bool `path:"exceed-profile-octets-forwarded-count" module:"nokia-conf"`
	ExceedProfileOctetsOfferedCount    *bool `path:"exceed-profile-octets-offered-count" module:"nokia-conf"`
	ExceedProfilePacketsDiscardedCount *bool `path:"exceed-profile-packets-discarded-count" module:"nokia-conf"`
	ExceedProfilePacketsForwardedCount *bool `path:"exceed-profile-packets-forwarded-count" module:"nokia-conf"`
	ExceedProfilePacketsOfferedCount   *bool `path:"exceed-profile-packets-offered-count" module:"nokia-conf"`
	InPlusProfileOctetsDiscardedCount  *bool `path:"in-plus-profile-octets-discarded-count" module:"nokia-conf"`
	InPlusProfileOctetsForwardedCount  *bool `path:"in-plus-profile-octets-forwarded-count" module:"nokia-conf"`
	InPlusProfileOctetsOfferedCount    *bool `path:"in-plus-profile-octets-offered-count" module:"nokia-conf"`
	InPlusProfilePacketsDiscardedCount *bool `path:"in-plus-profile-packets-discarded-count" module:"nokia-conf"`
	InPlusProfilePacketsForwardedCount *bool `path:"in-plus-profile-packets-forwarded-count" module:"nokia-conf"`
	InPlusProfilePacketsOfferedCount   *bool `path:"in-plus-profile-packets-offered-count" module:"nokia-conf"`
	InProfileOctetsDiscardedCount      *bool `path:"in-profile-octets-discarded-count" module:"nokia-conf"`
	InProfileOctetsForwardedCount      *bool `path:"in-profile-octets-forwarded-count" module:"nokia-conf"`
	InProfileOctetsOfferedCount        *bool `path:"in-profile-octets-offered-count" module:"nokia-conf"`
	InProfilePacketsDiscardedCount     *bool `path:"in-profile-packets-discarded-count" module:"nokia-conf"`
	InProfilePacketsForwardedCount     *bool `path:"in-profile-packets-forwarded-count" module:"nokia-conf"`
	InProfilePacketsOfferedCount       *bool `path:"in-profile-packets-offered-count" module:"nokia-conf"`
	OutProfileOctetsDiscardedCount     *bool `path:"out-profile-octets-discarded-count" module:"nokia-conf"`
	OutProfileOctetsForwardedCount     *bool `path:"out-profile-octets-forwarded-count" module:"nokia-conf"`
	OutProfileOctetsOfferedCount       *bool `path:"out-profile-octets-offered-count" module:"nokia-conf"`
	OutProfilePacketsDiscardedCount    *bool `path:"out-profile-packets-discarded-count" module:"nokia-conf"`
	OutProfilePacketsForwardedCount    *bool `path:"out-profile-packets-forwarded-count" module:"nokia-conf"`
	OutProfilePacketsOfferedCount      *bool `path:"out-profile-packets-offered-count" module:"nokia-conf"`
	UncolouredOctetsOfferedCount       *bool `path:"uncoloured-octets-offered-count" module:"nokia-conf"`
	UncolouredPacketsOfferedCount      *bool `path:"uncoloured-packets-offered-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) IsYANGGoStruct() {
}

// GetExceedProfileOctetsDiscardedCount retrieves the value of the leaf ExceedProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceedProfileOctetsDiscardedCount is set, it can
// safely use t.GetExceedProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceedProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetExceedProfileOctetsDiscardedCount() bool {
	if t == nil || t.ExceedProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.ExceedProfileOctetsDiscardedCount
}

// GetExceedProfileOctetsForwardedCount retrieves the value of the leaf ExceedProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceedProfileOctetsForwardedCount is set, it can
// safely use t.GetExceedProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceedProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetExceedProfileOctetsForwardedCount() bool {
	if t == nil || t.ExceedProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.ExceedProfileOctetsForwardedCount
}

// GetExceedProfileOctetsOfferedCount retrieves the value of the leaf ExceedProfileOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceedProfileOctetsOfferedCount is set, it can
// safely use t.GetExceedProfileOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceedProfileOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetExceedProfileOctetsOfferedCount() bool {
	if t == nil || t.ExceedProfileOctetsOfferedCount == nil {
		return false
	}
	return *t.ExceedProfileOctetsOfferedCount
}

// GetExceedProfilePacketsDiscardedCount retrieves the value of the leaf ExceedProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceedProfilePacketsDiscardedCount is set, it can
// safely use t.GetExceedProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceedProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetExceedProfilePacketsDiscardedCount() bool {
	if t == nil || t.ExceedProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.ExceedProfilePacketsDiscardedCount
}

// GetExceedProfilePacketsForwardedCount retrieves the value of the leaf ExceedProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceedProfilePacketsForwardedCount is set, it can
// safely use t.GetExceedProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceedProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetExceedProfilePacketsForwardedCount() bool {
	if t == nil || t.ExceedProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.ExceedProfilePacketsForwardedCount
}

// GetExceedProfilePacketsOfferedCount retrieves the value of the leaf ExceedProfilePacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ExceedProfilePacketsOfferedCount is set, it can
// safely use t.GetExceedProfilePacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ExceedProfilePacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetExceedProfilePacketsOfferedCount() bool {
	if t == nil || t.ExceedProfilePacketsOfferedCount == nil {
		return false
	}
	return *t.ExceedProfilePacketsOfferedCount
}

// GetInPlusProfileOctetsDiscardedCount retrieves the value of the leaf InPlusProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPlusProfileOctetsDiscardedCount is set, it can
// safely use t.GetInPlusProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPlusProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetInPlusProfileOctetsDiscardedCount() bool {
	if t == nil || t.InPlusProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.InPlusProfileOctetsDiscardedCount
}

// GetInPlusProfileOctetsForwardedCount retrieves the value of the leaf InPlusProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPlusProfileOctetsForwardedCount is set, it can
// safely use t.GetInPlusProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPlusProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetInPlusProfileOctetsForwardedCount() bool {
	if t == nil || t.InPlusProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InPlusProfileOctetsForwardedCount
}

// GetInPlusProfileOctetsOfferedCount retrieves the value of the leaf InPlusProfileOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPlusProfileOctetsOfferedCount is set, it can
// safely use t.GetInPlusProfileOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPlusProfileOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetInPlusProfileOctetsOfferedCount() bool {
	if t == nil || t.InPlusProfileOctetsOfferedCount == nil {
		return false
	}
	return *t.InPlusProfileOctetsOfferedCount
}

// GetInPlusProfilePacketsDiscardedCount retrieves the value of the leaf InPlusProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPlusProfilePacketsDiscardedCount is set, it can
// safely use t.GetInPlusProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPlusProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetInPlusProfilePacketsDiscardedCount() bool {
	if t == nil || t.InPlusProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.InPlusProfilePacketsDiscardedCount
}

// GetInPlusProfilePacketsForwardedCount retrieves the value of the leaf InPlusProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPlusProfilePacketsForwardedCount is set, it can
// safely use t.GetInPlusProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPlusProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetInPlusProfilePacketsForwardedCount() bool {
	if t == nil || t.InPlusProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InPlusProfilePacketsForwardedCount
}

// GetInPlusProfilePacketsOfferedCount retrieves the value of the leaf InPlusProfilePacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InPlusProfilePacketsOfferedCount is set, it can
// safely use t.GetInPlusProfilePacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InPlusProfilePacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetInPlusProfilePacketsOfferedCount() bool {
	if t == nil || t.InPlusProfilePacketsOfferedCount == nil {
		return false
	}
	return *t.InPlusProfilePacketsOfferedCount
}

// GetInProfileOctetsDiscardedCount retrieves the value of the leaf InProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsDiscardedCount is set, it can
// safely use t.GetInProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetInProfileOctetsDiscardedCount() bool {
	if t == nil || t.InProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.InProfileOctetsDiscardedCount
}

// GetInProfileOctetsForwardedCount retrieves the value of the leaf InProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsForwardedCount is set, it can
// safely use t.GetInProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetInProfileOctetsForwardedCount() bool {
	if t == nil || t.InProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InProfileOctetsForwardedCount
}

// GetInProfileOctetsOfferedCount retrieves the value of the leaf InProfileOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsOfferedCount is set, it can
// safely use t.GetInProfileOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetInProfileOctetsOfferedCount() bool {
	if t == nil || t.InProfileOctetsOfferedCount == nil {
		return false
	}
	return *t.InProfileOctetsOfferedCount
}

// GetInProfilePacketsDiscardedCount retrieves the value of the leaf InProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsDiscardedCount is set, it can
// safely use t.GetInProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetInProfilePacketsDiscardedCount() bool {
	if t == nil || t.InProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.InProfilePacketsDiscardedCount
}

// GetInProfilePacketsForwardedCount retrieves the value of the leaf InProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsForwardedCount is set, it can
// safely use t.GetInProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetInProfilePacketsForwardedCount() bool {
	if t == nil || t.InProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InProfilePacketsForwardedCount
}

// GetInProfilePacketsOfferedCount retrieves the value of the leaf InProfilePacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsOfferedCount is set, it can
// safely use t.GetInProfilePacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetInProfilePacketsOfferedCount() bool {
	if t == nil || t.InProfilePacketsOfferedCount == nil {
		return false
	}
	return *t.InProfilePacketsOfferedCount
}

// GetOutProfileOctetsDiscardedCount retrieves the value of the leaf OutProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsDiscardedCount is set, it can
// safely use t.GetOutProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetOutProfileOctetsDiscardedCount() bool {
	if t == nil || t.OutProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsDiscardedCount
}

// GetOutProfileOctetsForwardedCount retrieves the value of the leaf OutProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsForwardedCount is set, it can
// safely use t.GetOutProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetOutProfileOctetsForwardedCount() bool {
	if t == nil || t.OutProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsForwardedCount
}

// GetOutProfileOctetsOfferedCount retrieves the value of the leaf OutProfileOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsOfferedCount is set, it can
// safely use t.GetOutProfileOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetOutProfileOctetsOfferedCount() bool {
	if t == nil || t.OutProfileOctetsOfferedCount == nil {
		return false
	}
	return *t.OutProfileOctetsOfferedCount
}

// GetOutProfilePacketsDiscardedCount retrieves the value of the leaf OutProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsDiscardedCount is set, it can
// safely use t.GetOutProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetOutProfilePacketsDiscardedCount() bool {
	if t == nil || t.OutProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsDiscardedCount
}

// GetOutProfilePacketsForwardedCount retrieves the value of the leaf OutProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsForwardedCount is set, it can
// safely use t.GetOutProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetOutProfilePacketsForwardedCount() bool {
	if t == nil || t.OutProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsForwardedCount
}

// GetOutProfilePacketsOfferedCount retrieves the value of the leaf OutProfilePacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsOfferedCount is set, it can
// safely use t.GetOutProfilePacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetOutProfilePacketsOfferedCount() bool {
	if t == nil || t.OutProfilePacketsOfferedCount == nil {
		return false
	}
	return *t.OutProfilePacketsOfferedCount
}

// GetUncolouredOctetsOfferedCount retrieves the value of the leaf UncolouredOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UncolouredOctetsOfferedCount is set, it can
// safely use t.GetUncolouredOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UncolouredOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetUncolouredOctetsOfferedCount() bool {
	if t == nil || t.UncolouredOctetsOfferedCount == nil {
		return false
	}
	return *t.UncolouredOctetsOfferedCount
}

// GetUncolouredPacketsOfferedCount retrieves the value of the leaf UncolouredPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UncolouredPacketsOfferedCount is set, it can
// safely use t.GetUncolouredPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UncolouredPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) GetUncolouredPacketsOfferedCount() bool {
	if t == nil || t.UncolouredPacketsOfferedCount == nil {
		return false
	}
	return *t.UncolouredPacketsOfferedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.ExceedProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.ExceedProfileOctetsDiscardedCount = &v
	}
	if t.ExceedProfileOctetsForwardedCount == nil {
		var v bool = false
		t.ExceedProfileOctetsForwardedCount = &v
	}
	if t.ExceedProfileOctetsOfferedCount == nil {
		var v bool = false
		t.ExceedProfileOctetsOfferedCount = &v
	}
	if t.ExceedProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.ExceedProfilePacketsDiscardedCount = &v
	}
	if t.ExceedProfilePacketsForwardedCount == nil {
		var v bool = false
		t.ExceedProfilePacketsForwardedCount = &v
	}
	if t.ExceedProfilePacketsOfferedCount == nil {
		var v bool = false
		t.ExceedProfilePacketsOfferedCount = &v
	}
	if t.InPlusProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.InPlusProfileOctetsDiscardedCount = &v
	}
	if t.InPlusProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InPlusProfileOctetsForwardedCount = &v
	}
	if t.InPlusProfileOctetsOfferedCount == nil {
		var v bool = false
		t.InPlusProfileOctetsOfferedCount = &v
	}
	if t.InPlusProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.InPlusProfilePacketsDiscardedCount = &v
	}
	if t.InPlusProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InPlusProfilePacketsForwardedCount = &v
	}
	if t.InPlusProfilePacketsOfferedCount == nil {
		var v bool = false
		t.InPlusProfilePacketsOfferedCount = &v
	}
	if t.InProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.InProfileOctetsDiscardedCount = &v
	}
	if t.InProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InProfileOctetsForwardedCount = &v
	}
	if t.InProfileOctetsOfferedCount == nil {
		var v bool = false
		t.InProfileOctetsOfferedCount = &v
	}
	if t.InProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.InProfilePacketsDiscardedCount = &v
	}
	if t.InProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InProfilePacketsForwardedCount = &v
	}
	if t.InProfilePacketsOfferedCount == nil {
		var v bool = false
		t.InProfilePacketsOfferedCount = &v
	}
	if t.OutProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.OutProfileOctetsDiscardedCount = &v
	}
	if t.OutProfileOctetsForwardedCount == nil {
		var v bool = false
		t.OutProfileOctetsForwardedCount = &v
	}
	if t.OutProfileOctetsOfferedCount == nil {
		var v bool = false
		t.OutProfileOctetsOfferedCount = &v
	}
	if t.OutProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.OutProfilePacketsDiscardedCount = &v
	}
	if t.OutProfilePacketsForwardedCount == nil {
		var v bool = false
		t.OutProfilePacketsForwardedCount = &v
	}
	if t.OutProfilePacketsOfferedCount == nil {
		var v bool = false
		t.OutProfilePacketsOfferedCount = &v
	}
	if t.UncolouredOctetsOfferedCount == nil {
		var v bool = false
		t.UncolouredOctetsOfferedCount = &v
	}
	if t.UncolouredPacketsOfferedCount == nil {
		var v bool = false
		t.UncolouredPacketsOfferedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ECounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/ref-policer/i-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters struct {
	InProfileOctetsDiscardedCount   *bool `path:"in-profile-octets-discarded-count" module:"nokia-conf"`
	InProfileOctetsForwardedCount   *bool `path:"in-profile-octets-forwarded-count" module:"nokia-conf"`
	InProfileOctetsOfferedCount     *bool `path:"in-profile-octets-offered-count" module:"nokia-conf"`
	InProfilePacketsDiscardedCount  *bool `path:"in-profile-packets-discarded-count" module:"nokia-conf"`
	InProfilePacketsForwardedCount  *bool `path:"in-profile-packets-forwarded-count" module:"nokia-conf"`
	InProfilePacketsOfferedCount    *bool `path:"in-profile-packets-offered-count" module:"nokia-conf"`
	OutProfileOctetsDiscardedCount  *bool `path:"out-profile-octets-discarded-count" module:"nokia-conf"`
	OutProfileOctetsForwardedCount  *bool `path:"out-profile-octets-forwarded-count" module:"nokia-conf"`
	OutProfileOctetsOfferedCount    *bool `path:"out-profile-octets-offered-count" module:"nokia-conf"`
	OutProfilePacketsDiscardedCount *bool `path:"out-profile-packets-discarded-count" module:"nokia-conf"`
	OutProfilePacketsForwardedCount *bool `path:"out-profile-packets-forwarded-count" module:"nokia-conf"`
	OutProfilePacketsOfferedCount   *bool `path:"out-profile-packets-offered-count" module:"nokia-conf"`
	UncolouredOctetsOfferedCount    *bool `path:"uncoloured-octets-offered-count" module:"nokia-conf"`
	UncolouredPacketsOfferedCount   *bool `path:"uncoloured-packets-offered-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) IsYANGGoStruct() {
}

// GetInProfileOctetsDiscardedCount retrieves the value of the leaf InProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsDiscardedCount is set, it can
// safely use t.GetInProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetInProfileOctetsDiscardedCount() bool {
	if t == nil || t.InProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.InProfileOctetsDiscardedCount
}

// GetInProfileOctetsForwardedCount retrieves the value of the leaf InProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsForwardedCount is set, it can
// safely use t.GetInProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetInProfileOctetsForwardedCount() bool {
	if t == nil || t.InProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InProfileOctetsForwardedCount
}

// GetInProfileOctetsOfferedCount retrieves the value of the leaf InProfileOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsOfferedCount is set, it can
// safely use t.GetInProfileOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetInProfileOctetsOfferedCount() bool {
	if t == nil || t.InProfileOctetsOfferedCount == nil {
		return false
	}
	return *t.InProfileOctetsOfferedCount
}

// GetInProfilePacketsDiscardedCount retrieves the value of the leaf InProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsDiscardedCount is set, it can
// safely use t.GetInProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetInProfilePacketsDiscardedCount() bool {
	if t == nil || t.InProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.InProfilePacketsDiscardedCount
}

// GetInProfilePacketsForwardedCount retrieves the value of the leaf InProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsForwardedCount is set, it can
// safely use t.GetInProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetInProfilePacketsForwardedCount() bool {
	if t == nil || t.InProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InProfilePacketsForwardedCount
}

// GetInProfilePacketsOfferedCount retrieves the value of the leaf InProfilePacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsOfferedCount is set, it can
// safely use t.GetInProfilePacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetInProfilePacketsOfferedCount() bool {
	if t == nil || t.InProfilePacketsOfferedCount == nil {
		return false
	}
	return *t.InProfilePacketsOfferedCount
}

// GetOutProfileOctetsDiscardedCount retrieves the value of the leaf OutProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsDiscardedCount is set, it can
// safely use t.GetOutProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetOutProfileOctetsDiscardedCount() bool {
	if t == nil || t.OutProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsDiscardedCount
}

// GetOutProfileOctetsForwardedCount retrieves the value of the leaf OutProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsForwardedCount is set, it can
// safely use t.GetOutProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetOutProfileOctetsForwardedCount() bool {
	if t == nil || t.OutProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsForwardedCount
}

// GetOutProfileOctetsOfferedCount retrieves the value of the leaf OutProfileOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsOfferedCount is set, it can
// safely use t.GetOutProfileOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetOutProfileOctetsOfferedCount() bool {
	if t == nil || t.OutProfileOctetsOfferedCount == nil {
		return false
	}
	return *t.OutProfileOctetsOfferedCount
}

// GetOutProfilePacketsDiscardedCount retrieves the value of the leaf OutProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsDiscardedCount is set, it can
// safely use t.GetOutProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetOutProfilePacketsDiscardedCount() bool {
	if t == nil || t.OutProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsDiscardedCount
}

// GetOutProfilePacketsForwardedCount retrieves the value of the leaf OutProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsForwardedCount is set, it can
// safely use t.GetOutProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetOutProfilePacketsForwardedCount() bool {
	if t == nil || t.OutProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsForwardedCount
}

// GetOutProfilePacketsOfferedCount retrieves the value of the leaf OutProfilePacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsOfferedCount is set, it can
// safely use t.GetOutProfilePacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetOutProfilePacketsOfferedCount() bool {
	if t == nil || t.OutProfilePacketsOfferedCount == nil {
		return false
	}
	return *t.OutProfilePacketsOfferedCount
}

// GetUncolouredOctetsOfferedCount retrieves the value of the leaf UncolouredOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UncolouredOctetsOfferedCount is set, it can
// safely use t.GetUncolouredOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UncolouredOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetUncolouredOctetsOfferedCount() bool {
	if t == nil || t.UncolouredOctetsOfferedCount == nil {
		return false
	}
	return *t.UncolouredOctetsOfferedCount
}

// GetUncolouredPacketsOfferedCount retrieves the value of the leaf UncolouredPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UncolouredPacketsOfferedCount is set, it can
// safely use t.GetUncolouredPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UncolouredPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) GetUncolouredPacketsOfferedCount() bool {
	if t == nil || t.UncolouredPacketsOfferedCount == nil {
		return false
	}
	return *t.UncolouredPacketsOfferedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.InProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.InProfileOctetsDiscardedCount = &v
	}
	if t.InProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InProfileOctetsForwardedCount = &v
	}
	if t.InProfileOctetsOfferedCount == nil {
		var v bool = false
		t.InProfileOctetsOfferedCount = &v
	}
	if t.InProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.InProfilePacketsDiscardedCount = &v
	}
	if t.InProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InProfilePacketsForwardedCount = &v
	}
	if t.InProfilePacketsOfferedCount == nil {
		var v bool = false
		t.InProfilePacketsOfferedCount = &v
	}
	if t.OutProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.OutProfileOctetsDiscardedCount = &v
	}
	if t.OutProfileOctetsForwardedCount == nil {
		var v bool = false
		t.OutProfileOctetsForwardedCount = &v
	}
	if t.OutProfileOctetsOfferedCount == nil {
		var v bool = false
		t.OutProfileOctetsOfferedCount = &v
	}
	if t.OutProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.OutProfilePacketsDiscardedCount = &v
	}
	if t.OutProfilePacketsForwardedCount == nil {
		var v bool = false
		t.OutProfilePacketsForwardedCount = &v
	}
	if t.OutProfilePacketsOfferedCount == nil {
		var v bool = false
		t.OutProfilePacketsOfferedCount = &v
	}
	if t.UncolouredOctetsOfferedCount == nil {
		var v bool = false
		t.UncolouredOctetsOfferedCount = &v
	}
	if t.UncolouredPacketsOfferedCount == nil {
		var v bool = false
		t.UncolouredPacketsOfferedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefPolicer_ICounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/ref-queue YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue struct {
	All       YANGEmpty                                                                              `path:"all" module:"nokia-conf"`
	ECounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters `path:"e-counters" module:"nokia-conf"`
	ICounters *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters `path:"i-counters" module:"nokia-conf"`
	Id        *uint32                                                                                `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue) IsYANGGoStruct() {
}

// GetOrCreateECounters retrieves the value of the ECounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue) GetOrCreateECounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters {
	if t.ECounters != nil {
		return t.ECounters
	}
	t.ECounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters{}
	return t.ECounters
}

// GetOrCreateICounters retrieves the value of the ICounters field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue) GetOrCreateICounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters {
	if t.ICounters != nil {
		return t.ICounters
	}
	t.ICounters = &NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters{}
	return t.ICounters
}

// GetECounters returns the value of the ECounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue. If the receiver or the field ECounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue) GetECounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters {
	if t != nil && t.ECounters != nil {
		return t.ECounters
	}
	return nil
}

// GetICounters returns the value of the ICounters struct pointer
// from NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue. If the receiver or the field ICounters is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue) GetICounters() *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters {
	if t != nil && t.ICounters != nil {
		return t.ICounters
	}
	return nil
}

// GetAll retrieves the value of the leaf All from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if All is set, it can
// safely use t.GetAll() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.All == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue) GetAll() YANGEmpty {
	if t == nil || t.All == false {
		return false
	}
	return t.All
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue) GetId() uint32 {
	if t == nil || t.Id == nil {
		return 0
	}
	return *t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	t.ECounters.PopulateDefaults()
	t.ICounters.PopulateDefaults()
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/ref-queue/e-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters struct {
	InProfileOctetsDiscardedCount   *bool `path:"in-profile-octets-discarded-count" module:"nokia-conf"`
	InProfileOctetsForwardedCount   *bool `path:"in-profile-octets-forwarded-count" module:"nokia-conf"`
	InProfilePacketsDiscardedCount  *bool `path:"in-profile-packets-discarded-count" module:"nokia-conf"`
	InProfilePacketsForwardedCount  *bool `path:"in-profile-packets-forwarded-count" module:"nokia-conf"`
	OutProfileOctetsDiscardedCount  *bool `path:"out-profile-octets-discarded-count" module:"nokia-conf"`
	OutProfileOctetsForwardedCount  *bool `path:"out-profile-octets-forwarded-count" module:"nokia-conf"`
	OutProfilePacketsDiscardedCount *bool `path:"out-profile-packets-discarded-count" module:"nokia-conf"`
	OutProfilePacketsForwardedCount *bool `path:"out-profile-packets-forwarded-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) IsYANGGoStruct() {
}

// GetInProfileOctetsDiscardedCount retrieves the value of the leaf InProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsDiscardedCount is set, it can
// safely use t.GetInProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) GetInProfileOctetsDiscardedCount() bool {
	if t == nil || t.InProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.InProfileOctetsDiscardedCount
}

// GetInProfileOctetsForwardedCount retrieves the value of the leaf InProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsForwardedCount is set, it can
// safely use t.GetInProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) GetInProfileOctetsForwardedCount() bool {
	if t == nil || t.InProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InProfileOctetsForwardedCount
}

// GetInProfilePacketsDiscardedCount retrieves the value of the leaf InProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsDiscardedCount is set, it can
// safely use t.GetInProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) GetInProfilePacketsDiscardedCount() bool {
	if t == nil || t.InProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.InProfilePacketsDiscardedCount
}

// GetInProfilePacketsForwardedCount retrieves the value of the leaf InProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsForwardedCount is set, it can
// safely use t.GetInProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) GetInProfilePacketsForwardedCount() bool {
	if t == nil || t.InProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InProfilePacketsForwardedCount
}

// GetOutProfileOctetsDiscardedCount retrieves the value of the leaf OutProfileOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsDiscardedCount is set, it can
// safely use t.GetOutProfileOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) GetOutProfileOctetsDiscardedCount() bool {
	if t == nil || t.OutProfileOctetsDiscardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsDiscardedCount
}

// GetOutProfileOctetsForwardedCount retrieves the value of the leaf OutProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsForwardedCount is set, it can
// safely use t.GetOutProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) GetOutProfileOctetsForwardedCount() bool {
	if t == nil || t.OutProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsForwardedCount
}

// GetOutProfilePacketsDiscardedCount retrieves the value of the leaf OutProfilePacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsDiscardedCount is set, it can
// safely use t.GetOutProfilePacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) GetOutProfilePacketsDiscardedCount() bool {
	if t == nil || t.OutProfilePacketsDiscardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsDiscardedCount
}

// GetOutProfilePacketsForwardedCount retrieves the value of the leaf OutProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsForwardedCount is set, it can
// safely use t.GetOutProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) GetOutProfilePacketsForwardedCount() bool {
	if t == nil || t.OutProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsForwardedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.InProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.InProfileOctetsDiscardedCount = &v
	}
	if t.InProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InProfileOctetsForwardedCount = &v
	}
	if t.InProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.InProfilePacketsDiscardedCount = &v
	}
	if t.InProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InProfilePacketsForwardedCount = &v
	}
	if t.OutProfileOctetsDiscardedCount == nil {
		var v bool = false
		t.OutProfileOctetsDiscardedCount = &v
	}
	if t.OutProfileOctetsForwardedCount == nil {
		var v bool = false
		t.OutProfileOctetsForwardedCount = &v
	}
	if t.OutProfilePacketsDiscardedCount == nil {
		var v bool = false
		t.OutProfilePacketsDiscardedCount = &v
	}
	if t.OutProfilePacketsForwardedCount == nil {
		var v bool = false
		t.OutProfilePacketsForwardedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ECounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters represents the /nokia-conf/configure/groups/group/log/accounting-policy/custom-record/ref-queue/i-counters YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters struct {
	AllOctetsOfferedCount           *bool `path:"all-octets-offered-count" module:"nokia-conf"`
	AllPacketsOfferedCount          *bool `path:"all-packets-offered-count" module:"nokia-conf"`
	HighOctetsDiscardedCount        *bool `path:"high-octets-discarded-count" module:"nokia-conf"`
	HighOctetsOfferedCount          *bool `path:"high-octets-offered-count" module:"nokia-conf"`
	HighPacketsDiscardedCount       *bool `path:"high-packets-discarded-count" module:"nokia-conf"`
	HighPacketsOfferedCount         *bool `path:"high-packets-offered-count" module:"nokia-conf"`
	InProfileOctetsForwardedCount   *bool `path:"in-profile-octets-forwarded-count" module:"nokia-conf"`
	InProfilePacketsForwardedCount  *bool `path:"in-profile-packets-forwarded-count" module:"nokia-conf"`
	LowOctetsDiscardedCount         *bool `path:"low-octets-discarded-count" module:"nokia-conf"`
	LowOctetsOfferedCount           *bool `path:"low-octets-offered-count" module:"nokia-conf"`
	LowPacketsDiscardedCount        *bool `path:"low-packets-discarded-count" module:"nokia-conf"`
	LowPacketsOfferedCount          *bool `path:"low-packets-offered-count" module:"nokia-conf"`
	OutProfileOctetsForwardedCount  *bool `path:"out-profile-octets-forwarded-count" module:"nokia-conf"`
	OutProfilePacketsForwardedCount *bool `path:"out-profile-packets-forwarded-count" module:"nokia-conf"`
	UncolouredOctetsOfferedCount    *bool `path:"uncoloured-octets-offered-count" module:"nokia-conf"`
	UncolouredPacketsOfferedCount   *bool `path:"uncoloured-packets-offered-count" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) IsYANGGoStruct() {
}

// GetAllOctetsOfferedCount retrieves the value of the leaf AllOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllOctetsOfferedCount is set, it can
// safely use t.GetAllOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetAllOctetsOfferedCount() bool {
	if t == nil || t.AllOctetsOfferedCount == nil {
		return false
	}
	return *t.AllOctetsOfferedCount
}

// GetAllPacketsOfferedCount retrieves the value of the leaf AllPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AllPacketsOfferedCount is set, it can
// safely use t.GetAllPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AllPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetAllPacketsOfferedCount() bool {
	if t == nil || t.AllPacketsOfferedCount == nil {
		return false
	}
	return *t.AllPacketsOfferedCount
}

// GetHighOctetsDiscardedCount retrieves the value of the leaf HighOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighOctetsDiscardedCount is set, it can
// safely use t.GetHighOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetHighOctetsDiscardedCount() bool {
	if t == nil || t.HighOctetsDiscardedCount == nil {
		return false
	}
	return *t.HighOctetsDiscardedCount
}

// GetHighOctetsOfferedCount retrieves the value of the leaf HighOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighOctetsOfferedCount is set, it can
// safely use t.GetHighOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetHighOctetsOfferedCount() bool {
	if t == nil || t.HighOctetsOfferedCount == nil {
		return false
	}
	return *t.HighOctetsOfferedCount
}

// GetHighPacketsDiscardedCount retrieves the value of the leaf HighPacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighPacketsDiscardedCount is set, it can
// safely use t.GetHighPacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighPacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetHighPacketsDiscardedCount() bool {
	if t == nil || t.HighPacketsDiscardedCount == nil {
		return false
	}
	return *t.HighPacketsDiscardedCount
}

// GetHighPacketsOfferedCount retrieves the value of the leaf HighPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if HighPacketsOfferedCount is set, it can
// safely use t.GetHighPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.HighPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetHighPacketsOfferedCount() bool {
	if t == nil || t.HighPacketsOfferedCount == nil {
		return false
	}
	return *t.HighPacketsOfferedCount
}

// GetInProfileOctetsForwardedCount retrieves the value of the leaf InProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfileOctetsForwardedCount is set, it can
// safely use t.GetInProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetInProfileOctetsForwardedCount() bool {
	if t == nil || t.InProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.InProfileOctetsForwardedCount
}

// GetInProfilePacketsForwardedCount retrieves the value of the leaf InProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if InProfilePacketsForwardedCount is set, it can
// safely use t.GetInProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.InProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetInProfilePacketsForwardedCount() bool {
	if t == nil || t.InProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.InProfilePacketsForwardedCount
}

// GetLowOctetsDiscardedCount retrieves the value of the leaf LowOctetsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowOctetsDiscardedCount is set, it can
// safely use t.GetLowOctetsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowOctetsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetLowOctetsDiscardedCount() bool {
	if t == nil || t.LowOctetsDiscardedCount == nil {
		return false
	}
	return *t.LowOctetsDiscardedCount
}

// GetLowOctetsOfferedCount retrieves the value of the leaf LowOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowOctetsOfferedCount is set, it can
// safely use t.GetLowOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetLowOctetsOfferedCount() bool {
	if t == nil || t.LowOctetsOfferedCount == nil {
		return false
	}
	return *t.LowOctetsOfferedCount
}

// GetLowPacketsDiscardedCount retrieves the value of the leaf LowPacketsDiscardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowPacketsDiscardedCount is set, it can
// safely use t.GetLowPacketsDiscardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowPacketsDiscardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetLowPacketsDiscardedCount() bool {
	if t == nil || t.LowPacketsDiscardedCount == nil {
		return false
	}
	return *t.LowPacketsDiscardedCount
}

// GetLowPacketsOfferedCount retrieves the value of the leaf LowPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if LowPacketsOfferedCount is set, it can
// safely use t.GetLowPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.LowPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetLowPacketsOfferedCount() bool {
	if t == nil || t.LowPacketsOfferedCount == nil {
		return false
	}
	return *t.LowPacketsOfferedCount
}

// GetOutProfileOctetsForwardedCount retrieves the value of the leaf OutProfileOctetsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfileOctetsForwardedCount is set, it can
// safely use t.GetOutProfileOctetsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfileOctetsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetOutProfileOctetsForwardedCount() bool {
	if t == nil || t.OutProfileOctetsForwardedCount == nil {
		return false
	}
	return *t.OutProfileOctetsForwardedCount
}

// GetOutProfilePacketsForwardedCount retrieves the value of the leaf OutProfilePacketsForwardedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if OutProfilePacketsForwardedCount is set, it can
// safely use t.GetOutProfilePacketsForwardedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.OutProfilePacketsForwardedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetOutProfilePacketsForwardedCount() bool {
	if t == nil || t.OutProfilePacketsForwardedCount == nil {
		return false
	}
	return *t.OutProfilePacketsForwardedCount
}

// GetUncolouredOctetsOfferedCount retrieves the value of the leaf UncolouredOctetsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UncolouredOctetsOfferedCount is set, it can
// safely use t.GetUncolouredOctetsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UncolouredOctetsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetUncolouredOctetsOfferedCount() bool {
	if t == nil || t.UncolouredOctetsOfferedCount == nil {
		return false
	}
	return *t.UncolouredOctetsOfferedCount
}

// GetUncolouredPacketsOfferedCount retrieves the value of the leaf UncolouredPacketsOfferedCount from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if UncolouredPacketsOfferedCount is set, it can
// safely use t.GetUncolouredPacketsOfferedCount() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.UncolouredPacketsOfferedCount == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) GetUncolouredPacketsOfferedCount() bool {
	if t == nil || t.UncolouredPacketsOfferedCount == nil {
		return false
	}
	return *t.UncolouredPacketsOfferedCount
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AllOctetsOfferedCount == nil {
		var v bool = false
		t.AllOctetsOfferedCount = &v
	}
	if t.AllPacketsOfferedCount == nil {
		var v bool = false
		t.AllPacketsOfferedCount = &v
	}
	if t.HighOctetsDiscardedCount == nil {
		var v bool = false
		t.HighOctetsDiscardedCount = &v
	}
	if t.HighOctetsOfferedCount == nil {
		var v bool = false
		t.HighOctetsOfferedCount = &v
	}
	if t.HighPacketsDiscardedCount == nil {
		var v bool = false
		t.HighPacketsDiscardedCount = &v
	}
	if t.HighPacketsOfferedCount == nil {
		var v bool = false
		t.HighPacketsOfferedCount = &v
	}
	if t.InProfileOctetsForwardedCount == nil {
		var v bool = false
		t.InProfileOctetsForwardedCount = &v
	}
	if t.InProfilePacketsForwardedCount == nil {
		var v bool = false
		t.InProfilePacketsForwardedCount = &v
	}
	if t.LowOctetsDiscardedCount == nil {
		var v bool = false
		t.LowOctetsDiscardedCount = &v
	}
	if t.LowOctetsOfferedCount == nil {
		var v bool = false
		t.LowOctetsOfferedCount = &v
	}
	if t.LowPacketsDiscardedCount == nil {
		var v bool = false
		t.LowPacketsDiscardedCount = &v
	}
	if t.LowPacketsOfferedCount == nil {
		var v bool = false
		t.LowPacketsOfferedCount = &v
	}
	if t.OutProfileOctetsForwardedCount == nil {
		var v bool = false
		t.OutProfileOctetsForwardedCount = &v
	}
	if t.OutProfilePacketsForwardedCount == nil {
		var v bool = false
		t.OutProfilePacketsForwardedCount = &v
	}
	if t.UncolouredOctetsOfferedCount == nil {
		var v bool = false
		t.UncolouredOctetsOfferedCount = &v
	}
	if t.UncolouredPacketsOfferedCount == nil {
		var v bool = false
		t.UncolouredPacketsOfferedCount = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_CustomRecord_RefQueue_ICounters) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination represents the /nokia-conf/configure/groups/group/log/accounting-policy/destination YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination struct {
	File *string   `path:"file" module:"nokia-conf"`
	Null YANGEmpty `path:"null" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination) IsYANGGoStruct() {}

// GetFile retrieves the value of the leaf File from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if File is set, it can
// safely use t.GetFile() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.File == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination) GetFile() string {
	if t == nil || t.File == nil {
		return ""
	}
	return *t.File
}

// GetNull retrieves the value of the leaf Null from the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Null is set, it can
// safely use t.GetNull() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Null == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination) GetNull() YANGEmpty {
	if t == nil || t.Null == false {
		return false
	}
	return t.Null
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination.
func (*NokiaConf_Configure_Groups_Group_Log_AccountingPolicy_Destination) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications represents the /nokia-conf/configure/groups/group/log/app-route-notifications YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications struct {
	ColdStartWait     *uint32 `path:"cold-start-wait" module:"nokia-conf"`
	RouteRecoveryWait *uint32 `path:"route-recovery-wait" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications) IsYANGGoStruct() {}

// GetColdStartWait retrieves the value of the leaf ColdStartWait from the NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if ColdStartWait is set, it can
// safely use t.GetColdStartWait() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.ColdStartWait == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications) GetColdStartWait() uint32 {
	if t == nil || t.ColdStartWait == nil {
		return 0
	}
	return *t.ColdStartWait
}

// GetRouteRecoveryWait retrieves the value of the leaf RouteRecoveryWait from the NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if RouteRecoveryWait is set, it can
// safely use t.GetRouteRecoveryWait() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.RouteRecoveryWait == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications) GetRouteRecoveryWait() uint32 {
	if t == nil || t.RouteRecoveryWait == nil {
		return 0
	}
	return *t.RouteRecoveryWait
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications.
func (*NokiaConf_Configure_Groups_Group_Log_AppRouteNotifications) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventHandling represents the /nokia-conf/configure/groups/group/log/event-handling YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventHandling struct {
	Handler map[string]*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler `path:"handler" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventHandling implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventHandling) IsYANGGoStruct() {}

// NewHandler creates a new entry in the Handler list of the
// NokiaConf_Configure_Groups_Group_Log_EventHandling struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling) NewHandler(Name string) (*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Handler == nil {
		t.Handler = make(map[string]*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler)
	}

	key := Name

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Handler[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Handler", key)
	}

	t.Handler[key] = &NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler{
		Name: &Name,
	}

	return t.Handler[key], nil
}

// RenameHandler renames an entry in the list Handler within
// the NokiaConf_Configure_Groups_Group_Log_EventHandling struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling) RenameHandler(oldK, newK string) error {
	if _, ok := t.Handler[newK]; ok {
		return fmt.Errorf("key %v already exists in Handler", newK)
	}

	e, ok := t.Handler[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Handler", oldK)
	}
	e.Name = &newK

	t.Handler[newK] = e
	delete(t.Handler, oldK)
	return nil
}

// GetOrCreateHandler retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventHandling. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling) GetOrCreateHandler(Name string) *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler {

	key := Name

	if v, ok := t.Handler[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewHandler(Name)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateHandler got unexpected error: %v", err))
	}
	return v
}

// GetHandler retrieves the value with the specified key from
// the Handler map field of NokiaConf_Configure_Groups_Group_Log_EventHandling. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling) GetHandler(Name string) *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler {

	if t == nil {
		return nil
	}

	key := Name

	if lm, ok := t.Handler[key]; ok {
		return lm
	}
	return nil
}

// DeleteHandler deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventHandling. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling) DeleteHandler(Name string) {
	key := Name

	delete(t.Handler, key)
}

// AppendHandler appends the supplied NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler struct to the
// list Handler of NokiaConf_Configure_Groups_Group_Log_EventHandling. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling) AppendHandler(v *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) error {
	if v.Name == nil {
		return fmt.Errorf("invalid nil key received for Name")
	}

	key := *v.Name

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Handler == nil {
		t.Handler = make(map[string]*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler)
	}

	if _, ok := t.Handler[key]; ok {
		return fmt.Errorf("duplicate key for list Handler %v", key)
	}

	t.Handler[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventHandling
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Handler {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventHandling"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventHandling.
func (*NokiaConf_Configure_Groups_Group_Log_EventHandling) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler represents the /nokia-conf/configure/groups/group/log/event-handling/handler YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                                     `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                         `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry `path:"entry" module:"nokia-conf"`
	Name        *string                                                                                                                                         `path:"name" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) ΛListKeyMap() (map[string]interface{}, error) {
	if t.Name == nil {
		return nil, fmt.Errorf("nil value for key Name")
	}

	return map[string]interface{}{
		"name": *t.Name,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler.
func (*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry represents the /nokia-conf/configure/groups/group/log/event-handling/handler/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry struct {
	AdminState   E_NokiaTypesSros_AdminState                                                    `path:"admin-state" module:"nokia-conf"`
	Description  *string                                                                        `path:"description" module:"nokia-conf"`
	Id           NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_Id_Union      `path:"id" module:"nokia-conf"`
	MinDelay     *uint32                                                                        `path:"min-delay" module:"nokia-conf"`
	ScriptPolicy *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy `path:"script-policy" module:"nokia-conf" yangPresence:"true"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) IsYANGGoStruct() {}

// GetOrCreateScriptPolicy retrieves the value of the ScriptPolicy field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) GetOrCreateScriptPolicy() *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy {
	if t.ScriptPolicy != nil {
		return t.ScriptPolicy
	}
	t.ScriptPolicy = &NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy{}
	return t.ScriptPolicy
}

// GetScriptPolicy returns the value of the ScriptPolicy struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry. If the receiver or the field ScriptPolicy is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) GetScriptPolicy() *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy {
	if t != nil && t.ScriptPolicy != nil {
		return t.ScriptPolicy
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// GetMinDelay retrieves the value of the leaf MinDelay from the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if MinDelay is set, it can
// safely use t.GetMinDelay() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.MinDelay == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) GetMinDelay() uint32 {
	if t == nil || t.MinDelay == nil {
		return 0
	}
	return *t.MinDelay
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.ScriptPolicy.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy represents the /nokia-conf/configure/groups/group/log/event-handling/handler/entry/script-policy YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy struct {
	Name  *string `path:"name" module:"nokia-conf"`
	Owner *string `path:"owner" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy) IsYANGGoStruct() {
}

// GetName retrieves the value of the leaf Name from the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Name is set, it can
// safely use t.GetName() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Name == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy) GetName() string {
	if t == nil || t.Name == nil {
		return ""
	}
	return *t.Name
}

// GetOwner retrieves the value of the leaf Owner from the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Owner is set, it can
// safely use t.GetOwner() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Owner == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy) GetOwner() string {
	if t == nil || t.Owner == nil {
		return "TiMOS CLI"
	}
	return *t.Owner
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.Owner == nil {
		var v string = "TiMOS CLI"
		t.Owner = &v
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy.
func (*NokiaConf_Configure_Groups_Group_Log_EventHandling_Handler_Entry_ScriptPolicy) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger represents the /nokia-conf/configure/groups/group/log/event-trigger YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger struct {
	Adp                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp                                   `path:"adp" module:"nokia-conf"`
	ApplicationAssurance map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance `path:"application-assurance" module:"nokia-conf"`
	Aps                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps                                   `path:"aps" module:"nokia-conf"`
	Atm                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm                                   `path:"atm" module:"nokia-conf"`
	AutoProv             map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv                         `path:"auto-prov" module:"nokia-conf"`
	Bfd                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd                                   `path:"bfd" module:"nokia-conf"`
	Bgp                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp                                   `path:"bgp" module:"nokia-conf"`
	Bier                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier                                 `path:"bier" module:"nokia-conf"`
	Calltrace            map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace                       `path:"calltrace" module:"nokia-conf"`
	Cflowd               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd                             `path:"cflowd" module:"nokia-conf"`
	Chassis              map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis                           `path:"chassis" module:"nokia-conf"`
	Debug                map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug                               `path:"debug" module:"nokia-conf"`
	Dhcp                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp                                 `path:"dhcp" module:"nokia-conf"`
	Dhcps                map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps                               `path:"dhcps" module:"nokia-conf"`
	Diameter             map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter                         `path:"diameter" module:"nokia-conf"`
	Dynsvc               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc                             `path:"dynsvc" module:"nokia-conf"`
	EfmOam               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam                             `path:"efm-oam" module:"nokia-conf"`
	Elmi                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi                                 `path:"elmi" module:"nokia-conf"`
	Ering                map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering                               `path:"ering" module:"nokia-conf"`
	EthCfm               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm                             `path:"eth-cfm" module:"nokia-conf"`
	Etun                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun                                 `path:"etun" module:"nokia-conf"`
	Filter               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter                             `path:"filter" module:"nokia-conf"`
	Gmpls                map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls                               `path:"gmpls" module:"nokia-conf"`
	Gsmp                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp                                 `path:"gsmp" module:"nokia-conf"`
	Igh                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh                                   `path:"igh" module:"nokia-conf"`
	Igmp                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp                                 `path:"igmp" module:"nokia-conf"`
	IgmpSnooping         map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping                 `path:"igmp-snooping" module:"nokia-conf"`
	Ip                   map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip                                     `path:"ip" module:"nokia-conf"`
	Ipsec                map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec                               `path:"ipsec" module:"nokia-conf"`
	Isis                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis                                 `path:"isis" module:"nokia-conf"`
	L2Tp                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp                                 `path:"l2tp" module:"nokia-conf"`
	Lag                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag                                   `path:"lag" module:"nokia-conf"`
	Ldap                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap                                 `path:"ldap" module:"nokia-conf"`
	Ldp                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp                                   `path:"ldp" module:"nokia-conf"`
	Li                   map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li                                     `path:"li" module:"nokia-conf"`
	Lldp                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp                                 `path:"lldp" module:"nokia-conf"`
	Lmp                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp                                   `path:"lmp" module:"nokia-conf"`
	Logger               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger                             `path:"logger" module:"nokia-conf"`
	Macsec               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec                             `path:"macsec" module:"nokia-conf"`
	McRedundancy         map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy                 `path:"mc-redundancy" module:"nokia-conf"`
	Mcpath               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath                             `path:"mcpath" module:"nokia-conf"`
	MgmtCore             map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore                         `path:"mgmt-core" module:"nokia-conf"`
	Mirror               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror                             `path:"mirror" module:"nokia-conf"`
	Mld                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld                                   `path:"mld" module:"nokia-conf"`
	MldSnooping          map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping                   `path:"mld-snooping" module:"nokia-conf"`
	Mpls                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls                                 `path:"mpls" module:"nokia-conf"`
	MplsTp               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp                             `path:"mpls-tp" module:"nokia-conf"`
	Msdp                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp                                 `path:"msdp" module:"nokia-conf"`
	Nat                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat                                   `path:"nat" module:"nokia-conf"`
	Ntp                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp                                   `path:"ntp" module:"nokia-conf"`
	Oam                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam                                   `path:"oam" module:"nokia-conf"`
	Openflow             map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow                         `path:"openflow" module:"nokia-conf"`
	Ospf                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf                                 `path:"ospf" module:"nokia-conf"`
	Pcap                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap                                 `path:"pcap" module:"nokia-conf"`
	Pcep                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep                                 `path:"pcep" module:"nokia-conf"`
	Pim                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim                                   `path:"pim" module:"nokia-conf"`
	PimSnooping          map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping                   `path:"pim-snooping" module:"nokia-conf"`
	Port                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port                                 `path:"port" module:"nokia-conf"`
	Ppp                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp                                   `path:"ppp" module:"nokia-conf"`
	Pppoe                map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe                               `path:"pppoe" module:"nokia-conf"`
	PppoeClnt            map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt                       `path:"pppoe-clnt" module:"nokia-conf"`
	Ptp                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp                                   `path:"ptp" module:"nokia-conf"`
	Radius               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius                             `path:"radius" module:"nokia-conf"`
	Rip                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip                                   `path:"rip" module:"nokia-conf"`
	Ripng                map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng                               `path:"ripng" module:"nokia-conf"`
	RoutePolicy          map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy                   `path:"route-policy" module:"nokia-conf"`
	Rpki                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki                                 `path:"rpki" module:"nokia-conf"`
	Rsvp                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp                                 `path:"rsvp" module:"nokia-conf"`
	Satellite            map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite                       `path:"satellite" module:"nokia-conf"`
	Security             map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security                         `path:"security" module:"nokia-conf"`
	Sflow                map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow                               `path:"sflow" module:"nokia-conf"`
	Snmp                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp                                 `path:"snmp" module:"nokia-conf"`
	SrMpls               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls                             `path:"sr-mpls" module:"nokia-conf"`
	Srv6                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6                                 `path:"srv6" module:"nokia-conf"`
	Stp                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp                                   `path:"stp" module:"nokia-conf"`
	Svcmgr               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr                             `path:"svcmgr" module:"nokia-conf"`
	System               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_System_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_System                             `path:"system" module:"nokia-conf"`
	Tls                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls                                   `path:"tls" module:"nokia-conf"`
	TreeSid              map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid                           `path:"tree-sid" module:"nokia-conf"`
	User                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_User_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_User                                 `path:"user" module:"nokia-conf"`
	Video                map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video                               `path:"video" module:"nokia-conf"`
	Vrrp                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp                                 `path:"vrrp" module:"nokia-conf"`
	Vrtr                 map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr                                 `path:"vrtr" module:"nokia-conf"`
	WlanGw               map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw                             `path:"wlan-gw" module:"nokia-conf"`
	Wpp                  map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp                                   `path:"wpp" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger) IsYANGGoStruct() {}

// NewAdp creates a new entry in the Adp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewAdp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Adp == nil {
		t.Adp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Adp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Adp", key)
	}

	t.Adp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp{
		Event: Event,
	}

	return t.Adp[key], nil
}

// RenameAdp renames an entry in the list Adp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameAdp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Event_Union) error {
	if _, ok := t.Adp[newK]; ok {
		return fmt.Errorf("key %v already exists in Adp", newK)
	}

	e, ok := t.Adp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Adp", oldK)
	}
	e.Event = newK

	t.Adp[newK] = e
	delete(t.Adp, oldK)
	return nil
}

// GetOrCreateAdp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateAdp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp {

	key := Event

	if v, ok := t.Adp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAdp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAdp got unexpected error: %v", err))
	}
	return v
}

// GetAdp retrieves the value with the specified key from
// the Adp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetAdp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Adp[key]; ok {
		return lm
	}
	return nil
}

// DeleteAdp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteAdp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Event_Union) {
	key := Event

	delete(t.Adp, key)
}

// AppendAdp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp struct to the
// list Adp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendAdp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Adp == nil {
		t.Adp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp)
	}

	if _, ok := t.Adp[key]; ok {
		return fmt.Errorf("duplicate key for list Adp %v", key)
	}

	t.Adp[key] = v
	return nil
}

// NewApplicationAssurance creates a new entry in the ApplicationAssurance list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewApplicationAssurance(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ApplicationAssurance == nil {
		t.ApplicationAssurance = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.ApplicationAssurance[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list ApplicationAssurance", key)
	}

	t.ApplicationAssurance[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance{
		Event: Event,
	}

	return t.ApplicationAssurance[key], nil
}

// RenameApplicationAssurance renames an entry in the list ApplicationAssurance within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameApplicationAssurance(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Event_Union) error {
	if _, ok := t.ApplicationAssurance[newK]; ok {
		return fmt.Errorf("key %v already exists in ApplicationAssurance", newK)
	}

	e, ok := t.ApplicationAssurance[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in ApplicationAssurance", oldK)
	}
	e.Event = newK

	t.ApplicationAssurance[newK] = e
	delete(t.ApplicationAssurance, oldK)
	return nil
}

// GetOrCreateApplicationAssurance retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateApplicationAssurance(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance {

	key := Event

	if v, ok := t.ApplicationAssurance[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewApplicationAssurance(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateApplicationAssurance got unexpected error: %v", err))
	}
	return v
}

// GetApplicationAssurance retrieves the value with the specified key from
// the ApplicationAssurance map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetApplicationAssurance(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.ApplicationAssurance[key]; ok {
		return lm
	}
	return nil
}

// DeleteApplicationAssurance deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteApplicationAssurance(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Event_Union) {
	key := Event

	delete(t.ApplicationAssurance, key)
}

// AppendApplicationAssurance appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance struct to the
// list ApplicationAssurance of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendApplicationAssurance(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.ApplicationAssurance == nil {
		t.ApplicationAssurance = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance)
	}

	if _, ok := t.ApplicationAssurance[key]; ok {
		return fmt.Errorf("duplicate key for list ApplicationAssurance %v", key)
	}

	t.ApplicationAssurance[key] = v
	return nil
}

// NewAps creates a new entry in the Aps list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewAps(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aps == nil {
		t.Aps = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Aps[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Aps", key)
	}

	t.Aps[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps{
		Event: Event,
	}

	return t.Aps[key], nil
}

// RenameAps renames an entry in the list Aps within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameAps(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Event_Union) error {
	if _, ok := t.Aps[newK]; ok {
		return fmt.Errorf("key %v already exists in Aps", newK)
	}

	e, ok := t.Aps[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Aps", oldK)
	}
	e.Event = newK

	t.Aps[newK] = e
	delete(t.Aps, oldK)
	return nil
}

// GetOrCreateAps retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateAps(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps {

	key := Event

	if v, ok := t.Aps[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAps(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAps got unexpected error: %v", err))
	}
	return v
}

// GetAps retrieves the value with the specified key from
// the Aps map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetAps(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Aps[key]; ok {
		return lm
	}
	return nil
}

// DeleteAps deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteAps(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Event_Union) {
	key := Event

	delete(t.Aps, key)
}

// AppendAps appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps struct to the
// list Aps of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendAps(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Aps == nil {
		t.Aps = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps)
	}

	if _, ok := t.Aps[key]; ok {
		return fmt.Errorf("duplicate key for list Aps %v", key)
	}

	t.Aps[key] = v
	return nil
}

// NewAtm creates a new entry in the Atm list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewAtm(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Atm == nil {
		t.Atm = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Atm[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Atm", key)
	}

	t.Atm[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm{
		Event: Event,
	}

	return t.Atm[key], nil
}

// RenameAtm renames an entry in the list Atm within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameAtm(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Event_Union) error {
	if _, ok := t.Atm[newK]; ok {
		return fmt.Errorf("key %v already exists in Atm", newK)
	}

	e, ok := t.Atm[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Atm", oldK)
	}
	e.Event = newK

	t.Atm[newK] = e
	delete(t.Atm, oldK)
	return nil
}

// GetOrCreateAtm retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateAtm(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm {

	key := Event

	if v, ok := t.Atm[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAtm(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAtm got unexpected error: %v", err))
	}
	return v
}

// GetAtm retrieves the value with the specified key from
// the Atm map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetAtm(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Atm[key]; ok {
		return lm
	}
	return nil
}

// DeleteAtm deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteAtm(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Event_Union) {
	key := Event

	delete(t.Atm, key)
}

// AppendAtm appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm struct to the
// list Atm of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendAtm(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Atm == nil {
		t.Atm = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm)
	}

	if _, ok := t.Atm[key]; ok {
		return fmt.Errorf("duplicate key for list Atm %v", key)
	}

	t.Atm[key] = v
	return nil
}

// NewAutoProv creates a new entry in the AutoProv list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewAutoProv(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AutoProv == nil {
		t.AutoProv = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.AutoProv[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list AutoProv", key)
	}

	t.AutoProv[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv{
		Event: Event,
	}

	return t.AutoProv[key], nil
}

// RenameAutoProv renames an entry in the list AutoProv within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameAutoProv(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Event_Union) error {
	if _, ok := t.AutoProv[newK]; ok {
		return fmt.Errorf("key %v already exists in AutoProv", newK)
	}

	e, ok := t.AutoProv[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in AutoProv", oldK)
	}
	e.Event = newK

	t.AutoProv[newK] = e
	delete(t.AutoProv, oldK)
	return nil
}

// GetOrCreateAutoProv retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateAutoProv(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv {

	key := Event

	if v, ok := t.AutoProv[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewAutoProv(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateAutoProv got unexpected error: %v", err))
	}
	return v
}

// GetAutoProv retrieves the value with the specified key from
// the AutoProv map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetAutoProv(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.AutoProv[key]; ok {
		return lm
	}
	return nil
}

// DeleteAutoProv deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteAutoProv(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Event_Union) {
	key := Event

	delete(t.AutoProv, key)
}

// AppendAutoProv appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv struct to the
// list AutoProv of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendAutoProv(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.AutoProv == nil {
		t.AutoProv = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv)
	}

	if _, ok := t.AutoProv[key]; ok {
		return fmt.Errorf("duplicate key for list AutoProv %v", key)
	}

	t.AutoProv[key] = v
	return nil
}

// NewBfd creates a new entry in the Bfd list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewBfd(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bfd == nil {
		t.Bfd = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Bfd[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Bfd", key)
	}

	t.Bfd[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd{
		Event: Event,
	}

	return t.Bfd[key], nil
}

// RenameBfd renames an entry in the list Bfd within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameBfd(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Event_Union) error {
	if _, ok := t.Bfd[newK]; ok {
		return fmt.Errorf("key %v already exists in Bfd", newK)
	}

	e, ok := t.Bfd[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Bfd", oldK)
	}
	e.Event = newK

	t.Bfd[newK] = e
	delete(t.Bfd, oldK)
	return nil
}

// GetOrCreateBfd retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateBfd(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd {

	key := Event

	if v, ok := t.Bfd[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBfd(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBfd got unexpected error: %v", err))
	}
	return v
}

// GetBfd retrieves the value with the specified key from
// the Bfd map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetBfd(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Bfd[key]; ok {
		return lm
	}
	return nil
}

// DeleteBfd deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteBfd(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Event_Union) {
	key := Event

	delete(t.Bfd, key)
}

// AppendBfd appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd struct to the
// list Bfd of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendBfd(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bfd == nil {
		t.Bfd = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd)
	}

	if _, ok := t.Bfd[key]; ok {
		return fmt.Errorf("duplicate key for list Bfd %v", key)
	}

	t.Bfd[key] = v
	return nil
}

// NewBgp creates a new entry in the Bgp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewBgp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bgp == nil {
		t.Bgp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Bgp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Bgp", key)
	}

	t.Bgp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp{
		Event: Event,
	}

	return t.Bgp[key], nil
}

// RenameBgp renames an entry in the list Bgp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameBgp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Event_Union) error {
	if _, ok := t.Bgp[newK]; ok {
		return fmt.Errorf("key %v already exists in Bgp", newK)
	}

	e, ok := t.Bgp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Bgp", oldK)
	}
	e.Event = newK

	t.Bgp[newK] = e
	delete(t.Bgp, oldK)
	return nil
}

// GetOrCreateBgp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateBgp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp {

	key := Event

	if v, ok := t.Bgp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBgp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBgp got unexpected error: %v", err))
	}
	return v
}

// GetBgp retrieves the value with the specified key from
// the Bgp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetBgp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Bgp[key]; ok {
		return lm
	}
	return nil
}

// DeleteBgp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteBgp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Event_Union) {
	key := Event

	delete(t.Bgp, key)
}

// AppendBgp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp struct to the
// list Bgp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendBgp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bgp == nil {
		t.Bgp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp)
	}

	if _, ok := t.Bgp[key]; ok {
		return fmt.Errorf("duplicate key for list Bgp %v", key)
	}

	t.Bgp[key] = v
	return nil
}

// NewBier creates a new entry in the Bier list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewBier(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bier == nil {
		t.Bier = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Bier[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Bier", key)
	}

	t.Bier[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier{
		Event: Event,
	}

	return t.Bier[key], nil
}

// RenameBier renames an entry in the list Bier within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameBier(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Event_Union) error {
	if _, ok := t.Bier[newK]; ok {
		return fmt.Errorf("key %v already exists in Bier", newK)
	}

	e, ok := t.Bier[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Bier", oldK)
	}
	e.Event = newK

	t.Bier[newK] = e
	delete(t.Bier, oldK)
	return nil
}

// GetOrCreateBier retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateBier(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier {

	key := Event

	if v, ok := t.Bier[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewBier(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateBier got unexpected error: %v", err))
	}
	return v
}

// GetBier retrieves the value with the specified key from
// the Bier map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetBier(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Bier[key]; ok {
		return lm
	}
	return nil
}

// DeleteBier deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteBier(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Event_Union) {
	key := Event

	delete(t.Bier, key)
}

// AppendBier appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier struct to the
// list Bier of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendBier(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Bier == nil {
		t.Bier = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier)
	}

	if _, ok := t.Bier[key]; ok {
		return fmt.Errorf("duplicate key for list Bier %v", key)
	}

	t.Bier[key] = v
	return nil
}

// NewCalltrace creates a new entry in the Calltrace list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewCalltrace(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Calltrace == nil {
		t.Calltrace = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Calltrace[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Calltrace", key)
	}

	t.Calltrace[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace{
		Event: Event,
	}

	return t.Calltrace[key], nil
}

// RenameCalltrace renames an entry in the list Calltrace within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameCalltrace(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Event_Union) error {
	if _, ok := t.Calltrace[newK]; ok {
		return fmt.Errorf("key %v already exists in Calltrace", newK)
	}

	e, ok := t.Calltrace[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Calltrace", oldK)
	}
	e.Event = newK

	t.Calltrace[newK] = e
	delete(t.Calltrace, oldK)
	return nil
}

// GetOrCreateCalltrace retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateCalltrace(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace {

	key := Event

	if v, ok := t.Calltrace[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCalltrace(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCalltrace got unexpected error: %v", err))
	}
	return v
}

// GetCalltrace retrieves the value with the specified key from
// the Calltrace map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetCalltrace(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Calltrace[key]; ok {
		return lm
	}
	return nil
}

// DeleteCalltrace deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteCalltrace(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Event_Union) {
	key := Event

	delete(t.Calltrace, key)
}

// AppendCalltrace appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace struct to the
// list Calltrace of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendCalltrace(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Calltrace == nil {
		t.Calltrace = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace)
	}

	if _, ok := t.Calltrace[key]; ok {
		return fmt.Errorf("duplicate key for list Calltrace %v", key)
	}

	t.Calltrace[key] = v
	return nil
}

// NewCflowd creates a new entry in the Cflowd list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewCflowd(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Cflowd == nil {
		t.Cflowd = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Cflowd[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Cflowd", key)
	}

	t.Cflowd[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd{
		Event: Event,
	}

	return t.Cflowd[key], nil
}

// RenameCflowd renames an entry in the list Cflowd within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameCflowd(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Event_Union) error {
	if _, ok := t.Cflowd[newK]; ok {
		return fmt.Errorf("key %v already exists in Cflowd", newK)
	}

	e, ok := t.Cflowd[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Cflowd", oldK)
	}
	e.Event = newK

	t.Cflowd[newK] = e
	delete(t.Cflowd, oldK)
	return nil
}

// GetOrCreateCflowd retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateCflowd(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd {

	key := Event

	if v, ok := t.Cflowd[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewCflowd(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateCflowd got unexpected error: %v", err))
	}
	return v
}

// GetCflowd retrieves the value with the specified key from
// the Cflowd map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetCflowd(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Cflowd[key]; ok {
		return lm
	}
	return nil
}

// DeleteCflowd deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteCflowd(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Event_Union) {
	key := Event

	delete(t.Cflowd, key)
}

// AppendCflowd appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd struct to the
// list Cflowd of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendCflowd(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Cflowd == nil {
		t.Cflowd = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd)
	}

	if _, ok := t.Cflowd[key]; ok {
		return fmt.Errorf("duplicate key for list Cflowd %v", key)
	}

	t.Cflowd[key] = v
	return nil
}

// NewChassis creates a new entry in the Chassis list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewChassis(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Chassis == nil {
		t.Chassis = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Chassis[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Chassis", key)
	}

	t.Chassis[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis{
		Event: Event,
	}

	return t.Chassis[key], nil
}

// RenameChassis renames an entry in the list Chassis within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameChassis(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Event_Union) error {
	if _, ok := t.Chassis[newK]; ok {
		return fmt.Errorf("key %v already exists in Chassis", newK)
	}

	e, ok := t.Chassis[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Chassis", oldK)
	}
	e.Event = newK

	t.Chassis[newK] = e
	delete(t.Chassis, oldK)
	return nil
}

// GetOrCreateChassis retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateChassis(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis {

	key := Event

	if v, ok := t.Chassis[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewChassis(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateChassis got unexpected error: %v", err))
	}
	return v
}

// GetChassis retrieves the value with the specified key from
// the Chassis map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetChassis(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Chassis[key]; ok {
		return lm
	}
	return nil
}

// DeleteChassis deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteChassis(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Event_Union) {
	key := Event

	delete(t.Chassis, key)
}

// AppendChassis appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis struct to the
// list Chassis of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendChassis(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Chassis == nil {
		t.Chassis = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis)
	}

	if _, ok := t.Chassis[key]; ok {
		return fmt.Errorf("duplicate key for list Chassis %v", key)
	}

	t.Chassis[key] = v
	return nil
}

// NewDebug creates a new entry in the Debug list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewDebug(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Debug == nil {
		t.Debug = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Debug[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Debug", key)
	}

	t.Debug[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug{
		Event: Event,
	}

	return t.Debug[key], nil
}

// RenameDebug renames an entry in the list Debug within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameDebug(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Event_Union) error {
	if _, ok := t.Debug[newK]; ok {
		return fmt.Errorf("key %v already exists in Debug", newK)
	}

	e, ok := t.Debug[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Debug", oldK)
	}
	e.Event = newK

	t.Debug[newK] = e
	delete(t.Debug, oldK)
	return nil
}

// GetOrCreateDebug retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateDebug(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug {

	key := Event

	if v, ok := t.Debug[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDebug(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDebug got unexpected error: %v", err))
	}
	return v
}

// GetDebug retrieves the value with the specified key from
// the Debug map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetDebug(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Debug[key]; ok {
		return lm
	}
	return nil
}

// DeleteDebug deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteDebug(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Event_Union) {
	key := Event

	delete(t.Debug, key)
}

// AppendDebug appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug struct to the
// list Debug of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendDebug(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Debug == nil {
		t.Debug = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug)
	}

	if _, ok := t.Debug[key]; ok {
		return fmt.Errorf("duplicate key for list Debug %v", key)
	}

	t.Debug[key] = v
	return nil
}

// NewDhcp creates a new entry in the Dhcp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewDhcp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dhcp == nil {
		t.Dhcp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Dhcp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Dhcp", key)
	}

	t.Dhcp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp{
		Event: Event,
	}

	return t.Dhcp[key], nil
}

// RenameDhcp renames an entry in the list Dhcp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameDhcp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Event_Union) error {
	if _, ok := t.Dhcp[newK]; ok {
		return fmt.Errorf("key %v already exists in Dhcp", newK)
	}

	e, ok := t.Dhcp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Dhcp", oldK)
	}
	e.Event = newK

	t.Dhcp[newK] = e
	delete(t.Dhcp, oldK)
	return nil
}

// GetOrCreateDhcp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateDhcp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp {

	key := Event

	if v, ok := t.Dhcp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDhcp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDhcp got unexpected error: %v", err))
	}
	return v
}

// GetDhcp retrieves the value with the specified key from
// the Dhcp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetDhcp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Dhcp[key]; ok {
		return lm
	}
	return nil
}

// DeleteDhcp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteDhcp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Event_Union) {
	key := Event

	delete(t.Dhcp, key)
}

// AppendDhcp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp struct to the
// list Dhcp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendDhcp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dhcp == nil {
		t.Dhcp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp)
	}

	if _, ok := t.Dhcp[key]; ok {
		return fmt.Errorf("duplicate key for list Dhcp %v", key)
	}

	t.Dhcp[key] = v
	return nil
}

// NewDhcps creates a new entry in the Dhcps list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewDhcps(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dhcps == nil {
		t.Dhcps = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Dhcps[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Dhcps", key)
	}

	t.Dhcps[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps{
		Event: Event,
	}

	return t.Dhcps[key], nil
}

// RenameDhcps renames an entry in the list Dhcps within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameDhcps(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Event_Union) error {
	if _, ok := t.Dhcps[newK]; ok {
		return fmt.Errorf("key %v already exists in Dhcps", newK)
	}

	e, ok := t.Dhcps[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Dhcps", oldK)
	}
	e.Event = newK

	t.Dhcps[newK] = e
	delete(t.Dhcps, oldK)
	return nil
}

// GetOrCreateDhcps retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateDhcps(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps {

	key := Event

	if v, ok := t.Dhcps[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDhcps(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDhcps got unexpected error: %v", err))
	}
	return v
}

// GetDhcps retrieves the value with the specified key from
// the Dhcps map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetDhcps(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Dhcps[key]; ok {
		return lm
	}
	return nil
}

// DeleteDhcps deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteDhcps(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Event_Union) {
	key := Event

	delete(t.Dhcps, key)
}

// AppendDhcps appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps struct to the
// list Dhcps of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendDhcps(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dhcps == nil {
		t.Dhcps = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps)
	}

	if _, ok := t.Dhcps[key]; ok {
		return fmt.Errorf("duplicate key for list Dhcps %v", key)
	}

	t.Dhcps[key] = v
	return nil
}

// NewDiameter creates a new entry in the Diameter list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewDiameter(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Diameter == nil {
		t.Diameter = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Diameter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Diameter", key)
	}

	t.Diameter[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter{
		Event: Event,
	}

	return t.Diameter[key], nil
}

// RenameDiameter renames an entry in the list Diameter within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameDiameter(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Event_Union) error {
	if _, ok := t.Diameter[newK]; ok {
		return fmt.Errorf("key %v already exists in Diameter", newK)
	}

	e, ok := t.Diameter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Diameter", oldK)
	}
	e.Event = newK

	t.Diameter[newK] = e
	delete(t.Diameter, oldK)
	return nil
}

// GetOrCreateDiameter retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateDiameter(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter {

	key := Event

	if v, ok := t.Diameter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDiameter(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDiameter got unexpected error: %v", err))
	}
	return v
}

// GetDiameter retrieves the value with the specified key from
// the Diameter map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetDiameter(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Diameter[key]; ok {
		return lm
	}
	return nil
}

// DeleteDiameter deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteDiameter(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Event_Union) {
	key := Event

	delete(t.Diameter, key)
}

// AppendDiameter appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter struct to the
// list Diameter of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendDiameter(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Diameter == nil {
		t.Diameter = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter)
	}

	if _, ok := t.Diameter[key]; ok {
		return fmt.Errorf("duplicate key for list Diameter %v", key)
	}

	t.Diameter[key] = v
	return nil
}

// NewDynsvc creates a new entry in the Dynsvc list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewDynsvc(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dynsvc == nil {
		t.Dynsvc = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Dynsvc[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Dynsvc", key)
	}

	t.Dynsvc[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc{
		Event: Event,
	}

	return t.Dynsvc[key], nil
}

// RenameDynsvc renames an entry in the list Dynsvc within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameDynsvc(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Event_Union) error {
	if _, ok := t.Dynsvc[newK]; ok {
		return fmt.Errorf("key %v already exists in Dynsvc", newK)
	}

	e, ok := t.Dynsvc[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Dynsvc", oldK)
	}
	e.Event = newK

	t.Dynsvc[newK] = e
	delete(t.Dynsvc, oldK)
	return nil
}

// GetOrCreateDynsvc retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateDynsvc(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc {

	key := Event

	if v, ok := t.Dynsvc[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewDynsvc(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateDynsvc got unexpected error: %v", err))
	}
	return v
}

// GetDynsvc retrieves the value with the specified key from
// the Dynsvc map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetDynsvc(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Dynsvc[key]; ok {
		return lm
	}
	return nil
}

// DeleteDynsvc deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteDynsvc(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Event_Union) {
	key := Event

	delete(t.Dynsvc, key)
}

// AppendDynsvc appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc struct to the
// list Dynsvc of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendDynsvc(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Dynsvc == nil {
		t.Dynsvc = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc)
	}

	if _, ok := t.Dynsvc[key]; ok {
		return fmt.Errorf("duplicate key for list Dynsvc %v", key)
	}

	t.Dynsvc[key] = v
	return nil
}

// NewEfmOam creates a new entry in the EfmOam list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewEfmOam(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EfmOam == nil {
		t.EfmOam = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EfmOam[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EfmOam", key)
	}

	t.EfmOam[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam{
		Event: Event,
	}

	return t.EfmOam[key], nil
}

// RenameEfmOam renames an entry in the list EfmOam within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameEfmOam(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Event_Union) error {
	if _, ok := t.EfmOam[newK]; ok {
		return fmt.Errorf("key %v already exists in EfmOam", newK)
	}

	e, ok := t.EfmOam[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EfmOam", oldK)
	}
	e.Event = newK

	t.EfmOam[newK] = e
	delete(t.EfmOam, oldK)
	return nil
}

// GetOrCreateEfmOam retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateEfmOam(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam {

	key := Event

	if v, ok := t.EfmOam[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEfmOam(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEfmOam got unexpected error: %v", err))
	}
	return v
}

// GetEfmOam retrieves the value with the specified key from
// the EfmOam map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetEfmOam(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.EfmOam[key]; ok {
		return lm
	}
	return nil
}

// DeleteEfmOam deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteEfmOam(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Event_Union) {
	key := Event

	delete(t.EfmOam, key)
}

// AppendEfmOam appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam struct to the
// list EfmOam of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendEfmOam(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EfmOam == nil {
		t.EfmOam = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam)
	}

	if _, ok := t.EfmOam[key]; ok {
		return fmt.Errorf("duplicate key for list EfmOam %v", key)
	}

	t.EfmOam[key] = v
	return nil
}

// NewElmi creates a new entry in the Elmi list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewElmi(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Elmi == nil {
		t.Elmi = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Elmi[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Elmi", key)
	}

	t.Elmi[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi{
		Event: Event,
	}

	return t.Elmi[key], nil
}

// RenameElmi renames an entry in the list Elmi within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameElmi(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Event_Union) error {
	if _, ok := t.Elmi[newK]; ok {
		return fmt.Errorf("key %v already exists in Elmi", newK)
	}

	e, ok := t.Elmi[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Elmi", oldK)
	}
	e.Event = newK

	t.Elmi[newK] = e
	delete(t.Elmi, oldK)
	return nil
}

// GetOrCreateElmi retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateElmi(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi {

	key := Event

	if v, ok := t.Elmi[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewElmi(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateElmi got unexpected error: %v", err))
	}
	return v
}

// GetElmi retrieves the value with the specified key from
// the Elmi map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetElmi(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Elmi[key]; ok {
		return lm
	}
	return nil
}

// DeleteElmi deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteElmi(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Event_Union) {
	key := Event

	delete(t.Elmi, key)
}

// AppendElmi appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi struct to the
// list Elmi of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendElmi(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Elmi == nil {
		t.Elmi = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi)
	}

	if _, ok := t.Elmi[key]; ok {
		return fmt.Errorf("duplicate key for list Elmi %v", key)
	}

	t.Elmi[key] = v
	return nil
}

// NewEring creates a new entry in the Ering list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewEring(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ering == nil {
		t.Ering = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ering[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ering", key)
	}

	t.Ering[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering{
		Event: Event,
	}

	return t.Ering[key], nil
}

// RenameEring renames an entry in the list Ering within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameEring(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Event_Union) error {
	if _, ok := t.Ering[newK]; ok {
		return fmt.Errorf("key %v already exists in Ering", newK)
	}

	e, ok := t.Ering[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ering", oldK)
	}
	e.Event = newK

	t.Ering[newK] = e
	delete(t.Ering, oldK)
	return nil
}

// GetOrCreateEring retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateEring(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering {

	key := Event

	if v, ok := t.Ering[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEring(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEring got unexpected error: %v", err))
	}
	return v
}

// GetEring retrieves the value with the specified key from
// the Ering map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetEring(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Ering[key]; ok {
		return lm
	}
	return nil
}

// DeleteEring deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteEring(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Event_Union) {
	key := Event

	delete(t.Ering, key)
}

// AppendEring appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering struct to the
// list Ering of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendEring(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ering == nil {
		t.Ering = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering)
	}

	if _, ok := t.Ering[key]; ok {
		return fmt.Errorf("duplicate key for list Ering %v", key)
	}

	t.Ering[key] = v
	return nil
}

// NewEthCfm creates a new entry in the EthCfm list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewEthCfm(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EthCfm == nil {
		t.EthCfm = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.EthCfm[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list EthCfm", key)
	}

	t.EthCfm[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm{
		Event: Event,
	}

	return t.EthCfm[key], nil
}

// RenameEthCfm renames an entry in the list EthCfm within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameEthCfm(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Event_Union) error {
	if _, ok := t.EthCfm[newK]; ok {
		return fmt.Errorf("key %v already exists in EthCfm", newK)
	}

	e, ok := t.EthCfm[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in EthCfm", oldK)
	}
	e.Event = newK

	t.EthCfm[newK] = e
	delete(t.EthCfm, oldK)
	return nil
}

// GetOrCreateEthCfm retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateEthCfm(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm {

	key := Event

	if v, ok := t.EthCfm[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEthCfm(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEthCfm got unexpected error: %v", err))
	}
	return v
}

// GetEthCfm retrieves the value with the specified key from
// the EthCfm map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetEthCfm(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.EthCfm[key]; ok {
		return lm
	}
	return nil
}

// DeleteEthCfm deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteEthCfm(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Event_Union) {
	key := Event

	delete(t.EthCfm, key)
}

// AppendEthCfm appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm struct to the
// list EthCfm of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendEthCfm(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.EthCfm == nil {
		t.EthCfm = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm)
	}

	if _, ok := t.EthCfm[key]; ok {
		return fmt.Errorf("duplicate key for list EthCfm %v", key)
	}

	t.EthCfm[key] = v
	return nil
}

// NewEtun creates a new entry in the Etun list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewEtun(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Etun == nil {
		t.Etun = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Etun[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Etun", key)
	}

	t.Etun[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun{
		Event: Event,
	}

	return t.Etun[key], nil
}

// RenameEtun renames an entry in the list Etun within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameEtun(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Event_Union) error {
	if _, ok := t.Etun[newK]; ok {
		return fmt.Errorf("key %v already exists in Etun", newK)
	}

	e, ok := t.Etun[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Etun", oldK)
	}
	e.Event = newK

	t.Etun[newK] = e
	delete(t.Etun, oldK)
	return nil
}

// GetOrCreateEtun retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateEtun(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun {

	key := Event

	if v, ok := t.Etun[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEtun(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEtun got unexpected error: %v", err))
	}
	return v
}

// GetEtun retrieves the value with the specified key from
// the Etun map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetEtun(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Etun[key]; ok {
		return lm
	}
	return nil
}

// DeleteEtun deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteEtun(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Event_Union) {
	key := Event

	delete(t.Etun, key)
}

// AppendEtun appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun struct to the
// list Etun of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendEtun(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Etun == nil {
		t.Etun = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun)
	}

	if _, ok := t.Etun[key]; ok {
		return fmt.Errorf("duplicate key for list Etun %v", key)
	}

	t.Etun[key] = v
	return nil
}

// NewFilter creates a new entry in the Filter list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewFilter(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Filter == nil {
		t.Filter = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Filter[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Filter", key)
	}

	t.Filter[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter{
		Event: Event,
	}

	return t.Filter[key], nil
}

// RenameFilter renames an entry in the list Filter within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameFilter(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Event_Union) error {
	if _, ok := t.Filter[newK]; ok {
		return fmt.Errorf("key %v already exists in Filter", newK)
	}

	e, ok := t.Filter[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Filter", oldK)
	}
	e.Event = newK

	t.Filter[newK] = e
	delete(t.Filter, oldK)
	return nil
}

// GetOrCreateFilter retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateFilter(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter {

	key := Event

	if v, ok := t.Filter[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewFilter(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateFilter got unexpected error: %v", err))
	}
	return v
}

// GetFilter retrieves the value with the specified key from
// the Filter map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetFilter(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Filter[key]; ok {
		return lm
	}
	return nil
}

// DeleteFilter deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteFilter(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Event_Union) {
	key := Event

	delete(t.Filter, key)
}

// AppendFilter appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter struct to the
// list Filter of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendFilter(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Filter == nil {
		t.Filter = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter)
	}

	if _, ok := t.Filter[key]; ok {
		return fmt.Errorf("duplicate key for list Filter %v", key)
	}

	t.Filter[key] = v
	return nil
}

// NewGmpls creates a new entry in the Gmpls list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewGmpls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Gmpls == nil {
		t.Gmpls = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Gmpls[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Gmpls", key)
	}

	t.Gmpls[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls{
		Event: Event,
	}

	return t.Gmpls[key], nil
}

// RenameGmpls renames an entry in the list Gmpls within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameGmpls(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Event_Union) error {
	if _, ok := t.Gmpls[newK]; ok {
		return fmt.Errorf("key %v already exists in Gmpls", newK)
	}

	e, ok := t.Gmpls[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Gmpls", oldK)
	}
	e.Event = newK

	t.Gmpls[newK] = e
	delete(t.Gmpls, oldK)
	return nil
}

// GetOrCreateGmpls retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateGmpls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls {

	key := Event

	if v, ok := t.Gmpls[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewGmpls(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateGmpls got unexpected error: %v", err))
	}
	return v
}

// GetGmpls retrieves the value with the specified key from
// the Gmpls map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetGmpls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Gmpls[key]; ok {
		return lm
	}
	return nil
}

// DeleteGmpls deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteGmpls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Event_Union) {
	key := Event

	delete(t.Gmpls, key)
}

// AppendGmpls appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls struct to the
// list Gmpls of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendGmpls(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Gmpls == nil {
		t.Gmpls = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls)
	}

	if _, ok := t.Gmpls[key]; ok {
		return fmt.Errorf("duplicate key for list Gmpls %v", key)
	}

	t.Gmpls[key] = v
	return nil
}

// NewGsmp creates a new entry in the Gsmp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewGsmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Gsmp == nil {
		t.Gsmp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Gsmp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Gsmp", key)
	}

	t.Gsmp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp{
		Event: Event,
	}

	return t.Gsmp[key], nil
}

// RenameGsmp renames an entry in the list Gsmp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameGsmp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Event_Union) error {
	if _, ok := t.Gsmp[newK]; ok {
		return fmt.Errorf("key %v already exists in Gsmp", newK)
	}

	e, ok := t.Gsmp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Gsmp", oldK)
	}
	e.Event = newK

	t.Gsmp[newK] = e
	delete(t.Gsmp, oldK)
	return nil
}

// GetOrCreateGsmp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateGsmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp {

	key := Event

	if v, ok := t.Gsmp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewGsmp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateGsmp got unexpected error: %v", err))
	}
	return v
}

// GetGsmp retrieves the value with the specified key from
// the Gsmp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetGsmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Gsmp[key]; ok {
		return lm
	}
	return nil
}

// DeleteGsmp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteGsmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Event_Union) {
	key := Event

	delete(t.Gsmp, key)
}

// AppendGsmp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp struct to the
// list Gsmp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendGsmp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Gsmp == nil {
		t.Gsmp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp)
	}

	if _, ok := t.Gsmp[key]; ok {
		return fmt.Errorf("duplicate key for list Gsmp %v", key)
	}

	t.Gsmp[key] = v
	return nil
}

// NewIgh creates a new entry in the Igh list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewIgh(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Igh == nil {
		t.Igh = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Igh[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Igh", key)
	}

	t.Igh[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh{
		Event: Event,
	}

	return t.Igh[key], nil
}

// RenameIgh renames an entry in the list Igh within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameIgh(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Event_Union) error {
	if _, ok := t.Igh[newK]; ok {
		return fmt.Errorf("key %v already exists in Igh", newK)
	}

	e, ok := t.Igh[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Igh", oldK)
	}
	e.Event = newK

	t.Igh[newK] = e
	delete(t.Igh, oldK)
	return nil
}

// GetOrCreateIgh retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateIgh(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh {

	key := Event

	if v, ok := t.Igh[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIgh(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIgh got unexpected error: %v", err))
	}
	return v
}

// GetIgh retrieves the value with the specified key from
// the Igh map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetIgh(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Igh[key]; ok {
		return lm
	}
	return nil
}

// DeleteIgh deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteIgh(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Event_Union) {
	key := Event

	delete(t.Igh, key)
}

// AppendIgh appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh struct to the
// list Igh of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendIgh(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Igh == nil {
		t.Igh = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh)
	}

	if _, ok := t.Igh[key]; ok {
		return fmt.Errorf("duplicate key for list Igh %v", key)
	}

	t.Igh[key] = v
	return nil
}

// NewIgmp creates a new entry in the Igmp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewIgmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Igmp == nil {
		t.Igmp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Igmp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Igmp", key)
	}

	t.Igmp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp{
		Event: Event,
	}

	return t.Igmp[key], nil
}

// RenameIgmp renames an entry in the list Igmp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameIgmp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Event_Union) error {
	if _, ok := t.Igmp[newK]; ok {
		return fmt.Errorf("key %v already exists in Igmp", newK)
	}

	e, ok := t.Igmp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Igmp", oldK)
	}
	e.Event = newK

	t.Igmp[newK] = e
	delete(t.Igmp, oldK)
	return nil
}

// GetOrCreateIgmp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateIgmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp {

	key := Event

	if v, ok := t.Igmp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIgmp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIgmp got unexpected error: %v", err))
	}
	return v
}

// GetIgmp retrieves the value with the specified key from
// the Igmp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetIgmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Igmp[key]; ok {
		return lm
	}
	return nil
}

// DeleteIgmp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteIgmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Event_Union) {
	key := Event

	delete(t.Igmp, key)
}

// AppendIgmp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp struct to the
// list Igmp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendIgmp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Igmp == nil {
		t.Igmp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp)
	}

	if _, ok := t.Igmp[key]; ok {
		return fmt.Errorf("duplicate key for list Igmp %v", key)
	}

	t.Igmp[key] = v
	return nil
}

// NewIgmpSnooping creates a new entry in the IgmpSnooping list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewIgmpSnooping(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IgmpSnooping == nil {
		t.IgmpSnooping = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.IgmpSnooping[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list IgmpSnooping", key)
	}

	t.IgmpSnooping[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping{
		Event: Event,
	}

	return t.IgmpSnooping[key], nil
}

// RenameIgmpSnooping renames an entry in the list IgmpSnooping within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameIgmpSnooping(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Event_Union) error {
	if _, ok := t.IgmpSnooping[newK]; ok {
		return fmt.Errorf("key %v already exists in IgmpSnooping", newK)
	}

	e, ok := t.IgmpSnooping[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in IgmpSnooping", oldK)
	}
	e.Event = newK

	t.IgmpSnooping[newK] = e
	delete(t.IgmpSnooping, oldK)
	return nil
}

// GetOrCreateIgmpSnooping retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateIgmpSnooping(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping {

	key := Event

	if v, ok := t.IgmpSnooping[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIgmpSnooping(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIgmpSnooping got unexpected error: %v", err))
	}
	return v
}

// GetIgmpSnooping retrieves the value with the specified key from
// the IgmpSnooping map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetIgmpSnooping(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.IgmpSnooping[key]; ok {
		return lm
	}
	return nil
}

// DeleteIgmpSnooping deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteIgmpSnooping(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Event_Union) {
	key := Event

	delete(t.IgmpSnooping, key)
}

// AppendIgmpSnooping appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping struct to the
// list IgmpSnooping of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendIgmpSnooping(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.IgmpSnooping == nil {
		t.IgmpSnooping = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping)
	}

	if _, ok := t.IgmpSnooping[key]; ok {
		return fmt.Errorf("duplicate key for list IgmpSnooping %v", key)
	}

	t.IgmpSnooping[key] = v
	return nil
}

// NewIp creates a new entry in the Ip list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewIp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ip == nil {
		t.Ip = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ip[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ip", key)
	}

	t.Ip[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip{
		Event: Event,
	}

	return t.Ip[key], nil
}

// RenameIp renames an entry in the list Ip within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameIp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Event_Union) error {
	if _, ok := t.Ip[newK]; ok {
		return fmt.Errorf("key %v already exists in Ip", newK)
	}

	e, ok := t.Ip[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ip", oldK)
	}
	e.Event = newK

	t.Ip[newK] = e
	delete(t.Ip, oldK)
	return nil
}

// GetOrCreateIp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateIp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip {

	key := Event

	if v, ok := t.Ip[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIp got unexpected error: %v", err))
	}
	return v
}

// GetIp retrieves the value with the specified key from
// the Ip map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetIp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Ip[key]; ok {
		return lm
	}
	return nil
}

// DeleteIp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteIp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Event_Union) {
	key := Event

	delete(t.Ip, key)
}

// AppendIp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip struct to the
// list Ip of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendIp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ip == nil {
		t.Ip = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip)
	}

	if _, ok := t.Ip[key]; ok {
		return fmt.Errorf("duplicate key for list Ip %v", key)
	}

	t.Ip[key] = v
	return nil
}

// NewIpsec creates a new entry in the Ipsec list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewIpsec(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipsec == nil {
		t.Ipsec = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ipsec[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ipsec", key)
	}

	t.Ipsec[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec{
		Event: Event,
	}

	return t.Ipsec[key], nil
}

// RenameIpsec renames an entry in the list Ipsec within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameIpsec(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Event_Union) error {
	if _, ok := t.Ipsec[newK]; ok {
		return fmt.Errorf("key %v already exists in Ipsec", newK)
	}

	e, ok := t.Ipsec[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ipsec", oldK)
	}
	e.Event = newK

	t.Ipsec[newK] = e
	delete(t.Ipsec, oldK)
	return nil
}

// GetOrCreateIpsec retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateIpsec(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec {

	key := Event

	if v, ok := t.Ipsec[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIpsec(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIpsec got unexpected error: %v", err))
	}
	return v
}

// GetIpsec retrieves the value with the specified key from
// the Ipsec map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetIpsec(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Ipsec[key]; ok {
		return lm
	}
	return nil
}

// DeleteIpsec deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteIpsec(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Event_Union) {
	key := Event

	delete(t.Ipsec, key)
}

// AppendIpsec appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec struct to the
// list Ipsec of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendIpsec(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ipsec == nil {
		t.Ipsec = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec)
	}

	if _, ok := t.Ipsec[key]; ok {
		return fmt.Errorf("duplicate key for list Ipsec %v", key)
	}

	t.Ipsec[key] = v
	return nil
}

// NewIsis creates a new entry in the Isis list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewIsis(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Isis == nil {
		t.Isis = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Isis[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Isis", key)
	}

	t.Isis[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis{
		Event: Event,
	}

	return t.Isis[key], nil
}

// RenameIsis renames an entry in the list Isis within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameIsis(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Event_Union) error {
	if _, ok := t.Isis[newK]; ok {
		return fmt.Errorf("key %v already exists in Isis", newK)
	}

	e, ok := t.Isis[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Isis", oldK)
	}
	e.Event = newK

	t.Isis[newK] = e
	delete(t.Isis, oldK)
	return nil
}

// GetOrCreateIsis retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateIsis(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis {

	key := Event

	if v, ok := t.Isis[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewIsis(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateIsis got unexpected error: %v", err))
	}
	return v
}

// GetIsis retrieves the value with the specified key from
// the Isis map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetIsis(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Isis[key]; ok {
		return lm
	}
	return nil
}

// DeleteIsis deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteIsis(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Event_Union) {
	key := Event

	delete(t.Isis, key)
}

// AppendIsis appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis struct to the
// list Isis of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendIsis(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Isis == nil {
		t.Isis = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis)
	}

	if _, ok := t.Isis[key]; ok {
		return fmt.Errorf("duplicate key for list Isis %v", key)
	}

	t.Isis[key] = v
	return nil
}

// NewL2Tp creates a new entry in the L2Tp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewL2Tp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.L2Tp == nil {
		t.L2Tp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.L2Tp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list L2Tp", key)
	}

	t.L2Tp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp{
		Event: Event,
	}

	return t.L2Tp[key], nil
}

// RenameL2Tp renames an entry in the list L2Tp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameL2Tp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Event_Union) error {
	if _, ok := t.L2Tp[newK]; ok {
		return fmt.Errorf("key %v already exists in L2Tp", newK)
	}

	e, ok := t.L2Tp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in L2Tp", oldK)
	}
	e.Event = newK

	t.L2Tp[newK] = e
	delete(t.L2Tp, oldK)
	return nil
}

// GetOrCreateL2Tp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateL2Tp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp {

	key := Event

	if v, ok := t.L2Tp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewL2Tp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateL2Tp got unexpected error: %v", err))
	}
	return v
}

// GetL2Tp retrieves the value with the specified key from
// the L2Tp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetL2Tp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.L2Tp[key]; ok {
		return lm
	}
	return nil
}

// DeleteL2Tp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteL2Tp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Event_Union) {
	key := Event

	delete(t.L2Tp, key)
}

// AppendL2Tp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp struct to the
// list L2Tp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendL2Tp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.L2Tp == nil {
		t.L2Tp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp)
	}

	if _, ok := t.L2Tp[key]; ok {
		return fmt.Errorf("duplicate key for list L2Tp %v", key)
	}

	t.L2Tp[key] = v
	return nil
}

// NewLag creates a new entry in the Lag list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewLag(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lag == nil {
		t.Lag = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Lag[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Lag", key)
	}

	t.Lag[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag{
		Event: Event,
	}

	return t.Lag[key], nil
}

// RenameLag renames an entry in the list Lag within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameLag(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Event_Union) error {
	if _, ok := t.Lag[newK]; ok {
		return fmt.Errorf("key %v already exists in Lag", newK)
	}

	e, ok := t.Lag[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Lag", oldK)
	}
	e.Event = newK

	t.Lag[newK] = e
	delete(t.Lag, oldK)
	return nil
}

// GetOrCreateLag retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateLag(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag {

	key := Event

	if v, ok := t.Lag[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLag(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLag got unexpected error: %v", err))
	}
	return v
}

// GetLag retrieves the value with the specified key from
// the Lag map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetLag(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Lag[key]; ok {
		return lm
	}
	return nil
}

// DeleteLag deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteLag(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Event_Union) {
	key := Event

	delete(t.Lag, key)
}

// AppendLag appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag struct to the
// list Lag of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendLag(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lag == nil {
		t.Lag = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag)
	}

	if _, ok := t.Lag[key]; ok {
		return fmt.Errorf("duplicate key for list Lag %v", key)
	}

	t.Lag[key] = v
	return nil
}

// NewLdap creates a new entry in the Ldap list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewLdap(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ldap == nil {
		t.Ldap = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ldap[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ldap", key)
	}

	t.Ldap[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap{
		Event: Event,
	}

	return t.Ldap[key], nil
}

// RenameLdap renames an entry in the list Ldap within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameLdap(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap_Event_Union) error {
	if _, ok := t.Ldap[newK]; ok {
		return fmt.Errorf("key %v already exists in Ldap", newK)
	}

	e, ok := t.Ldap[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ldap", oldK)
	}
	e.Event = newK

	t.Ldap[newK] = e
	delete(t.Ldap, oldK)
	return nil
}

// GetOrCreateLdap retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateLdap(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap {

	key := Event

	if v, ok := t.Ldap[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLdap(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLdap got unexpected error: %v", err))
	}
	return v
}

// GetLdap retrieves the value with the specified key from
// the Ldap map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetLdap(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Ldap[key]; ok {
		return lm
	}
	return nil
}

// DeleteLdap deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteLdap(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap_Event_Union) {
	key := Event

	delete(t.Ldap, key)
}

// AppendLdap appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap struct to the
// list Ldap of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendLdap(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ldap == nil {
		t.Ldap = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldap)
	}

	if _, ok := t.Ldap[key]; ok {
		return fmt.Errorf("duplicate key for list Ldap %v", key)
	}

	t.Ldap[key] = v
	return nil
}

// NewLdp creates a new entry in the Ldp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewLdp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ldp == nil {
		t.Ldp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ldp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ldp", key)
	}

	t.Ldp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp{
		Event: Event,
	}

	return t.Ldp[key], nil
}

// RenameLdp renames an entry in the list Ldp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameLdp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp_Event_Union) error {
	if _, ok := t.Ldp[newK]; ok {
		return fmt.Errorf("key %v already exists in Ldp", newK)
	}

	e, ok := t.Ldp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ldp", oldK)
	}
	e.Event = newK

	t.Ldp[newK] = e
	delete(t.Ldp, oldK)
	return nil
}

// GetOrCreateLdp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateLdp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp {

	key := Event

	if v, ok := t.Ldp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLdp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLdp got unexpected error: %v", err))
	}
	return v
}

// GetLdp retrieves the value with the specified key from
// the Ldp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetLdp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Ldp[key]; ok {
		return lm
	}
	return nil
}

// DeleteLdp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteLdp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp_Event_Union) {
	key := Event

	delete(t.Ldp, key)
}

// AppendLdp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp struct to the
// list Ldp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendLdp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ldp == nil {
		t.Ldp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ldp)
	}

	if _, ok := t.Ldp[key]; ok {
		return fmt.Errorf("duplicate key for list Ldp %v", key)
	}

	t.Ldp[key] = v
	return nil
}

// NewLi creates a new entry in the Li list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewLi(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Li == nil {
		t.Li = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Li[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Li", key)
	}

	t.Li[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li{
		Event: Event,
	}

	return t.Li[key], nil
}

// RenameLi renames an entry in the list Li within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameLi(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li_Event_Union) error {
	if _, ok := t.Li[newK]; ok {
		return fmt.Errorf("key %v already exists in Li", newK)
	}

	e, ok := t.Li[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Li", oldK)
	}
	e.Event = newK

	t.Li[newK] = e
	delete(t.Li, oldK)
	return nil
}

// GetOrCreateLi retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateLi(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li {

	key := Event

	if v, ok := t.Li[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLi(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLi got unexpected error: %v", err))
	}
	return v
}

// GetLi retrieves the value with the specified key from
// the Li map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetLi(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Li[key]; ok {
		return lm
	}
	return nil
}

// DeleteLi deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteLi(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li_Event_Union) {
	key := Event

	delete(t.Li, key)
}

// AppendLi appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li struct to the
// list Li of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendLi(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Li == nil {
		t.Li = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Li)
	}

	if _, ok := t.Li[key]; ok {
		return fmt.Errorf("duplicate key for list Li %v", key)
	}

	t.Li[key] = v
	return nil
}

// NewLldp creates a new entry in the Lldp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewLldp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lldp == nil {
		t.Lldp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Lldp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Lldp", key)
	}

	t.Lldp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp{
		Event: Event,
	}

	return t.Lldp[key], nil
}

// RenameLldp renames an entry in the list Lldp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameLldp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp_Event_Union) error {
	if _, ok := t.Lldp[newK]; ok {
		return fmt.Errorf("key %v already exists in Lldp", newK)
	}

	e, ok := t.Lldp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Lldp", oldK)
	}
	e.Event = newK

	t.Lldp[newK] = e
	delete(t.Lldp, oldK)
	return nil
}

// GetOrCreateLldp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateLldp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp {

	key := Event

	if v, ok := t.Lldp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLldp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLldp got unexpected error: %v", err))
	}
	return v
}

// GetLldp retrieves the value with the specified key from
// the Lldp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetLldp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Lldp[key]; ok {
		return lm
	}
	return nil
}

// DeleteLldp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteLldp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp_Event_Union) {
	key := Event

	delete(t.Lldp, key)
}

// AppendLldp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp struct to the
// list Lldp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendLldp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lldp == nil {
		t.Lldp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lldp)
	}

	if _, ok := t.Lldp[key]; ok {
		return fmt.Errorf("duplicate key for list Lldp %v", key)
	}

	t.Lldp[key] = v
	return nil
}

// NewLmp creates a new entry in the Lmp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewLmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lmp == nil {
		t.Lmp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Lmp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Lmp", key)
	}

	t.Lmp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp{
		Event: Event,
	}

	return t.Lmp[key], nil
}

// RenameLmp renames an entry in the list Lmp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameLmp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp_Event_Union) error {
	if _, ok := t.Lmp[newK]; ok {
		return fmt.Errorf("key %v already exists in Lmp", newK)
	}

	e, ok := t.Lmp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Lmp", oldK)
	}
	e.Event = newK

	t.Lmp[newK] = e
	delete(t.Lmp, oldK)
	return nil
}

// GetOrCreateLmp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateLmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp {

	key := Event

	if v, ok := t.Lmp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLmp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLmp got unexpected error: %v", err))
	}
	return v
}

// GetLmp retrieves the value with the specified key from
// the Lmp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetLmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Lmp[key]; ok {
		return lm
	}
	return nil
}

// DeleteLmp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteLmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp_Event_Union) {
	key := Event

	delete(t.Lmp, key)
}

// AppendLmp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp struct to the
// list Lmp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendLmp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Lmp == nil {
		t.Lmp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lmp)
	}

	if _, ok := t.Lmp[key]; ok {
		return fmt.Errorf("duplicate key for list Lmp %v", key)
	}

	t.Lmp[key] = v
	return nil
}

// NewLogger creates a new entry in the Logger list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewLogger(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Logger == nil {
		t.Logger = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Logger[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Logger", key)
	}

	t.Logger[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger{
		Event: Event,
	}

	return t.Logger[key], nil
}

// RenameLogger renames an entry in the list Logger within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameLogger(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger_Event_Union) error {
	if _, ok := t.Logger[newK]; ok {
		return fmt.Errorf("key %v already exists in Logger", newK)
	}

	e, ok := t.Logger[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Logger", oldK)
	}
	e.Event = newK

	t.Logger[newK] = e
	delete(t.Logger, oldK)
	return nil
}

// GetOrCreateLogger retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateLogger(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger {

	key := Event

	if v, ok := t.Logger[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewLogger(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateLogger got unexpected error: %v", err))
	}
	return v
}

// GetLogger retrieves the value with the specified key from
// the Logger map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetLogger(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Logger[key]; ok {
		return lm
	}
	return nil
}

// DeleteLogger deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteLogger(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger_Event_Union) {
	key := Event

	delete(t.Logger, key)
}

// AppendLogger appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger struct to the
// list Logger of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendLogger(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Logger == nil {
		t.Logger = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Logger)
	}

	if _, ok := t.Logger[key]; ok {
		return fmt.Errorf("duplicate key for list Logger %v", key)
	}

	t.Logger[key] = v
	return nil
}

// NewMacsec creates a new entry in the Macsec list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewMacsec(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Macsec == nil {
		t.Macsec = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Macsec[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Macsec", key)
	}

	t.Macsec[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec{
		Event: Event,
	}

	return t.Macsec[key], nil
}

// RenameMacsec renames an entry in the list Macsec within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameMacsec(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec_Event_Union) error {
	if _, ok := t.Macsec[newK]; ok {
		return fmt.Errorf("key %v already exists in Macsec", newK)
	}

	e, ok := t.Macsec[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Macsec", oldK)
	}
	e.Event = newK

	t.Macsec[newK] = e
	delete(t.Macsec, oldK)
	return nil
}

// GetOrCreateMacsec retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateMacsec(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec {

	key := Event

	if v, ok := t.Macsec[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMacsec(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMacsec got unexpected error: %v", err))
	}
	return v
}

// GetMacsec retrieves the value with the specified key from
// the Macsec map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetMacsec(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Macsec[key]; ok {
		return lm
	}
	return nil
}

// DeleteMacsec deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteMacsec(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec_Event_Union) {
	key := Event

	delete(t.Macsec, key)
}

// AppendMacsec appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec struct to the
// list Macsec of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendMacsec(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Macsec == nil {
		t.Macsec = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Macsec)
	}

	if _, ok := t.Macsec[key]; ok {
		return fmt.Errorf("duplicate key for list Macsec %v", key)
	}

	t.Macsec[key] = v
	return nil
}

// NewMcRedundancy creates a new entry in the McRedundancy list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewMcRedundancy(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.McRedundancy == nil {
		t.McRedundancy = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.McRedundancy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list McRedundancy", key)
	}

	t.McRedundancy[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy{
		Event: Event,
	}

	return t.McRedundancy[key], nil
}

// RenameMcRedundancy renames an entry in the list McRedundancy within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameMcRedundancy(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy_Event_Union) error {
	if _, ok := t.McRedundancy[newK]; ok {
		return fmt.Errorf("key %v already exists in McRedundancy", newK)
	}

	e, ok := t.McRedundancy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in McRedundancy", oldK)
	}
	e.Event = newK

	t.McRedundancy[newK] = e
	delete(t.McRedundancy, oldK)
	return nil
}

// GetOrCreateMcRedundancy retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateMcRedundancy(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy {

	key := Event

	if v, ok := t.McRedundancy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMcRedundancy(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMcRedundancy got unexpected error: %v", err))
	}
	return v
}

// GetMcRedundancy retrieves the value with the specified key from
// the McRedundancy map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetMcRedundancy(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.McRedundancy[key]; ok {
		return lm
	}
	return nil
}

// DeleteMcRedundancy deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteMcRedundancy(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy_Event_Union) {
	key := Event

	delete(t.McRedundancy, key)
}

// AppendMcRedundancy appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy struct to the
// list McRedundancy of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendMcRedundancy(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.McRedundancy == nil {
		t.McRedundancy = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_McRedundancy)
	}

	if _, ok := t.McRedundancy[key]; ok {
		return fmt.Errorf("duplicate key for list McRedundancy %v", key)
	}

	t.McRedundancy[key] = v
	return nil
}

// NewMcpath creates a new entry in the Mcpath list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewMcpath(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mcpath == nil {
		t.Mcpath = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mcpath[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mcpath", key)
	}

	t.Mcpath[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath{
		Event: Event,
	}

	return t.Mcpath[key], nil
}

// RenameMcpath renames an entry in the list Mcpath within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameMcpath(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath_Event_Union) error {
	if _, ok := t.Mcpath[newK]; ok {
		return fmt.Errorf("key %v already exists in Mcpath", newK)
	}

	e, ok := t.Mcpath[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mcpath", oldK)
	}
	e.Event = newK

	t.Mcpath[newK] = e
	delete(t.Mcpath, oldK)
	return nil
}

// GetOrCreateMcpath retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateMcpath(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath {

	key := Event

	if v, ok := t.Mcpath[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMcpath(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMcpath got unexpected error: %v", err))
	}
	return v
}

// GetMcpath retrieves the value with the specified key from
// the Mcpath map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetMcpath(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Mcpath[key]; ok {
		return lm
	}
	return nil
}

// DeleteMcpath deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteMcpath(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath_Event_Union) {
	key := Event

	delete(t.Mcpath, key)
}

// AppendMcpath appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath struct to the
// list Mcpath of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendMcpath(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mcpath == nil {
		t.Mcpath = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mcpath)
	}

	if _, ok := t.Mcpath[key]; ok {
		return fmt.Errorf("duplicate key for list Mcpath %v", key)
	}

	t.Mcpath[key] = v
	return nil
}

// NewMgmtCore creates a new entry in the MgmtCore list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewMgmtCore(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MgmtCore == nil {
		t.MgmtCore = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MgmtCore[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MgmtCore", key)
	}

	t.MgmtCore[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore{
		Event: Event,
	}

	return t.MgmtCore[key], nil
}

// RenameMgmtCore renames an entry in the list MgmtCore within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameMgmtCore(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore_Event_Union) error {
	if _, ok := t.MgmtCore[newK]; ok {
		return fmt.Errorf("key %v already exists in MgmtCore", newK)
	}

	e, ok := t.MgmtCore[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MgmtCore", oldK)
	}
	e.Event = newK

	t.MgmtCore[newK] = e
	delete(t.MgmtCore, oldK)
	return nil
}

// GetOrCreateMgmtCore retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateMgmtCore(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore {

	key := Event

	if v, ok := t.MgmtCore[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMgmtCore(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMgmtCore got unexpected error: %v", err))
	}
	return v
}

// GetMgmtCore retrieves the value with the specified key from
// the MgmtCore map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetMgmtCore(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.MgmtCore[key]; ok {
		return lm
	}
	return nil
}

// DeleteMgmtCore deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteMgmtCore(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore_Event_Union) {
	key := Event

	delete(t.MgmtCore, key)
}

// AppendMgmtCore appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore struct to the
// list MgmtCore of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendMgmtCore(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MgmtCore == nil {
		t.MgmtCore = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_MgmtCore)
	}

	if _, ok := t.MgmtCore[key]; ok {
		return fmt.Errorf("duplicate key for list MgmtCore %v", key)
	}

	t.MgmtCore[key] = v
	return nil
}

// NewMirror creates a new entry in the Mirror list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewMirror(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mirror == nil {
		t.Mirror = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mirror[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mirror", key)
	}

	t.Mirror[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror{
		Event: Event,
	}

	return t.Mirror[key], nil
}

// RenameMirror renames an entry in the list Mirror within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameMirror(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror_Event_Union) error {
	if _, ok := t.Mirror[newK]; ok {
		return fmt.Errorf("key %v already exists in Mirror", newK)
	}

	e, ok := t.Mirror[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mirror", oldK)
	}
	e.Event = newK

	t.Mirror[newK] = e
	delete(t.Mirror, oldK)
	return nil
}

// GetOrCreateMirror retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateMirror(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror {

	key := Event

	if v, ok := t.Mirror[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMirror(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMirror got unexpected error: %v", err))
	}
	return v
}

// GetMirror retrieves the value with the specified key from
// the Mirror map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetMirror(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Mirror[key]; ok {
		return lm
	}
	return nil
}

// DeleteMirror deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteMirror(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror_Event_Union) {
	key := Event

	delete(t.Mirror, key)
}

// AppendMirror appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror struct to the
// list Mirror of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendMirror(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mirror == nil {
		t.Mirror = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mirror)
	}

	if _, ok := t.Mirror[key]; ok {
		return fmt.Errorf("duplicate key for list Mirror %v", key)
	}

	t.Mirror[key] = v
	return nil
}

// NewMld creates a new entry in the Mld list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewMld(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mld == nil {
		t.Mld = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mld[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mld", key)
	}

	t.Mld[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld{
		Event: Event,
	}

	return t.Mld[key], nil
}

// RenameMld renames an entry in the list Mld within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameMld(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld_Event_Union) error {
	if _, ok := t.Mld[newK]; ok {
		return fmt.Errorf("key %v already exists in Mld", newK)
	}

	e, ok := t.Mld[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mld", oldK)
	}
	e.Event = newK

	t.Mld[newK] = e
	delete(t.Mld, oldK)
	return nil
}

// GetOrCreateMld retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateMld(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld {

	key := Event

	if v, ok := t.Mld[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMld(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMld got unexpected error: %v", err))
	}
	return v
}

// GetMld retrieves the value with the specified key from
// the Mld map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetMld(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Mld[key]; ok {
		return lm
	}
	return nil
}

// DeleteMld deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteMld(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld_Event_Union) {
	key := Event

	delete(t.Mld, key)
}

// AppendMld appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld struct to the
// list Mld of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendMld(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mld == nil {
		t.Mld = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mld)
	}

	if _, ok := t.Mld[key]; ok {
		return fmt.Errorf("duplicate key for list Mld %v", key)
	}

	t.Mld[key] = v
	return nil
}

// NewMldSnooping creates a new entry in the MldSnooping list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewMldSnooping(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MldSnooping == nil {
		t.MldSnooping = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MldSnooping[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MldSnooping", key)
	}

	t.MldSnooping[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping{
		Event: Event,
	}

	return t.MldSnooping[key], nil
}

// RenameMldSnooping renames an entry in the list MldSnooping within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameMldSnooping(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping_Event_Union) error {
	if _, ok := t.MldSnooping[newK]; ok {
		return fmt.Errorf("key %v already exists in MldSnooping", newK)
	}

	e, ok := t.MldSnooping[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MldSnooping", oldK)
	}
	e.Event = newK

	t.MldSnooping[newK] = e
	delete(t.MldSnooping, oldK)
	return nil
}

// GetOrCreateMldSnooping retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateMldSnooping(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping {

	key := Event

	if v, ok := t.MldSnooping[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMldSnooping(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMldSnooping got unexpected error: %v", err))
	}
	return v
}

// GetMldSnooping retrieves the value with the specified key from
// the MldSnooping map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetMldSnooping(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.MldSnooping[key]; ok {
		return lm
	}
	return nil
}

// DeleteMldSnooping deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteMldSnooping(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping_Event_Union) {
	key := Event

	delete(t.MldSnooping, key)
}

// AppendMldSnooping appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping struct to the
// list MldSnooping of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendMldSnooping(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MldSnooping == nil {
		t.MldSnooping = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_MldSnooping)
	}

	if _, ok := t.MldSnooping[key]; ok {
		return fmt.Errorf("duplicate key for list MldSnooping %v", key)
	}

	t.MldSnooping[key] = v
	return nil
}

// NewMpls creates a new entry in the Mpls list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewMpls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mpls == nil {
		t.Mpls = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Mpls[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Mpls", key)
	}

	t.Mpls[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls{
		Event: Event,
	}

	return t.Mpls[key], nil
}

// RenameMpls renames an entry in the list Mpls within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameMpls(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls_Event_Union) error {
	if _, ok := t.Mpls[newK]; ok {
		return fmt.Errorf("key %v already exists in Mpls", newK)
	}

	e, ok := t.Mpls[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Mpls", oldK)
	}
	e.Event = newK

	t.Mpls[newK] = e
	delete(t.Mpls, oldK)
	return nil
}

// GetOrCreateMpls retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateMpls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls {

	key := Event

	if v, ok := t.Mpls[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMpls(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMpls got unexpected error: %v", err))
	}
	return v
}

// GetMpls retrieves the value with the specified key from
// the Mpls map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetMpls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Mpls[key]; ok {
		return lm
	}
	return nil
}

// DeleteMpls deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteMpls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls_Event_Union) {
	key := Event

	delete(t.Mpls, key)
}

// AppendMpls appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls struct to the
// list Mpls of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendMpls(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Mpls == nil {
		t.Mpls = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Mpls)
	}

	if _, ok := t.Mpls[key]; ok {
		return fmt.Errorf("duplicate key for list Mpls %v", key)
	}

	t.Mpls[key] = v
	return nil
}

// NewMplsTp creates a new entry in the MplsTp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewMplsTp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MplsTp == nil {
		t.MplsTp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.MplsTp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list MplsTp", key)
	}

	t.MplsTp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp{
		Event: Event,
	}

	return t.MplsTp[key], nil
}

// RenameMplsTp renames an entry in the list MplsTp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameMplsTp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp_Event_Union) error {
	if _, ok := t.MplsTp[newK]; ok {
		return fmt.Errorf("key %v already exists in MplsTp", newK)
	}

	e, ok := t.MplsTp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in MplsTp", oldK)
	}
	e.Event = newK

	t.MplsTp[newK] = e
	delete(t.MplsTp, oldK)
	return nil
}

// GetOrCreateMplsTp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateMplsTp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp {

	key := Event

	if v, ok := t.MplsTp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMplsTp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMplsTp got unexpected error: %v", err))
	}
	return v
}

// GetMplsTp retrieves the value with the specified key from
// the MplsTp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetMplsTp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.MplsTp[key]; ok {
		return lm
	}
	return nil
}

// DeleteMplsTp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteMplsTp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp_Event_Union) {
	key := Event

	delete(t.MplsTp, key)
}

// AppendMplsTp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp struct to the
// list MplsTp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendMplsTp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.MplsTp == nil {
		t.MplsTp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_MplsTp)
	}

	if _, ok := t.MplsTp[key]; ok {
		return fmt.Errorf("duplicate key for list MplsTp %v", key)
	}

	t.MplsTp[key] = v
	return nil
}

// NewMsdp creates a new entry in the Msdp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewMsdp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Msdp == nil {
		t.Msdp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Msdp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Msdp", key)
	}

	t.Msdp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp{
		Event: Event,
	}

	return t.Msdp[key], nil
}

// RenameMsdp renames an entry in the list Msdp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameMsdp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp_Event_Union) error {
	if _, ok := t.Msdp[newK]; ok {
		return fmt.Errorf("key %v already exists in Msdp", newK)
	}

	e, ok := t.Msdp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Msdp", oldK)
	}
	e.Event = newK

	t.Msdp[newK] = e
	delete(t.Msdp, oldK)
	return nil
}

// GetOrCreateMsdp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateMsdp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp {

	key := Event

	if v, ok := t.Msdp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewMsdp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateMsdp got unexpected error: %v", err))
	}
	return v
}

// GetMsdp retrieves the value with the specified key from
// the Msdp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetMsdp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Msdp[key]; ok {
		return lm
	}
	return nil
}

// DeleteMsdp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteMsdp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp_Event_Union) {
	key := Event

	delete(t.Msdp, key)
}

// AppendMsdp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp struct to the
// list Msdp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendMsdp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Msdp == nil {
		t.Msdp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Msdp)
	}

	if _, ok := t.Msdp[key]; ok {
		return fmt.Errorf("duplicate key for list Msdp %v", key)
	}

	t.Msdp[key] = v
	return nil
}

// NewNat creates a new entry in the Nat list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewNat(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Nat == nil {
		t.Nat = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Nat[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Nat", key)
	}

	t.Nat[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat{
		Event: Event,
	}

	return t.Nat[key], nil
}

// RenameNat renames an entry in the list Nat within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameNat(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat_Event_Union) error {
	if _, ok := t.Nat[newK]; ok {
		return fmt.Errorf("key %v already exists in Nat", newK)
	}

	e, ok := t.Nat[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Nat", oldK)
	}
	e.Event = newK

	t.Nat[newK] = e
	delete(t.Nat, oldK)
	return nil
}

// GetOrCreateNat retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateNat(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat {

	key := Event

	if v, ok := t.Nat[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNat(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNat got unexpected error: %v", err))
	}
	return v
}

// GetNat retrieves the value with the specified key from
// the Nat map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetNat(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Nat[key]; ok {
		return lm
	}
	return nil
}

// DeleteNat deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteNat(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat_Event_Union) {
	key := Event

	delete(t.Nat, key)
}

// AppendNat appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat struct to the
// list Nat of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendNat(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Nat == nil {
		t.Nat = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Nat)
	}

	if _, ok := t.Nat[key]; ok {
		return fmt.Errorf("duplicate key for list Nat %v", key)
	}

	t.Nat[key] = v
	return nil
}

// NewNtp creates a new entry in the Ntp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewNtp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ntp == nil {
		t.Ntp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ntp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ntp", key)
	}

	t.Ntp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp{
		Event: Event,
	}

	return t.Ntp[key], nil
}

// RenameNtp renames an entry in the list Ntp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameNtp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp_Event_Union) error {
	if _, ok := t.Ntp[newK]; ok {
		return fmt.Errorf("key %v already exists in Ntp", newK)
	}

	e, ok := t.Ntp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ntp", oldK)
	}
	e.Event = newK

	t.Ntp[newK] = e
	delete(t.Ntp, oldK)
	return nil
}

// GetOrCreateNtp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateNtp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp {

	key := Event

	if v, ok := t.Ntp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewNtp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateNtp got unexpected error: %v", err))
	}
	return v
}

// GetNtp retrieves the value with the specified key from
// the Ntp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetNtp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Ntp[key]; ok {
		return lm
	}
	return nil
}

// DeleteNtp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteNtp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp_Event_Union) {
	key := Event

	delete(t.Ntp, key)
}

// AppendNtp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp struct to the
// list Ntp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendNtp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ntp == nil {
		t.Ntp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ntp)
	}

	if _, ok := t.Ntp[key]; ok {
		return fmt.Errorf("duplicate key for list Ntp %v", key)
	}

	t.Ntp[key] = v
	return nil
}

// NewOam creates a new entry in the Oam list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewOam(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Oam == nil {
		t.Oam = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Oam[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Oam", key)
	}

	t.Oam[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam{
		Event: Event,
	}

	return t.Oam[key], nil
}

// RenameOam renames an entry in the list Oam within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameOam(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam_Event_Union) error {
	if _, ok := t.Oam[newK]; ok {
		return fmt.Errorf("key %v already exists in Oam", newK)
	}

	e, ok := t.Oam[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Oam", oldK)
	}
	e.Event = newK

	t.Oam[newK] = e
	delete(t.Oam, oldK)
	return nil
}

// GetOrCreateOam retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateOam(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam {

	key := Event

	if v, ok := t.Oam[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewOam(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateOam got unexpected error: %v", err))
	}
	return v
}

// GetOam retrieves the value with the specified key from
// the Oam map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOam(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Oam[key]; ok {
		return lm
	}
	return nil
}

// DeleteOam deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteOam(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam_Event_Union) {
	key := Event

	delete(t.Oam, key)
}

// AppendOam appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam struct to the
// list Oam of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendOam(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Oam == nil {
		t.Oam = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Oam)
	}

	if _, ok := t.Oam[key]; ok {
		return fmt.Errorf("duplicate key for list Oam %v", key)
	}

	t.Oam[key] = v
	return nil
}

// NewOpenflow creates a new entry in the Openflow list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewOpenflow(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Openflow == nil {
		t.Openflow = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Openflow[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Openflow", key)
	}

	t.Openflow[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow{
		Event: Event,
	}

	return t.Openflow[key], nil
}

// RenameOpenflow renames an entry in the list Openflow within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameOpenflow(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow_Event_Union) error {
	if _, ok := t.Openflow[newK]; ok {
		return fmt.Errorf("key %v already exists in Openflow", newK)
	}

	e, ok := t.Openflow[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Openflow", oldK)
	}
	e.Event = newK

	t.Openflow[newK] = e
	delete(t.Openflow, oldK)
	return nil
}

// GetOrCreateOpenflow retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateOpenflow(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow {

	key := Event

	if v, ok := t.Openflow[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewOpenflow(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateOpenflow got unexpected error: %v", err))
	}
	return v
}

// GetOpenflow retrieves the value with the specified key from
// the Openflow map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOpenflow(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Openflow[key]; ok {
		return lm
	}
	return nil
}

// DeleteOpenflow deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteOpenflow(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow_Event_Union) {
	key := Event

	delete(t.Openflow, key)
}

// AppendOpenflow appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow struct to the
// list Openflow of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendOpenflow(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Openflow == nil {
		t.Openflow = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Openflow)
	}

	if _, ok := t.Openflow[key]; ok {
		return fmt.Errorf("duplicate key for list Openflow %v", key)
	}

	t.Openflow[key] = v
	return nil
}

// NewOspf creates a new entry in the Ospf list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewOspf(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ospf == nil {
		t.Ospf = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ospf[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ospf", key)
	}

	t.Ospf[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf{
		Event: Event,
	}

	return t.Ospf[key], nil
}

// RenameOspf renames an entry in the list Ospf within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameOspf(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf_Event_Union) error {
	if _, ok := t.Ospf[newK]; ok {
		return fmt.Errorf("key %v already exists in Ospf", newK)
	}

	e, ok := t.Ospf[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ospf", oldK)
	}
	e.Event = newK

	t.Ospf[newK] = e
	delete(t.Ospf, oldK)
	return nil
}

// GetOrCreateOspf retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateOspf(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf {

	key := Event

	if v, ok := t.Ospf[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewOspf(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateOspf got unexpected error: %v", err))
	}
	return v
}

// GetOspf retrieves the value with the specified key from
// the Ospf map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOspf(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Ospf[key]; ok {
		return lm
	}
	return nil
}

// DeleteOspf deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteOspf(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf_Event_Union) {
	key := Event

	delete(t.Ospf, key)
}

// AppendOspf appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf struct to the
// list Ospf of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendOspf(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ospf == nil {
		t.Ospf = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ospf)
	}

	if _, ok := t.Ospf[key]; ok {
		return fmt.Errorf("duplicate key for list Ospf %v", key)
	}

	t.Ospf[key] = v
	return nil
}

// NewPcap creates a new entry in the Pcap list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewPcap(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Pcap == nil {
		t.Pcap = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Pcap[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Pcap", key)
	}

	t.Pcap[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap{
		Event: Event,
	}

	return t.Pcap[key], nil
}

// RenamePcap renames an entry in the list Pcap within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenamePcap(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap_Event_Union) error {
	if _, ok := t.Pcap[newK]; ok {
		return fmt.Errorf("key %v already exists in Pcap", newK)
	}

	e, ok := t.Pcap[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Pcap", oldK)
	}
	e.Event = newK

	t.Pcap[newK] = e
	delete(t.Pcap, oldK)
	return nil
}

// GetOrCreatePcap retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreatePcap(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap {

	key := Event

	if v, ok := t.Pcap[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPcap(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePcap got unexpected error: %v", err))
	}
	return v
}

// GetPcap retrieves the value with the specified key from
// the Pcap map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetPcap(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Pcap[key]; ok {
		return lm
	}
	return nil
}

// DeletePcap deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeletePcap(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap_Event_Union) {
	key := Event

	delete(t.Pcap, key)
}

// AppendPcap appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap struct to the
// list Pcap of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendPcap(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Pcap == nil {
		t.Pcap = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcap)
	}

	if _, ok := t.Pcap[key]; ok {
		return fmt.Errorf("duplicate key for list Pcap %v", key)
	}

	t.Pcap[key] = v
	return nil
}

// NewPcep creates a new entry in the Pcep list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewPcep(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Pcep == nil {
		t.Pcep = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Pcep[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Pcep", key)
	}

	t.Pcep[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep{
		Event: Event,
	}

	return t.Pcep[key], nil
}

// RenamePcep renames an entry in the list Pcep within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenamePcep(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep_Event_Union) error {
	if _, ok := t.Pcep[newK]; ok {
		return fmt.Errorf("key %v already exists in Pcep", newK)
	}

	e, ok := t.Pcep[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Pcep", oldK)
	}
	e.Event = newK

	t.Pcep[newK] = e
	delete(t.Pcep, oldK)
	return nil
}

// GetOrCreatePcep retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreatePcep(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep {

	key := Event

	if v, ok := t.Pcep[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPcep(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePcep got unexpected error: %v", err))
	}
	return v
}

// GetPcep retrieves the value with the specified key from
// the Pcep map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetPcep(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Pcep[key]; ok {
		return lm
	}
	return nil
}

// DeletePcep deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeletePcep(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep_Event_Union) {
	key := Event

	delete(t.Pcep, key)
}

// AppendPcep appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep struct to the
// list Pcep of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendPcep(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Pcep == nil {
		t.Pcep = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pcep)
	}

	if _, ok := t.Pcep[key]; ok {
		return fmt.Errorf("duplicate key for list Pcep %v", key)
	}

	t.Pcep[key] = v
	return nil
}

// NewPim creates a new entry in the Pim list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewPim(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Pim == nil {
		t.Pim = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Pim[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Pim", key)
	}

	t.Pim[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim{
		Event: Event,
	}

	return t.Pim[key], nil
}

// RenamePim renames an entry in the list Pim within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenamePim(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim_Event_Union) error {
	if _, ok := t.Pim[newK]; ok {
		return fmt.Errorf("key %v already exists in Pim", newK)
	}

	e, ok := t.Pim[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Pim", oldK)
	}
	e.Event = newK

	t.Pim[newK] = e
	delete(t.Pim, oldK)
	return nil
}

// GetOrCreatePim retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreatePim(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim {

	key := Event

	if v, ok := t.Pim[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPim(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePim got unexpected error: %v", err))
	}
	return v
}

// GetPim retrieves the value with the specified key from
// the Pim map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetPim(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Pim[key]; ok {
		return lm
	}
	return nil
}

// DeletePim deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeletePim(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim_Event_Union) {
	key := Event

	delete(t.Pim, key)
}

// AppendPim appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim struct to the
// list Pim of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendPim(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Pim == nil {
		t.Pim = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pim)
	}

	if _, ok := t.Pim[key]; ok {
		return fmt.Errorf("duplicate key for list Pim %v", key)
	}

	t.Pim[key] = v
	return nil
}

// NewPimSnooping creates a new entry in the PimSnooping list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewPimSnooping(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PimSnooping == nil {
		t.PimSnooping = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PimSnooping[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PimSnooping", key)
	}

	t.PimSnooping[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping{
		Event: Event,
	}

	return t.PimSnooping[key], nil
}

// RenamePimSnooping renames an entry in the list PimSnooping within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenamePimSnooping(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping_Event_Union) error {
	if _, ok := t.PimSnooping[newK]; ok {
		return fmt.Errorf("key %v already exists in PimSnooping", newK)
	}

	e, ok := t.PimSnooping[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PimSnooping", oldK)
	}
	e.Event = newK

	t.PimSnooping[newK] = e
	delete(t.PimSnooping, oldK)
	return nil
}

// GetOrCreatePimSnooping retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreatePimSnooping(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping {

	key := Event

	if v, ok := t.PimSnooping[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPimSnooping(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePimSnooping got unexpected error: %v", err))
	}
	return v
}

// GetPimSnooping retrieves the value with the specified key from
// the PimSnooping map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetPimSnooping(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.PimSnooping[key]; ok {
		return lm
	}
	return nil
}

// DeletePimSnooping deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeletePimSnooping(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping_Event_Union) {
	key := Event

	delete(t.PimSnooping, key)
}

// AppendPimSnooping appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping struct to the
// list PimSnooping of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendPimSnooping(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PimSnooping == nil {
		t.PimSnooping = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_PimSnooping)
	}

	if _, ok := t.PimSnooping[key]; ok {
		return fmt.Errorf("duplicate key for list PimSnooping %v", key)
	}

	t.PimSnooping[key] = v
	return nil
}

// NewPort creates a new entry in the Port list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewPort(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Port == nil {
		t.Port = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Port[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Port", key)
	}

	t.Port[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port{
		Event: Event,
	}

	return t.Port[key], nil
}

// RenamePort renames an entry in the list Port within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenamePort(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port_Event_Union) error {
	if _, ok := t.Port[newK]; ok {
		return fmt.Errorf("key %v already exists in Port", newK)
	}

	e, ok := t.Port[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Port", oldK)
	}
	e.Event = newK

	t.Port[newK] = e
	delete(t.Port, oldK)
	return nil
}

// GetOrCreatePort retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreatePort(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port {

	key := Event

	if v, ok := t.Port[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPort(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePort got unexpected error: %v", err))
	}
	return v
}

// GetPort retrieves the value with the specified key from
// the Port map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetPort(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Port[key]; ok {
		return lm
	}
	return nil
}

// DeletePort deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeletePort(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port_Event_Union) {
	key := Event

	delete(t.Port, key)
}

// AppendPort appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port struct to the
// list Port of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendPort(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Port == nil {
		t.Port = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Port)
	}

	if _, ok := t.Port[key]; ok {
		return fmt.Errorf("duplicate key for list Port %v", key)
	}

	t.Port[key] = v
	return nil
}

// NewPpp creates a new entry in the Ppp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewPpp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ppp == nil {
		t.Ppp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ppp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ppp", key)
	}

	t.Ppp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp{
		Event: Event,
	}

	return t.Ppp[key], nil
}

// RenamePpp renames an entry in the list Ppp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenamePpp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp_Event_Union) error {
	if _, ok := t.Ppp[newK]; ok {
		return fmt.Errorf("key %v already exists in Ppp", newK)
	}

	e, ok := t.Ppp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ppp", oldK)
	}
	e.Event = newK

	t.Ppp[newK] = e
	delete(t.Ppp, oldK)
	return nil
}

// GetOrCreatePpp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreatePpp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp {

	key := Event

	if v, ok := t.Ppp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPpp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePpp got unexpected error: %v", err))
	}
	return v
}

// GetPpp retrieves the value with the specified key from
// the Ppp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetPpp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Ppp[key]; ok {
		return lm
	}
	return nil
}

// DeletePpp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeletePpp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp_Event_Union) {
	key := Event

	delete(t.Ppp, key)
}

// AppendPpp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp struct to the
// list Ppp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendPpp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ppp == nil {
		t.Ppp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ppp)
	}

	if _, ok := t.Ppp[key]; ok {
		return fmt.Errorf("duplicate key for list Ppp %v", key)
	}

	t.Ppp[key] = v
	return nil
}

// NewPppoe creates a new entry in the Pppoe list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewPppoe(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Pppoe == nil {
		t.Pppoe = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Pppoe[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Pppoe", key)
	}

	t.Pppoe[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe{
		Event: Event,
	}

	return t.Pppoe[key], nil
}

// RenamePppoe renames an entry in the list Pppoe within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenamePppoe(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe_Event_Union) error {
	if _, ok := t.Pppoe[newK]; ok {
		return fmt.Errorf("key %v already exists in Pppoe", newK)
	}

	e, ok := t.Pppoe[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Pppoe", oldK)
	}
	e.Event = newK

	t.Pppoe[newK] = e
	delete(t.Pppoe, oldK)
	return nil
}

// GetOrCreatePppoe retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreatePppoe(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe {

	key := Event

	if v, ok := t.Pppoe[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPppoe(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePppoe got unexpected error: %v", err))
	}
	return v
}

// GetPppoe retrieves the value with the specified key from
// the Pppoe map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetPppoe(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Pppoe[key]; ok {
		return lm
	}
	return nil
}

// DeletePppoe deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeletePppoe(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe_Event_Union) {
	key := Event

	delete(t.Pppoe, key)
}

// AppendPppoe appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe struct to the
// list Pppoe of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendPppoe(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Pppoe == nil {
		t.Pppoe = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Pppoe)
	}

	if _, ok := t.Pppoe[key]; ok {
		return fmt.Errorf("duplicate key for list Pppoe %v", key)
	}

	t.Pppoe[key] = v
	return nil
}

// NewPppoeClnt creates a new entry in the PppoeClnt list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewPppoeClnt(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PppoeClnt == nil {
		t.PppoeClnt = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.PppoeClnt[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list PppoeClnt", key)
	}

	t.PppoeClnt[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt{
		Event: Event,
	}

	return t.PppoeClnt[key], nil
}

// RenamePppoeClnt renames an entry in the list PppoeClnt within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenamePppoeClnt(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt_Event_Union) error {
	if _, ok := t.PppoeClnt[newK]; ok {
		return fmt.Errorf("key %v already exists in PppoeClnt", newK)
	}

	e, ok := t.PppoeClnt[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in PppoeClnt", oldK)
	}
	e.Event = newK

	t.PppoeClnt[newK] = e
	delete(t.PppoeClnt, oldK)
	return nil
}

// GetOrCreatePppoeClnt retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreatePppoeClnt(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt {

	key := Event

	if v, ok := t.PppoeClnt[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPppoeClnt(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePppoeClnt got unexpected error: %v", err))
	}
	return v
}

// GetPppoeClnt retrieves the value with the specified key from
// the PppoeClnt map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetPppoeClnt(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.PppoeClnt[key]; ok {
		return lm
	}
	return nil
}

// DeletePppoeClnt deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeletePppoeClnt(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt_Event_Union) {
	key := Event

	delete(t.PppoeClnt, key)
}

// AppendPppoeClnt appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt struct to the
// list PppoeClnt of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendPppoeClnt(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.PppoeClnt == nil {
		t.PppoeClnt = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_PppoeClnt)
	}

	if _, ok := t.PppoeClnt[key]; ok {
		return fmt.Errorf("duplicate key for list PppoeClnt %v", key)
	}

	t.PppoeClnt[key] = v
	return nil
}

// NewPtp creates a new entry in the Ptp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewPtp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ptp == nil {
		t.Ptp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ptp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ptp", key)
	}

	t.Ptp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp{
		Event: Event,
	}

	return t.Ptp[key], nil
}

// RenamePtp renames an entry in the list Ptp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenamePtp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp_Event_Union) error {
	if _, ok := t.Ptp[newK]; ok {
		return fmt.Errorf("key %v already exists in Ptp", newK)
	}

	e, ok := t.Ptp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ptp", oldK)
	}
	e.Event = newK

	t.Ptp[newK] = e
	delete(t.Ptp, oldK)
	return nil
}

// GetOrCreatePtp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreatePtp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp {

	key := Event

	if v, ok := t.Ptp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewPtp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreatePtp got unexpected error: %v", err))
	}
	return v
}

// GetPtp retrieves the value with the specified key from
// the Ptp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetPtp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Ptp[key]; ok {
		return lm
	}
	return nil
}

// DeletePtp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeletePtp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp_Event_Union) {
	key := Event

	delete(t.Ptp, key)
}

// AppendPtp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp struct to the
// list Ptp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendPtp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ptp == nil {
		t.Ptp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ptp)
	}

	if _, ok := t.Ptp[key]; ok {
		return fmt.Errorf("duplicate key for list Ptp %v", key)
	}

	t.Ptp[key] = v
	return nil
}

// NewRadius creates a new entry in the Radius list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewRadius(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Radius == nil {
		t.Radius = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Radius[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Radius", key)
	}

	t.Radius[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius{
		Event: Event,
	}

	return t.Radius[key], nil
}

// RenameRadius renames an entry in the list Radius within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameRadius(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius_Event_Union) error {
	if _, ok := t.Radius[newK]; ok {
		return fmt.Errorf("key %v already exists in Radius", newK)
	}

	e, ok := t.Radius[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Radius", oldK)
	}
	e.Event = newK

	t.Radius[newK] = e
	delete(t.Radius, oldK)
	return nil
}

// GetOrCreateRadius retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateRadius(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius {

	key := Event

	if v, ok := t.Radius[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRadius(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRadius got unexpected error: %v", err))
	}
	return v
}

// GetRadius retrieves the value with the specified key from
// the Radius map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetRadius(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Radius[key]; ok {
		return lm
	}
	return nil
}

// DeleteRadius deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteRadius(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius_Event_Union) {
	key := Event

	delete(t.Radius, key)
}

// AppendRadius appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius struct to the
// list Radius of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendRadius(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Radius == nil {
		t.Radius = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Radius)
	}

	if _, ok := t.Radius[key]; ok {
		return fmt.Errorf("duplicate key for list Radius %v", key)
	}

	t.Radius[key] = v
	return nil
}

// NewRip creates a new entry in the Rip list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewRip(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rip == nil {
		t.Rip = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Rip[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Rip", key)
	}

	t.Rip[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip{
		Event: Event,
	}

	return t.Rip[key], nil
}

// RenameRip renames an entry in the list Rip within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameRip(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip_Event_Union) error {
	if _, ok := t.Rip[newK]; ok {
		return fmt.Errorf("key %v already exists in Rip", newK)
	}

	e, ok := t.Rip[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Rip", oldK)
	}
	e.Event = newK

	t.Rip[newK] = e
	delete(t.Rip, oldK)
	return nil
}

// GetOrCreateRip retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateRip(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip {

	key := Event

	if v, ok := t.Rip[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRip(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRip got unexpected error: %v", err))
	}
	return v
}

// GetRip retrieves the value with the specified key from
// the Rip map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetRip(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Rip[key]; ok {
		return lm
	}
	return nil
}

// DeleteRip deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteRip(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip_Event_Union) {
	key := Event

	delete(t.Rip, key)
}

// AppendRip appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip struct to the
// list Rip of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendRip(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rip == nil {
		t.Rip = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rip)
	}

	if _, ok := t.Rip[key]; ok {
		return fmt.Errorf("duplicate key for list Rip %v", key)
	}

	t.Rip[key] = v
	return nil
}

// NewRipng creates a new entry in the Ripng list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewRipng(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ripng == nil {
		t.Ripng = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Ripng[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Ripng", key)
	}

	t.Ripng[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng{
		Event: Event,
	}

	return t.Ripng[key], nil
}

// RenameRipng renames an entry in the list Ripng within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameRipng(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng_Event_Union) error {
	if _, ok := t.Ripng[newK]; ok {
		return fmt.Errorf("key %v already exists in Ripng", newK)
	}

	e, ok := t.Ripng[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Ripng", oldK)
	}
	e.Event = newK

	t.Ripng[newK] = e
	delete(t.Ripng, oldK)
	return nil
}

// GetOrCreateRipng retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateRipng(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng {

	key := Event

	if v, ok := t.Ripng[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRipng(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRipng got unexpected error: %v", err))
	}
	return v
}

// GetRipng retrieves the value with the specified key from
// the Ripng map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetRipng(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Ripng[key]; ok {
		return lm
	}
	return nil
}

// DeleteRipng deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteRipng(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng_Event_Union) {
	key := Event

	delete(t.Ripng, key)
}

// AppendRipng appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng struct to the
// list Ripng of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendRipng(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Ripng == nil {
		t.Ripng = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ripng)
	}

	if _, ok := t.Ripng[key]; ok {
		return fmt.Errorf("duplicate key for list Ripng %v", key)
	}

	t.Ripng[key] = v
	return nil
}

// NewRoutePolicy creates a new entry in the RoutePolicy list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewRoutePolicy(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RoutePolicy == nil {
		t.RoutePolicy = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.RoutePolicy[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list RoutePolicy", key)
	}

	t.RoutePolicy[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy{
		Event: Event,
	}

	return t.RoutePolicy[key], nil
}

// RenameRoutePolicy renames an entry in the list RoutePolicy within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameRoutePolicy(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy_Event_Union) error {
	if _, ok := t.RoutePolicy[newK]; ok {
		return fmt.Errorf("key %v already exists in RoutePolicy", newK)
	}

	e, ok := t.RoutePolicy[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in RoutePolicy", oldK)
	}
	e.Event = newK

	t.RoutePolicy[newK] = e
	delete(t.RoutePolicy, oldK)
	return nil
}

// GetOrCreateRoutePolicy retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateRoutePolicy(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy {

	key := Event

	if v, ok := t.RoutePolicy[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRoutePolicy(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRoutePolicy got unexpected error: %v", err))
	}
	return v
}

// GetRoutePolicy retrieves the value with the specified key from
// the RoutePolicy map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetRoutePolicy(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.RoutePolicy[key]; ok {
		return lm
	}
	return nil
}

// DeleteRoutePolicy deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteRoutePolicy(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy_Event_Union) {
	key := Event

	delete(t.RoutePolicy, key)
}

// AppendRoutePolicy appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy struct to the
// list RoutePolicy of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendRoutePolicy(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.RoutePolicy == nil {
		t.RoutePolicy = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_RoutePolicy)
	}

	if _, ok := t.RoutePolicy[key]; ok {
		return fmt.Errorf("duplicate key for list RoutePolicy %v", key)
	}

	t.RoutePolicy[key] = v
	return nil
}

// NewRpki creates a new entry in the Rpki list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewRpki(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rpki == nil {
		t.Rpki = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Rpki[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Rpki", key)
	}

	t.Rpki[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki{
		Event: Event,
	}

	return t.Rpki[key], nil
}

// RenameRpki renames an entry in the list Rpki within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameRpki(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki_Event_Union) error {
	if _, ok := t.Rpki[newK]; ok {
		return fmt.Errorf("key %v already exists in Rpki", newK)
	}

	e, ok := t.Rpki[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Rpki", oldK)
	}
	e.Event = newK

	t.Rpki[newK] = e
	delete(t.Rpki, oldK)
	return nil
}

// GetOrCreateRpki retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateRpki(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki {

	key := Event

	if v, ok := t.Rpki[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRpki(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRpki got unexpected error: %v", err))
	}
	return v
}

// GetRpki retrieves the value with the specified key from
// the Rpki map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetRpki(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Rpki[key]; ok {
		return lm
	}
	return nil
}

// DeleteRpki deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteRpki(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki_Event_Union) {
	key := Event

	delete(t.Rpki, key)
}

// AppendRpki appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki struct to the
// list Rpki of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendRpki(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rpki == nil {
		t.Rpki = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rpki)
	}

	if _, ok := t.Rpki[key]; ok {
		return fmt.Errorf("duplicate key for list Rpki %v", key)
	}

	t.Rpki[key] = v
	return nil
}

// NewRsvp creates a new entry in the Rsvp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewRsvp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rsvp == nil {
		t.Rsvp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Rsvp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Rsvp", key)
	}

	t.Rsvp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp{
		Event: Event,
	}

	return t.Rsvp[key], nil
}

// RenameRsvp renames an entry in the list Rsvp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameRsvp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp_Event_Union) error {
	if _, ok := t.Rsvp[newK]; ok {
		return fmt.Errorf("key %v already exists in Rsvp", newK)
	}

	e, ok := t.Rsvp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Rsvp", oldK)
	}
	e.Event = newK

	t.Rsvp[newK] = e
	delete(t.Rsvp, oldK)
	return nil
}

// GetOrCreateRsvp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateRsvp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp {

	key := Event

	if v, ok := t.Rsvp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewRsvp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateRsvp got unexpected error: %v", err))
	}
	return v
}

// GetRsvp retrieves the value with the specified key from
// the Rsvp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetRsvp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Rsvp[key]; ok {
		return lm
	}
	return nil
}

// DeleteRsvp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteRsvp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp_Event_Union) {
	key := Event

	delete(t.Rsvp, key)
}

// AppendRsvp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp struct to the
// list Rsvp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendRsvp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Rsvp == nil {
		t.Rsvp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Rsvp)
	}

	if _, ok := t.Rsvp[key]; ok {
		return fmt.Errorf("duplicate key for list Rsvp %v", key)
	}

	t.Rsvp[key] = v
	return nil
}

// NewSatellite creates a new entry in the Satellite list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewSatellite(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Satellite == nil {
		t.Satellite = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Satellite[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Satellite", key)
	}

	t.Satellite[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite{
		Event: Event,
	}

	return t.Satellite[key], nil
}

// RenameSatellite renames an entry in the list Satellite within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameSatellite(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite_Event_Union) error {
	if _, ok := t.Satellite[newK]; ok {
		return fmt.Errorf("key %v already exists in Satellite", newK)
	}

	e, ok := t.Satellite[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Satellite", oldK)
	}
	e.Event = newK

	t.Satellite[newK] = e
	delete(t.Satellite, oldK)
	return nil
}

// GetOrCreateSatellite retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateSatellite(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite {

	key := Event

	if v, ok := t.Satellite[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSatellite(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSatellite got unexpected error: %v", err))
	}
	return v
}

// GetSatellite retrieves the value with the specified key from
// the Satellite map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetSatellite(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Satellite[key]; ok {
		return lm
	}
	return nil
}

// DeleteSatellite deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteSatellite(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite_Event_Union) {
	key := Event

	delete(t.Satellite, key)
}

// AppendSatellite appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite struct to the
// list Satellite of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendSatellite(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Satellite == nil {
		t.Satellite = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Satellite)
	}

	if _, ok := t.Satellite[key]; ok {
		return fmt.Errorf("duplicate key for list Satellite %v", key)
	}

	t.Satellite[key] = v
	return nil
}

// NewSecurity creates a new entry in the Security list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewSecurity(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Security == nil {
		t.Security = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Security[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Security", key)
	}

	t.Security[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security{
		Event: Event,
	}

	return t.Security[key], nil
}

// RenameSecurity renames an entry in the list Security within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameSecurity(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security_Event_Union) error {
	if _, ok := t.Security[newK]; ok {
		return fmt.Errorf("key %v already exists in Security", newK)
	}

	e, ok := t.Security[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Security", oldK)
	}
	e.Event = newK

	t.Security[newK] = e
	delete(t.Security, oldK)
	return nil
}

// GetOrCreateSecurity retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateSecurity(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security {

	key := Event

	if v, ok := t.Security[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSecurity(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSecurity got unexpected error: %v", err))
	}
	return v
}

// GetSecurity retrieves the value with the specified key from
// the Security map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetSecurity(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Security[key]; ok {
		return lm
	}
	return nil
}

// DeleteSecurity deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteSecurity(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security_Event_Union) {
	key := Event

	delete(t.Security, key)
}

// AppendSecurity appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security struct to the
// list Security of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendSecurity(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Security == nil {
		t.Security = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Security)
	}

	if _, ok := t.Security[key]; ok {
		return fmt.Errorf("duplicate key for list Security %v", key)
	}

	t.Security[key] = v
	return nil
}

// NewSflow creates a new entry in the Sflow list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewSflow(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Sflow == nil {
		t.Sflow = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Sflow[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Sflow", key)
	}

	t.Sflow[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow{
		Event: Event,
	}

	return t.Sflow[key], nil
}

// RenameSflow renames an entry in the list Sflow within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameSflow(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow_Event_Union) error {
	if _, ok := t.Sflow[newK]; ok {
		return fmt.Errorf("key %v already exists in Sflow", newK)
	}

	e, ok := t.Sflow[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Sflow", oldK)
	}
	e.Event = newK

	t.Sflow[newK] = e
	delete(t.Sflow, oldK)
	return nil
}

// GetOrCreateSflow retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateSflow(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow {

	key := Event

	if v, ok := t.Sflow[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSflow(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSflow got unexpected error: %v", err))
	}
	return v
}

// GetSflow retrieves the value with the specified key from
// the Sflow map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetSflow(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Sflow[key]; ok {
		return lm
	}
	return nil
}

// DeleteSflow deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteSflow(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow_Event_Union) {
	key := Event

	delete(t.Sflow, key)
}

// AppendSflow appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow struct to the
// list Sflow of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendSflow(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Sflow == nil {
		t.Sflow = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Sflow)
	}

	if _, ok := t.Sflow[key]; ok {
		return fmt.Errorf("duplicate key for list Sflow %v", key)
	}

	t.Sflow[key] = v
	return nil
}

// NewSnmp creates a new entry in the Snmp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewSnmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Snmp == nil {
		t.Snmp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Snmp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Snmp", key)
	}

	t.Snmp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp{
		Event: Event,
	}

	return t.Snmp[key], nil
}

// RenameSnmp renames an entry in the list Snmp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameSnmp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp_Event_Union) error {
	if _, ok := t.Snmp[newK]; ok {
		return fmt.Errorf("key %v already exists in Snmp", newK)
	}

	e, ok := t.Snmp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Snmp", oldK)
	}
	e.Event = newK

	t.Snmp[newK] = e
	delete(t.Snmp, oldK)
	return nil
}

// GetOrCreateSnmp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateSnmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp {

	key := Event

	if v, ok := t.Snmp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSnmp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSnmp got unexpected error: %v", err))
	}
	return v
}

// GetSnmp retrieves the value with the specified key from
// the Snmp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetSnmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Snmp[key]; ok {
		return lm
	}
	return nil
}

// DeleteSnmp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteSnmp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp_Event_Union) {
	key := Event

	delete(t.Snmp, key)
}

// AppendSnmp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp struct to the
// list Snmp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendSnmp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Snmp == nil {
		t.Snmp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Snmp)
	}

	if _, ok := t.Snmp[key]; ok {
		return fmt.Errorf("duplicate key for list Snmp %v", key)
	}

	t.Snmp[key] = v
	return nil
}

// NewSrMpls creates a new entry in the SrMpls list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewSrMpls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SrMpls == nil {
		t.SrMpls = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.SrMpls[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list SrMpls", key)
	}

	t.SrMpls[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls{
		Event: Event,
	}

	return t.SrMpls[key], nil
}

// RenameSrMpls renames an entry in the list SrMpls within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameSrMpls(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls_Event_Union) error {
	if _, ok := t.SrMpls[newK]; ok {
		return fmt.Errorf("key %v already exists in SrMpls", newK)
	}

	e, ok := t.SrMpls[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in SrMpls", oldK)
	}
	e.Event = newK

	t.SrMpls[newK] = e
	delete(t.SrMpls, oldK)
	return nil
}

// GetOrCreateSrMpls retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateSrMpls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls {

	key := Event

	if v, ok := t.SrMpls[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrMpls(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrMpls got unexpected error: %v", err))
	}
	return v
}

// GetSrMpls retrieves the value with the specified key from
// the SrMpls map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetSrMpls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.SrMpls[key]; ok {
		return lm
	}
	return nil
}

// DeleteSrMpls deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteSrMpls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls_Event_Union) {
	key := Event

	delete(t.SrMpls, key)
}

// AppendSrMpls appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls struct to the
// list SrMpls of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendSrMpls(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.SrMpls == nil {
		t.SrMpls = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_SrMpls)
	}

	if _, ok := t.SrMpls[key]; ok {
		return fmt.Errorf("duplicate key for list SrMpls %v", key)
	}

	t.SrMpls[key] = v
	return nil
}

// NewSrv6 creates a new entry in the Srv6 list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewSrv6(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srv6 == nil {
		t.Srv6 = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Srv6[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Srv6", key)
	}

	t.Srv6[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6{
		Event: Event,
	}

	return t.Srv6[key], nil
}

// RenameSrv6 renames an entry in the list Srv6 within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameSrv6(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6_Event_Union) error {
	if _, ok := t.Srv6[newK]; ok {
		return fmt.Errorf("key %v already exists in Srv6", newK)
	}

	e, ok := t.Srv6[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Srv6", oldK)
	}
	e.Event = newK

	t.Srv6[newK] = e
	delete(t.Srv6, oldK)
	return nil
}

// GetOrCreateSrv6 retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateSrv6(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6 {

	key := Event

	if v, ok := t.Srv6[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSrv6(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSrv6 got unexpected error: %v", err))
	}
	return v
}

// GetSrv6 retrieves the value with the specified key from
// the Srv6 map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetSrv6(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6 {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Srv6[key]; ok {
		return lm
	}
	return nil
}

// DeleteSrv6 deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteSrv6(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6_Event_Union) {
	key := Event

	delete(t.Srv6, key)
}

// AppendSrv6 appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6 struct to the
// list Srv6 of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6 already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendSrv6(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Srv6 == nil {
		t.Srv6 = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Srv6)
	}

	if _, ok := t.Srv6[key]; ok {
		return fmt.Errorf("duplicate key for list Srv6 %v", key)
	}

	t.Srv6[key] = v
	return nil
}

// NewStp creates a new entry in the Stp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewStp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Stp == nil {
		t.Stp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Stp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Stp", key)
	}

	t.Stp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp{
		Event: Event,
	}

	return t.Stp[key], nil
}

// RenameStp renames an entry in the list Stp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameStp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp_Event_Union) error {
	if _, ok := t.Stp[newK]; ok {
		return fmt.Errorf("key %v already exists in Stp", newK)
	}

	e, ok := t.Stp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Stp", oldK)
	}
	e.Event = newK

	t.Stp[newK] = e
	delete(t.Stp, oldK)
	return nil
}

// GetOrCreateStp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateStp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp {

	key := Event

	if v, ok := t.Stp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewStp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateStp got unexpected error: %v", err))
	}
	return v
}

// GetStp retrieves the value with the specified key from
// the Stp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetStp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Stp[key]; ok {
		return lm
	}
	return nil
}

// DeleteStp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteStp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp_Event_Union) {
	key := Event

	delete(t.Stp, key)
}

// AppendStp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp struct to the
// list Stp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendStp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Stp == nil {
		t.Stp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Stp)
	}

	if _, ok := t.Stp[key]; ok {
		return fmt.Errorf("duplicate key for list Stp %v", key)
	}

	t.Stp[key] = v
	return nil
}

// NewSvcmgr creates a new entry in the Svcmgr list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewSvcmgr(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Svcmgr == nil {
		t.Svcmgr = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Svcmgr[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Svcmgr", key)
	}

	t.Svcmgr[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr{
		Event: Event,
	}

	return t.Svcmgr[key], nil
}

// RenameSvcmgr renames an entry in the list Svcmgr within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameSvcmgr(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr_Event_Union) error {
	if _, ok := t.Svcmgr[newK]; ok {
		return fmt.Errorf("key %v already exists in Svcmgr", newK)
	}

	e, ok := t.Svcmgr[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Svcmgr", oldK)
	}
	e.Event = newK

	t.Svcmgr[newK] = e
	delete(t.Svcmgr, oldK)
	return nil
}

// GetOrCreateSvcmgr retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateSvcmgr(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr {

	key := Event

	if v, ok := t.Svcmgr[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSvcmgr(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSvcmgr got unexpected error: %v", err))
	}
	return v
}

// GetSvcmgr retrieves the value with the specified key from
// the Svcmgr map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetSvcmgr(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Svcmgr[key]; ok {
		return lm
	}
	return nil
}

// DeleteSvcmgr deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteSvcmgr(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr_Event_Union) {
	key := Event

	delete(t.Svcmgr, key)
}

// AppendSvcmgr appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr struct to the
// list Svcmgr of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendSvcmgr(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Svcmgr == nil {
		t.Svcmgr = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Svcmgr)
	}

	if _, ok := t.Svcmgr[key]; ok {
		return fmt.Errorf("duplicate key for list Svcmgr %v", key)
	}

	t.Svcmgr[key] = v
	return nil
}

// NewSystem creates a new entry in the System list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewSystem(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_System_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_System, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.System == nil {
		t.System = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_System_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_System)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.System[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list System", key)
	}

	t.System[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_System{
		Event: Event,
	}

	return t.System[key], nil
}

// RenameSystem renames an entry in the list System within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameSystem(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_System_Event_Union) error {
	if _, ok := t.System[newK]; ok {
		return fmt.Errorf("key %v already exists in System", newK)
	}

	e, ok := t.System[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in System", oldK)
	}
	e.Event = newK

	t.System[newK] = e
	delete(t.System, oldK)
	return nil
}

// GetOrCreateSystem retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateSystem(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_System_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_System {

	key := Event

	if v, ok := t.System[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewSystem(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateSystem got unexpected error: %v", err))
	}
	return v
}

// GetSystem retrieves the value with the specified key from
// the System map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetSystem(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_System_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_System {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.System[key]; ok {
		return lm
	}
	return nil
}

// DeleteSystem deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteSystem(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_System_Event_Union) {
	key := Event

	delete(t.System, key)
}

// AppendSystem appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_System struct to the
// list System of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_System already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendSystem(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_System) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.System == nil {
		t.System = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_System_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_System)
	}

	if _, ok := t.System[key]; ok {
		return fmt.Errorf("duplicate key for list System %v", key)
	}

	t.System[key] = v
	return nil
}

// NewTls creates a new entry in the Tls list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewTls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tls == nil {
		t.Tls = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Tls[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Tls", key)
	}

	t.Tls[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls{
		Event: Event,
	}

	return t.Tls[key], nil
}

// RenameTls renames an entry in the list Tls within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameTls(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls_Event_Union) error {
	if _, ok := t.Tls[newK]; ok {
		return fmt.Errorf("key %v already exists in Tls", newK)
	}

	e, ok := t.Tls[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Tls", oldK)
	}
	e.Event = newK

	t.Tls[newK] = e
	delete(t.Tls, oldK)
	return nil
}

// GetOrCreateTls retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateTls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls {

	key := Event

	if v, ok := t.Tls[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTls(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTls got unexpected error: %v", err))
	}
	return v
}

// GetTls retrieves the value with the specified key from
// the Tls map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetTls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Tls[key]; ok {
		return lm
	}
	return nil
}

// DeleteTls deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteTls(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls_Event_Union) {
	key := Event

	delete(t.Tls, key)
}

// AppendTls appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls struct to the
// list Tls of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendTls(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Tls == nil {
		t.Tls = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Tls)
	}

	if _, ok := t.Tls[key]; ok {
		return fmt.Errorf("duplicate key for list Tls %v", key)
	}

	t.Tls[key] = v
	return nil
}

// NewTreeSid creates a new entry in the TreeSid list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewTreeSid(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TreeSid == nil {
		t.TreeSid = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.TreeSid[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list TreeSid", key)
	}

	t.TreeSid[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid{
		Event: Event,
	}

	return t.TreeSid[key], nil
}

// RenameTreeSid renames an entry in the list TreeSid within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameTreeSid(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid_Event_Union) error {
	if _, ok := t.TreeSid[newK]; ok {
		return fmt.Errorf("key %v already exists in TreeSid", newK)
	}

	e, ok := t.TreeSid[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in TreeSid", oldK)
	}
	e.Event = newK

	t.TreeSid[newK] = e
	delete(t.TreeSid, oldK)
	return nil
}

// GetOrCreateTreeSid retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateTreeSid(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid {

	key := Event

	if v, ok := t.TreeSid[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewTreeSid(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateTreeSid got unexpected error: %v", err))
	}
	return v
}

// GetTreeSid retrieves the value with the specified key from
// the TreeSid map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetTreeSid(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.TreeSid[key]; ok {
		return lm
	}
	return nil
}

// DeleteTreeSid deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteTreeSid(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid_Event_Union) {
	key := Event

	delete(t.TreeSid, key)
}

// AppendTreeSid appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid struct to the
// list TreeSid of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendTreeSid(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.TreeSid == nil {
		t.TreeSid = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_TreeSid)
	}

	if _, ok := t.TreeSid[key]; ok {
		return fmt.Errorf("duplicate key for list TreeSid %v", key)
	}

	t.TreeSid[key] = v
	return nil
}

// NewUser creates a new entry in the User list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewUser(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_User_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_User, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_User_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_User)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.User[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list User", key)
	}

	t.User[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_User{
		Event: Event,
	}

	return t.User[key], nil
}

// RenameUser renames an entry in the list User within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameUser(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_User_Event_Union) error {
	if _, ok := t.User[newK]; ok {
		return fmt.Errorf("key %v already exists in User", newK)
	}

	e, ok := t.User[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in User", oldK)
	}
	e.Event = newK

	t.User[newK] = e
	delete(t.User, oldK)
	return nil
}

// GetOrCreateUser retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateUser(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_User_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_User {

	key := Event

	if v, ok := t.User[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewUser(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateUser got unexpected error: %v", err))
	}
	return v
}

// GetUser retrieves the value with the specified key from
// the User map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetUser(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_User_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_User {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.User[key]; ok {
		return lm
	}
	return nil
}

// DeleteUser deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteUser(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_User_Event_Union) {
	key := Event

	delete(t.User, key)
}

// AppendUser appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_User struct to the
// list User of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_User already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendUser(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_User) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.User == nil {
		t.User = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_User_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_User)
	}

	if _, ok := t.User[key]; ok {
		return fmt.Errorf("duplicate key for list User %v", key)
	}

	t.User[key] = v
	return nil
}

// NewVideo creates a new entry in the Video list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewVideo(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Video == nil {
		t.Video = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Video[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Video", key)
	}

	t.Video[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video{
		Event: Event,
	}

	return t.Video[key], nil
}

// RenameVideo renames an entry in the list Video within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameVideo(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video_Event_Union) error {
	if _, ok := t.Video[newK]; ok {
		return fmt.Errorf("key %v already exists in Video", newK)
	}

	e, ok := t.Video[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Video", oldK)
	}
	e.Event = newK

	t.Video[newK] = e
	delete(t.Video, oldK)
	return nil
}

// GetOrCreateVideo retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateVideo(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video {

	key := Event

	if v, ok := t.Video[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVideo(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVideo got unexpected error: %v", err))
	}
	return v
}

// GetVideo retrieves the value with the specified key from
// the Video map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetVideo(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Video[key]; ok {
		return lm
	}
	return nil
}

// DeleteVideo deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteVideo(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video_Event_Union) {
	key := Event

	delete(t.Video, key)
}

// AppendVideo appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video struct to the
// list Video of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendVideo(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Video == nil {
		t.Video = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Video)
	}

	if _, ok := t.Video[key]; ok {
		return fmt.Errorf("duplicate key for list Video %v", key)
	}

	t.Video[key] = v
	return nil
}

// NewVrrp creates a new entry in the Vrrp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewVrrp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vrrp == nil {
		t.Vrrp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vrrp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vrrp", key)
	}

	t.Vrrp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp{
		Event: Event,
	}

	return t.Vrrp[key], nil
}

// RenameVrrp renames an entry in the list Vrrp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameVrrp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp_Event_Union) error {
	if _, ok := t.Vrrp[newK]; ok {
		return fmt.Errorf("key %v already exists in Vrrp", newK)
	}

	e, ok := t.Vrrp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vrrp", oldK)
	}
	e.Event = newK

	t.Vrrp[newK] = e
	delete(t.Vrrp, oldK)
	return nil
}

// GetOrCreateVrrp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateVrrp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp {

	key := Event

	if v, ok := t.Vrrp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrrp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrrp got unexpected error: %v", err))
	}
	return v
}

// GetVrrp retrieves the value with the specified key from
// the Vrrp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetVrrp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Vrrp[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrrp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteVrrp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp_Event_Union) {
	key := Event

	delete(t.Vrrp, key)
}

// AppendVrrp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp struct to the
// list Vrrp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendVrrp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vrrp == nil {
		t.Vrrp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrrp)
	}

	if _, ok := t.Vrrp[key]; ok {
		return fmt.Errorf("duplicate key for list Vrrp %v", key)
	}

	t.Vrrp[key] = v
	return nil
}

// NewVrtr creates a new entry in the Vrtr list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewVrtr(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vrtr == nil {
		t.Vrtr = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Vrtr[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Vrtr", key)
	}

	t.Vrtr[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr{
		Event: Event,
	}

	return t.Vrtr[key], nil
}

// RenameVrtr renames an entry in the list Vrtr within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameVrtr(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr_Event_Union) error {
	if _, ok := t.Vrtr[newK]; ok {
		return fmt.Errorf("key %v already exists in Vrtr", newK)
	}

	e, ok := t.Vrtr[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Vrtr", oldK)
	}
	e.Event = newK

	t.Vrtr[newK] = e
	delete(t.Vrtr, oldK)
	return nil
}

// GetOrCreateVrtr retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateVrtr(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr {

	key := Event

	if v, ok := t.Vrtr[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewVrtr(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateVrtr got unexpected error: %v", err))
	}
	return v
}

// GetVrtr retrieves the value with the specified key from
// the Vrtr map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetVrtr(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Vrtr[key]; ok {
		return lm
	}
	return nil
}

// DeleteVrtr deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteVrtr(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr_Event_Union) {
	key := Event

	delete(t.Vrtr, key)
}

// AppendVrtr appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr struct to the
// list Vrtr of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendVrtr(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Vrtr == nil {
		t.Vrtr = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Vrtr)
	}

	if _, ok := t.Vrtr[key]; ok {
		return fmt.Errorf("duplicate key for list Vrtr %v", key)
	}

	t.Vrtr[key] = v
	return nil
}

// NewWlanGw creates a new entry in the WlanGw list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewWlanGw(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.WlanGw == nil {
		t.WlanGw = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.WlanGw[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list WlanGw", key)
	}

	t.WlanGw[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw{
		Event: Event,
	}

	return t.WlanGw[key], nil
}

// RenameWlanGw renames an entry in the list WlanGw within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameWlanGw(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw_Event_Union) error {
	if _, ok := t.WlanGw[newK]; ok {
		return fmt.Errorf("key %v already exists in WlanGw", newK)
	}

	e, ok := t.WlanGw[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in WlanGw", oldK)
	}
	e.Event = newK

	t.WlanGw[newK] = e
	delete(t.WlanGw, oldK)
	return nil
}

// GetOrCreateWlanGw retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateWlanGw(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw {

	key := Event

	if v, ok := t.WlanGw[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewWlanGw(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateWlanGw got unexpected error: %v", err))
	}
	return v
}

// GetWlanGw retrieves the value with the specified key from
// the WlanGw map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetWlanGw(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.WlanGw[key]; ok {
		return lm
	}
	return nil
}

// DeleteWlanGw deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteWlanGw(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw_Event_Union) {
	key := Event

	delete(t.WlanGw, key)
}

// AppendWlanGw appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw struct to the
// list WlanGw of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendWlanGw(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.WlanGw == nil {
		t.WlanGw = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_WlanGw)
	}

	if _, ok := t.WlanGw[key]; ok {
		return fmt.Errorf("duplicate key for list WlanGw %v", key)
	}

	t.WlanGw[key] = v
	return nil
}

// NewWpp creates a new entry in the Wpp list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) NewWpp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp_Event_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Wpp == nil {
		t.Wpp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp)
	}

	key := Event

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Wpp[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Wpp", key)
	}

	t.Wpp[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp{
		Event: Event,
	}

	return t.Wpp[key], nil
}

// RenameWpp renames an entry in the list Wpp within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) RenameWpp(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp_Event_Union) error {
	if _, ok := t.Wpp[newK]; ok {
		return fmt.Errorf("key %v already exists in Wpp", newK)
	}

	e, ok := t.Wpp[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Wpp", oldK)
	}
	e.Event = newK

	t.Wpp[newK] = e
	delete(t.Wpp, oldK)
	return nil
}

// GetOrCreateWpp retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetOrCreateWpp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp {

	key := Event

	if v, ok := t.Wpp[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewWpp(Event)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateWpp got unexpected error: %v", err))
	}
	return v
}

// GetWpp retrieves the value with the specified key from
// the Wpp map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) GetWpp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp_Event_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp {

	if t == nil {
		return nil
	}

	key := Event

	if lm, ok := t.Wpp[key]; ok {
		return lm
	}
	return nil
}

// DeleteWpp deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) DeleteWpp(Event NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp_Event_Union) {
	key := Event

	delete(t.Wpp, key)
}

// AppendWpp appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp struct to the
// list Wpp of NokiaConf_Configure_Groups_Group_Log_EventTrigger. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) AppendWpp(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp) error {
	key := v.Event

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Wpp == nil {
		t.Wpp = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp_Event_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Wpp)
	}

	if _, ok := t.Wpp[key]; ok {
		return fmt.Errorf("duplicate key for list Wpp %v", key)
	}

	t.Wpp[key] = v
	return nil
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	for _, e := range t.Adp {
		e.PopulateDefaults()
	}
	for _, e := range t.ApplicationAssurance {
		e.PopulateDefaults()
	}
	for _, e := range t.Aps {
		e.PopulateDefaults()
	}
	for _, e := range t.Atm {
		e.PopulateDefaults()
	}
	for _, e := range t.AutoProv {
		e.PopulateDefaults()
	}
	for _, e := range t.Bfd {
		e.PopulateDefaults()
	}
	for _, e := range t.Bgp {
		e.PopulateDefaults()
	}
	for _, e := range t.Bier {
		e.PopulateDefaults()
	}
	for _, e := range t.Calltrace {
		e.PopulateDefaults()
	}
	for _, e := range t.Cflowd {
		e.PopulateDefaults()
	}
	for _, e := range t.Chassis {
		e.PopulateDefaults()
	}
	for _, e := range t.Debug {
		e.PopulateDefaults()
	}
	for _, e := range t.Dhcp {
		e.PopulateDefaults()
	}
	for _, e := range t.Dhcps {
		e.PopulateDefaults()
	}
	for _, e := range t.Diameter {
		e.PopulateDefaults()
	}
	for _, e := range t.Dynsvc {
		e.PopulateDefaults()
	}
	for _, e := range t.EfmOam {
		e.PopulateDefaults()
	}
	for _, e := range t.Elmi {
		e.PopulateDefaults()
	}
	for _, e := range t.Ering {
		e.PopulateDefaults()
	}
	for _, e := range t.EthCfm {
		e.PopulateDefaults()
	}
	for _, e := range t.Etun {
		e.PopulateDefaults()
	}
	for _, e := range t.Filter {
		e.PopulateDefaults()
	}
	for _, e := range t.Gmpls {
		e.PopulateDefaults()
	}
	for _, e := range t.Gsmp {
		e.PopulateDefaults()
	}
	for _, e := range t.Igh {
		e.PopulateDefaults()
	}
	for _, e := range t.Igmp {
		e.PopulateDefaults()
	}
	for _, e := range t.IgmpSnooping {
		e.PopulateDefaults()
	}
	for _, e := range t.Ip {
		e.PopulateDefaults()
	}
	for _, e := range t.Ipsec {
		e.PopulateDefaults()
	}
	for _, e := range t.Isis {
		e.PopulateDefaults()
	}
	for _, e := range t.L2Tp {
		e.PopulateDefaults()
	}
	for _, e := range t.Lag {
		e.PopulateDefaults()
	}
	for _, e := range t.Ldap {
		e.PopulateDefaults()
	}
	for _, e := range t.Ldp {
		e.PopulateDefaults()
	}
	for _, e := range t.Li {
		e.PopulateDefaults()
	}
	for _, e := range t.Lldp {
		e.PopulateDefaults()
	}
	for _, e := range t.Lmp {
		e.PopulateDefaults()
	}
	for _, e := range t.Logger {
		e.PopulateDefaults()
	}
	for _, e := range t.Macsec {
		e.PopulateDefaults()
	}
	for _, e := range t.McRedundancy {
		e.PopulateDefaults()
	}
	for _, e := range t.Mcpath {
		e.PopulateDefaults()
	}
	for _, e := range t.MgmtCore {
		e.PopulateDefaults()
	}
	for _, e := range t.Mirror {
		e.PopulateDefaults()
	}
	for _, e := range t.Mld {
		e.PopulateDefaults()
	}
	for _, e := range t.MldSnooping {
		e.PopulateDefaults()
	}
	for _, e := range t.Mpls {
		e.PopulateDefaults()
	}
	for _, e := range t.MplsTp {
		e.PopulateDefaults()
	}
	for _, e := range t.Msdp {
		e.PopulateDefaults()
	}
	for _, e := range t.Nat {
		e.PopulateDefaults()
	}
	for _, e := range t.Ntp {
		e.PopulateDefaults()
	}
	for _, e := range t.Oam {
		e.PopulateDefaults()
	}
	for _, e := range t.Openflow {
		e.PopulateDefaults()
	}
	for _, e := range t.Ospf {
		e.PopulateDefaults()
	}
	for _, e := range t.Pcap {
		e.PopulateDefaults()
	}
	for _, e := range t.Pcep {
		e.PopulateDefaults()
	}
	for _, e := range t.Pim {
		e.PopulateDefaults()
	}
	for _, e := range t.PimSnooping {
		e.PopulateDefaults()
	}
	for _, e := range t.Port {
		e.PopulateDefaults()
	}
	for _, e := range t.Ppp {
		e.PopulateDefaults()
	}
	for _, e := range t.Pppoe {
		e.PopulateDefaults()
	}
	for _, e := range t.PppoeClnt {
		e.PopulateDefaults()
	}
	for _, e := range t.Ptp {
		e.PopulateDefaults()
	}
	for _, e := range t.Radius {
		e.PopulateDefaults()
	}
	for _, e := range t.Rip {
		e.PopulateDefaults()
	}
	for _, e := range t.Ripng {
		e.PopulateDefaults()
	}
	for _, e := range t.RoutePolicy {
		e.PopulateDefaults()
	}
	for _, e := range t.Rpki {
		e.PopulateDefaults()
	}
	for _, e := range t.Rsvp {
		e.PopulateDefaults()
	}
	for _, e := range t.Satellite {
		e.PopulateDefaults()
	}
	for _, e := range t.Security {
		e.PopulateDefaults()
	}
	for _, e := range t.Sflow {
		e.PopulateDefaults()
	}
	for _, e := range t.Snmp {
		e.PopulateDefaults()
	}
	for _, e := range t.SrMpls {
		e.PopulateDefaults()
	}
	for _, e := range t.Srv6 {
		e.PopulateDefaults()
	}
	for _, e := range t.Stp {
		e.PopulateDefaults()
	}
	for _, e := range t.Svcmgr {
		e.PopulateDefaults()
	}
	for _, e := range t.System {
		e.PopulateDefaults()
	}
	for _, e := range t.Tls {
		e.PopulateDefaults()
	}
	for _, e := range t.TreeSid {
		e.PopulateDefaults()
	}
	for _, e := range t.User {
		e.PopulateDefaults()
	}
	for _, e := range t.Video {
		e.PopulateDefaults()
	}
	for _, e := range t.Vrrp {
		e.PopulateDefaults()
	}
	for _, e := range t.Vrtr {
		e.PopulateDefaults()
	}
	for _, e := range t.WlanGw {
		e.PopulateDefaults()
	}
	for _, e := range t.Wpp {
		e.PopulateDefaults()
	}
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp represents the /nokia-conf/configure/groups/group/log/event-trigger/adp YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                           `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                               `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Event_Union                                                                     `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/adp/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                           `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                               `path:"description" module:"nokia-conf"`
	Filter      *string                                                               `path:"filter" module:"nokia-conf"`
	Handler     *string                                                               `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/adp/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Adp_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance represents the /nokia-conf/configure/groups/group/log/event-trigger/application-assurance YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                                                             `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                                                 `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Event_Union                                                                                      `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/application-assurance/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                                            `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                                `path:"description" module:"nokia-conf"`
	Filter      *string                                                                                `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                                `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) IsYANGGoStruct() {
}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/application-assurance/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce) IsYANGGoStruct() {
}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_ApplicationAssurance_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps represents the /nokia-conf/configure/groups/group/log/event-trigger/aps YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                           `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                               `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Event_Union                                                                     `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/aps/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                           `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                               `path:"description" module:"nokia-conf"`
	Filter      *string                                                               `path:"filter" module:"nokia-conf"`
	Handler     *string                                                               `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/aps/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Aps_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm represents the /nokia-conf/configure/groups/group/log/event-trigger/atm YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                           `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                               `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Event_Union                                                                     `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/atm/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                           `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                               `path:"description" module:"nokia-conf"`
	Filter      *string                                                               `path:"filter" module:"nokia-conf"`
	Handler     *string                                                               `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/atm/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Atm_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv represents the /nokia-conf/configure/groups/group/log/event-trigger/auto-prov YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                                     `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                         `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Event_Union                                                                          `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/auto-prov/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                                `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                    `path:"description" module:"nokia-conf"`
	Filter      *string                                                                    `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                    `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/auto-prov/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_AutoProv_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd represents the /nokia-conf/configure/groups/group/log/event-trigger/bfd YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                           `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                               `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Event_Union                                                                     `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/bfd/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                           `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                               `path:"description" module:"nokia-conf"`
	Filter      *string                                                               `path:"filter" module:"nokia-conf"`
	Handler     *string                                                               `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/bfd/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bfd_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp represents the /nokia-conf/configure/groups/group/log/event-trigger/bgp YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                           `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                               `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Event_Union                                                                     `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/bgp/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                           `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                               `path:"description" module:"nokia-conf"`
	Filter      *string                                                               `path:"filter" module:"nokia-conf"`
	Handler     *string                                                               `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/bgp/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bgp_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier represents the /nokia-conf/configure/groups/group/log/event-trigger/bier YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                             `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                 `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Event_Union                                                                      `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/bier/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                            `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                `path:"description" module:"nokia-conf"`
	Filter      *string                                                                `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/bier/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Bier_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace represents the /nokia-conf/configure/groups/group/log/event-trigger/calltrace YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                                       `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                           `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Event_Union                                                                           `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/calltrace/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                                 `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                     `path:"description" module:"nokia-conf"`
	Filter      *string                                                                     `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                     `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/calltrace/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Calltrace_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd represents the /nokia-conf/configure/groups/group/log/event-trigger/cflowd YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                                 `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                     `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Event_Union                                                                        `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/cflowd/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                              `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                  `path:"description" module:"nokia-conf"`
	Filter      *string                                                                  `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                  `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/cflowd/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Cflowd_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis represents the /nokia-conf/configure/groups/group/log/event-trigger/chassis YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                                   `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                       `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Event_Union                                                                         `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/chassis/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                               `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                   `path:"description" module:"nokia-conf"`
	Filter      *string                                                                   `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                   `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/chassis/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Chassis_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug represents the /nokia-conf/configure/groups/group/log/event-trigger/debug YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                               `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                   `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Event_Union                                                                       `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/debug/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                             `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                 `path:"description" module:"nokia-conf"`
	Filter      *string                                                                 `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                 `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/debug/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Debug_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp represents the /nokia-conf/configure/groups/group/log/event-trigger/dhcp YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                             `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                 `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Event_Union                                                                      `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/dhcp/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                            `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                `path:"description" module:"nokia-conf"`
	Filter      *string                                                                `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/dhcp/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcp_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps represents the /nokia-conf/configure/groups/group/log/event-trigger/dhcps YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                               `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                   `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Event_Union                                                                       `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/dhcps/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                             `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                 `path:"description" module:"nokia-conf"`
	Filter      *string                                                                 `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                 `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/dhcps/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dhcps_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter represents the /nokia-conf/configure/groups/group/log/event-trigger/diameter YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                                     `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                         `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Event_Union                                                                          `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/diameter/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                                `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                    `path:"description" module:"nokia-conf"`
	Filter      *string                                                                    `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                    `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/diameter/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Diameter_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc represents the /nokia-conf/configure/groups/group/log/event-trigger/dynsvc YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                                 `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                     `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Event_Union                                                                        `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/dynsvc/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                              `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                  `path:"description" module:"nokia-conf"`
	Filter      *string                                                                  `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                  `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/dynsvc/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Dynsvc_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam represents the /nokia-conf/configure/groups/group/log/event-trigger/efm-oam YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                                 `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                     `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Event_Union                                                                        `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/efm-oam/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                              `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                  `path:"description" module:"nokia-conf"`
	Filter      *string                                                                  `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                  `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/efm-oam/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EfmOam_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi represents the /nokia-conf/configure/groups/group/log/event-trigger/elmi YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                             `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                 `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Event_Union                                                                      `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/elmi/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                            `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                `path:"description" module:"nokia-conf"`
	Filter      *string                                                                `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/elmi/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Elmi_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering represents the /nokia-conf/configure/groups/group/log/event-trigger/ering YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                               `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                   `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Event_Union                                                                       `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/ering/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                             `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                 `path:"description" module:"nokia-conf"`
	Filter      *string                                                                 `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                 `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/ering/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ering_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm represents the /nokia-conf/configure/groups/group/log/event-trigger/eth-cfm YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                                 `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                     `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Event_Union                                                                        `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/eth-cfm/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                              `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                  `path:"description" module:"nokia-conf"`
	Filter      *string                                                                  `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                  `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/eth-cfm/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_EthCfm_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun represents the /nokia-conf/configure/groups/group/log/event-trigger/etun YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                             `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                 `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Event_Union                                                                      `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/etun/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                            `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                `path:"description" module:"nokia-conf"`
	Filter      *string                                                                `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/etun/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Etun_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter represents the /nokia-conf/configure/groups/group/log/event-trigger/filter YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                                 `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                     `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Event_Union                                                                        `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/filter/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                              `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                  `path:"description" module:"nokia-conf"`
	Filter      *string                                                                  `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                  `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/filter/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Filter_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls represents the /nokia-conf/configure/groups/group/log/event-trigger/gmpls YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                               `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                   `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Event_Union                                                                       `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/gmpls/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                             `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                 `path:"description" module:"nokia-conf"`
	Filter      *string                                                                 `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                 `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/gmpls/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gmpls_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp represents the /nokia-conf/configure/groups/group/log/event-trigger/gsmp YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                             `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                 `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Event_Union                                                                      `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/gsmp/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                            `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                `path:"description" module:"nokia-conf"`
	Filter      *string                                                                `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/gsmp/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Gsmp_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh represents the /nokia-conf/configure/groups/group/log/event-trigger/igh YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                           `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                               `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Event_Union                                                                     `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/igh/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                           `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                               `path:"description" module:"nokia-conf"`
	Filter      *string                                                               `path:"filter" module:"nokia-conf"`
	Handler     *string                                                               `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/igh/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igh_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp represents the /nokia-conf/configure/groups/group/log/event-trigger/igmp YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                             `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                 `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Event_Union                                                                      `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping represents the /nokia-conf/configure/groups/group/log/event-trigger/igmp-snooping YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                                             `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                                 `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Event_Union                                                                              `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/igmp-snooping/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                                    `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                        `path:"description" module:"nokia-conf"`
	Filter      *string                                                                        `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                        `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/igmp-snooping/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce) IsYANGGoStruct() {
}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_IgmpSnooping_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/igmp/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                            `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                `path:"description" module:"nokia-conf"`
	Filter      *string                                                                `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/igmp/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Igmp_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip represents the /nokia-conf/configure/groups/group/log/event-trigger/ip YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                         `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                             `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Event_Union                                                                    `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/ip/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                          `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                              `path:"description" module:"nokia-conf"`
	Filter      *string                                                              `path:"filter" module:"nokia-conf"`
	Handler     *string                                                              `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/ip/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ip_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec represents the /nokia-conf/configure/groups/group/log/event-trigger/ipsec YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                               `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                   `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Event_Union                                                                       `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/ipsec/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                             `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                 `path:"description" module:"nokia-conf"`
	Filter      *string                                                                 `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                 `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/ipsec/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Ipsec_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis represents the /nokia-conf/configure/groups/group/log/event-trigger/isis YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                             `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                 `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Event_Union                                                                      `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/isis/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                            `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                `path:"description" module:"nokia-conf"`
	Filter      *string                                                                `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/isis/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Isis_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp represents the /nokia-conf/configure/groups/group/log/event-trigger/l2tp YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                             `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                                 `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Event_Union                                                                      `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/l2tp/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                            `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                                `path:"description" module:"nokia-conf"`
	Filter      *string                                                                `path:"filter" module:"nokia-conf"`
	Handler     *string                                                                `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce represents the /nokia-conf/configure/groups/group/log/event-trigger/l2tp/entry/debounce YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce struct {
	Time  *uint32 `path:"time" module:"nokia-conf"`
	Value *uint32 `path:"value" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce) IsYANGGoStruct() {}

// GetTime retrieves the value of the leaf Time from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Time is set, it can
// safely use t.GetTime() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Time == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce) GetTime() uint32 {
	if t == nil || t.Time == nil {
		return 0
	}
	return *t.Time
}

// GetValue retrieves the value of the leaf Value from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Value is set, it can
// safely use t.GetValue() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Value == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce) GetValue() uint32 {
	if t == nil || t.Value == nil {
		return 0
	}
	return *t.Value
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_L2Tp_Entry_Debounce) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag represents the /nokia-conf/configure/groups/group/log/event-trigger/lag YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag struct {
	AdminState  E_NokiaTypesSros_AdminState                                                                                                           `path:"admin-state" module:"nokia-conf"`
	Description *string                                                                                                                               `path:"description" module:"nokia-conf"`
	Entry       map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry `path:"entry" module:"nokia-conf"`
	Event       NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Event_Union                                                                     `path:"event" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) IsYANGGoStruct() {}

// NewEntry creates a new entry in the Entry list of the
// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag struct. The keys of the list are populated from the input
// arguments.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) NewEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Id_Union) (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry, error) {

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry)
	}

	key := Id

	// Ensure that this key has not already been used in the
	// list. Keyed YANG lists do not allow duplicate keys to
	// be created.
	if _, ok := t.Entry[key]; ok {
		return nil, fmt.Errorf("duplicate key %v for list Entry", key)
	}

	t.Entry[key] = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry{
		Id: Id,
	}

	return t.Entry[key], nil
}

// RenameEntry renames an entry in the list Entry within
// the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag struct. The entry with key oldK is renamed to newK updating
// the key within the value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) RenameEntry(oldK, newK NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Id_Union) error {
	if _, ok := t.Entry[newK]; ok {
		return fmt.Errorf("key %v already exists in Entry", newK)
	}

	e, ok := t.Entry[oldK]
	if !ok {
		return fmt.Errorf("key %v not found in Entry", oldK)
	}
	e.Id = newK

	t.Entry[newK] = e
	delete(t.Entry, oldK)
	return nil
}

// GetOrCreateEntry retrieves the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag. If the entry does not exist, then it is created.
// It returns the existing or new list member.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) GetOrCreateEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry {

	key := Id

	if v, ok := t.Entry[key]; ok {
		return v
	}
	// Panic if we receive an error, since we should have retrieved an existing
	// list member. This allows chaining of GetOrCreate methods.
	v, err := t.NewEntry(Id)
	if err != nil {
		panic(fmt.Sprintf("GetOrCreateEntry got unexpected error: %v", err))
	}
	return v
}

// GetEntry retrieves the value with the specified key from
// the Entry map field of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag. If the receiver is nil, or
// the specified key is not present in the list, nil is returned such that Get*
// methods may be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) GetEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Id_Union) *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry {

	if t == nil {
		return nil
	}

	key := Id

	if lm, ok := t.Entry[key]; ok {
		return lm
	}
	return nil
}

// DeleteEntry deletes the value with the specified keys from
// the receiver NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag. If there is no such element, the function
// is a no-op.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) DeleteEntry(Id NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Id_Union) {
	key := Id

	delete(t.Entry, key)
}

// AppendEntry appends the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry struct to the
// list Entry of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag. If the key value(s) specified in
// the supplied NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry already exist in the list, an error is
// returned.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) AppendEntry(v *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) error {
	key := v.Id

	// Initialise the list within the receiver struct if it has not already been
	// created.
	if t.Entry == nil {
		t.Entry = make(map[NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Id_Union]*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry)
	}

	if _, ok := t.Entry[key]; ok {
		return fmt.Errorf("duplicate key for list Entry %v", key)
	}

	t.Entry[key] = v
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_disable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetEvent retrieves the value of the leaf Event from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Event is set, it can
// safely use t.GetEvent() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Event == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) GetEvent() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Event_Union {
	if t == nil || t.Event == nil {
		return nil
	}
	return t.Event
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_disable
	}
	for _, e := range t.Entry {
		e.PopulateDefaults()
	}
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"event": t.Event,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag) ΛBelongingModule() string {
	return "nokia-conf"
}

// NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry represents the /nokia-conf/configure/groups/group/log/event-trigger/lag/entry YANG schema element.
type NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry struct {
	AdminState  E_NokiaTypesSros_AdminState                                           `path:"admin-state" module:"nokia-conf"`
	Debounce    *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Debounce `path:"debounce" module:"nokia-conf"`
	Description *string                                                               `path:"description" module:"nokia-conf"`
	Filter      *string                                                               `path:"filter" module:"nokia-conf"`
	Handler     *string                                                               `path:"handler" module:"nokia-conf"`
	Id          NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Id_Union  `path:"id" module:"nokia-conf"`
}

// IsYANGGoStruct ensures that NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry implements the yang.GoStruct
// interface. This allows functions that need to handle this struct to
// identify it as being generated by ygen.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) IsYANGGoStruct() {}

// GetOrCreateDebounce retrieves the value of the Debounce field
// or returns the existing field if it already exists.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) GetOrCreateDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Debounce {
	if t.Debounce != nil {
		return t.Debounce
	}
	t.Debounce = &NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Debounce{}
	return t.Debounce
}

// GetDebounce returns the value of the Debounce struct pointer
// from NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry. If the receiver or the field Debounce is nil, nil
// is returned such that the Get* methods can be safely chained.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) GetDebounce() *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Debounce {
	if t != nil && t.Debounce != nil {
		return t.Debounce
	}
	return nil
}

// GetAdminState retrieves the value of the leaf AdminState from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if AdminState is set, it can
// safely use t.GetAdminState() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.AdminState == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) GetAdminState() E_NokiaTypesSros_AdminState {
	if t == nil || t.AdminState == 0 {
		return NokiaTypesSros_AdminState_enable
	}
	return t.AdminState
}

// GetDescription retrieves the value of the leaf Description from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Description is set, it can
// safely use t.GetDescription() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Description == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) GetDescription() string {
	if t == nil || t.Description == nil {
		return ""
	}
	return *t.Description
}

// GetFilter retrieves the value of the leaf Filter from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Filter is set, it can
// safely use t.GetFilter() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Filter == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) GetFilter() string {
	if t == nil || t.Filter == nil {
		return ""
	}
	return *t.Filter
}

// GetHandler retrieves the value of the leaf Handler from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Handler is set, it can
// safely use t.GetHandler() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Handler == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) GetHandler() string {
	if t == nil || t.Handler == nil {
		return ""
	}
	return *t.Handler
}

// GetId retrieves the value of the leaf Id from the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry
// struct. If the field is unset but has a default value in the YANG schema,
// then the default value will be returned.
// Caution should be exercised whilst using this method since when without a
// default value, it will return the Go zero value if the field is explicitly
// unset. If the caller explicitly does not care if Id is set, it can
// safely use t.GetId() to retrieve the value. In the case that the
// caller has different actions based on whether the leaf is set or unset, it
// should use 'if t.Id == nil' before retrieving the leaf's value.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) GetId() NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry_Id_Union {
	if t == nil || t.Id == nil {
		return nil
	}
	return t.Id
}

// PopulateDefaults recursively populates unset leaf fields in the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry
// with default values as specified in the YANG schema, instantiating any nil
// container fields.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) PopulateDefaults() {
	if t == nil {
		return
	}
	ygot.BuildEmptyTree(t)
	if t.AdminState == 0 {
		t.AdminState = NokiaTypesSros_AdminState_enable
	}
	t.Debounce.PopulateDefaults()
}

// ΛListKeyMap returns the keys of the NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry struct, which is a YANG list entry.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) ΛListKeyMap() (map[string]interface{}, error) {

	return map[string]interface{}{
		"id": t.Id,
	}, nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) ΛValidate(opts ...ygot.ValidationOption) error {
	if err := ytypes.Validate(SchemaTree["NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry"], t, opts...); err != nil {
		return err
	}
	return nil
}

// Validate validates s against the YANG schema corresponding to its type.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) SROSValidate(opts ...ygot.ValidationOption) error {
	return t.ΛValidate(opts...)
}

// ΛEnumTypeMap returns a map, keyed by YANG schema path, of the enumerated types
// that are included in the generated code.
func (t *NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) ΛEnumTypeMap() map[string][]reflect.Type {
	return ΛEnumTypes
}

// ΛBelongingModule returns the name of the module that defines the namespace
// of NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry.
func (*NokiaConf_Configure_Groups_Group_Log_EventTrigger_Lag_Entry) ΛBelongingModule() string {
	return "nokia-conf"
}
